val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
val TypeRef(pre1, _, _) = t1
val TypeRef(pre2, _, _) = t2
pre1.typeSymbol
pre2.typeSymbol
ru
ru.asInstanceOf[{def mirrorThatLoaded(sym: Symbol): Mirror}
]
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}

import scala.reflect.runtime.universe._
import scala.reflect.runtime.{ currentMirror => cm }
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}

import scala.reflect.runtime.universe._
import scala.reflect.runtime.{ currentMirror => cm }
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
mirrorThatLoaded(t1)
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}

import scala.reflect.runtime.universe._
import scala.reflect.runtime.{ currentMirror => cm }
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
mirrorThatLoaded(t1)
val TypeRef(pre1, _, _) = t1
val TypeRef(pre2, _, _) = t2
mirrorThatLoaded(pre1)
mirrorThatLoaded(pre1.typeSymbol)
mirrorThatLoaded(pre2.typeSymbol)
classManifest[Int]
showRaw(typeOf[Int])
showRaw(reify(2 + 2).tree)
showRaw(reify(2 + 2).tree, printTypes = true)
" " * 2
exit
class ManifestTester {
  private final def toJavaMap[T, V](map: Map[T, V])(implicit m1: Manifest[T], m2: Manifest[V]): java.util.Map[_, _] = {
    map match {
      case m0: Map[Int, Int] => new java.util.HashMap[Integer, Integer]
      case m1: Map[Int, V] => new java.util.HashMap[Integer, V]
      case m2: Map[T, Int] => new java.util.HashMap[T, Integer]
      case _ => new java.util.HashMap[T, V]
    }
  }
}
val x: Manifest[Int] = null
def foo[T: Manifest] = ???
def foo[T: ClassManifest] = ???
def foo[T: Manifest] = ???
exit
def foo[T: Manifest] = ???
def foo[T: ClassManifest] = ???
def foo[T](implicit x: ClassManifest[T]) = ???
exit
def foo[T: ClassManifest] = ???
def foo[T](implicit x: ClassManifest[T]) = ???
def foo[T](implicit x: scala.reflect.ClassManifest[T]) = ???
def bar[T] = foo[T]
val x: ClassManifest[Int] = null
val y: ClassTag[Int] = null
x = y
var y: ClassTag[Int] = null
var x: ClassManifest[Int] = null
x = y
y = x
exit
@deprecated("foo", "2.10.0") def foo = ???
@deprecated("foo", "2.10.0") type T = Int
val x: T = 2
exit
typeOf[Int].member("$plus").asTermSymbol.resolveOverloaded(actuals = List(typeOf[Int]))
typeOf[Int].member(newTermName("$plus")).asTermSymbol.resolveOverloaded(actuals = List(typeOf[Int]))
exit
typeTag[(Int*) => Unit]
trait T
implicit val tag = typeTag[T]
implicit val tag = typeTag[String].asInstanceOf[TypeTag[T]]
println(tag.tpe)
val tree = reify { Nil : List[T] }.tree
trait T
implicit val tag = typeTag[String].asInstanceOf[TypeTag[T]]
val tree = reify { Nil : List[T] }.tree
class Foo { def bar(x: Int) = 2 }
new Foo().bar("
new Foo().bar("x")
implicit class Bar(x: Foo) { def bar(x: String) = 3 }
new Foo().bar("x")
ca
case class Foo()
trait X { def foo: Unit }
object Bar { def m(c: Context) = ??? }
import scala.reflect.makro.Context
object Bar { def m(c: Context) = ??? }
class C extends X { def foo = macro m }
class C extends X { def foo = macro Bar.m }
mirrorThatLoaded(typeOf[Int].typeSymbol)
showRaw(atype)
showRaw(atype2)
showRaw(atype, printIds = true)
showRaw(atype)
showRaw(atype, printIds = true)
showRaw(atype, printIds = true, printMirrors = true)
showRaw(atype2, printIds = true, printMirrors = true)
showRaw(atype, printIds = true, printMirrors = true)
typeOf[F].parents contains atype
typeOf[F].parents contains atype2
showRaw(atype)
showRaw(atype, printIds = true, printMirrors = true)
showRaw(atype2, printIds = true, printMirrors = true)
typeOf[F].parents
showRaw(typeOf[F].parents(1), printIds = true, printMirrors = true)
atype == atype2
atype2
typeOf[F].parents(1)
atype2 != res1
trait A[X]
trait B[Y] extends A[Y]
trait D
trait E extends A[D]
trait F extends A[String]
val atype = typeOf[A[String]]
val atype2 = typeOf[F].parents(1)
atype == atype2
class C { def foo(x: Int)(y: Int) = x + y }
object C { def foo(x: Int)(y: Int) = x + y }
cm.reflectModule("C")
class C { def foo(x: Int)(y: Int) = x + y }
cm.reflect(new C)
res1.reflectMethod(res1.symbol.member(newTermName("foo)))
res1.reflectMethod(res1.symbol.member(newTermName("foo:)))
res1.reflectMethod(res1.symbol.member(newTermName("foo")))
res1.reflectMethod(res1.symbol.typeSignature.member(newTermName("foo")))
res1.reflectMethod(res1.symbol.asTypeSymbol.typeSignature.member(newTermName("foo")))
res1.reflectMethod(res1.symbol.typeSignature.member(newTermName("foo")).asMethodSymbol)
res5(1, 2)
classOf[String]
ClassTag.String
classTag[String]
scala.reflect.classTag[String]
ClassTag.String
scala.reflect.ClassTag.String
exit
"""#\d+""".r.replaceAllIn("a#12121, b#3232", "<id>")
showRaw(reify(2), printTypes = true, printMirrors = true)
showRaw(reify(2).tree, printTypes = true, printMirrors = true)
showRaw(reify(2).tree, printTypes = true)
  val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
  val tree1 = reify(new collection.immutable.HashMap[String, String])
  val tree2 = reify(new collection.mutable.HashMap[String, String])
tb.typeCheck(tree1.tree)
showRaw(res3, printTypes = true, printMirrors = true)
  val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
  val tree1 = reify(new collection.immutable.HashMap[String, String])
  val tree2 = reify(new collection.mutable.HashMap[String, String])
tb.typeCheck(tree1.tree)
showRaw(res0, printTypes = true, printMirrors = true)
def foo[T <: Int] = reify(List[T]())
def foo[T] = reify(List[T]())
class Foo {
type T
reify(List[T]())
}
class Foo {
type T = Int
reify(List[T]())
}
class Foo {
type T = Int
def mkT: T = 0
reify(List[T](mkT, mkT))
}
type FootnoteIndex = collection.mutable.Map[Class, collection.mutable.WeakHashMap[Any, Int]]
type FootnoteIndex = collection.mutable.Map[Class[_], collection.mutable.WeakHashMap[Any, Int]]
new FootnoteIndex()
FootnoteIndex()
val s = TreeSet[Int]()
val s = collection.mutable.TreeSet[Int]()
s += 1
s += 5
s += 2
s
collection.mutable.WeakHashMap[Any, Int]()
collection.mutable.TreeSet(1, 5, 2)
collection.mutable.TreeSet(1, 5, 2).map(i => (i, i))
collection.mutable.SortedSet(1, 5, 2).map(i => (i, i))
collection.mutable.SortedSet(1, 5, 2).map(i => (i, i.toString))
collection.mutable.SortedSet(1, 5, 2).map(i => (i, new Object))
showRaw(typeOf[Int])
showRaw(typeOf[List[Int]], printIds = true, printMirrors = true)
Map[Class[_], SortedSet[Int]]() withDefault (key => SortedSet[Int]())
import scala.collection.mutable.{Map, WeakHashMap, SortedSet}
Map[Class[_], SortedSet[Int]]() withDefault (key => SortedSet[Int]())
res2(typeOf[Int]) += 1
res2(typeOf[Int])
res0(typeOf[Int])
res0(scala.reflect.runtime.universe.typeOf[Int])
res0(classOf[Int]) += 1
res0(classOf[Int])
showRaw(typeOf[Int])
showRaw(typeOf[List[Int]], printIds = true, printMirrors = true)
classOf[Object].getSuperClass
classOf[Object].getSuperclass
showRaw(typeOf[List[Int]], printIds = true, printMirrors = true)
showRaw(typeOf[List[Int]], printIds = true)
showRaw(typeOf[List[Int]])
show(typeOf[List[Int]])
typeOf[{def foo(x: Int): Int}]
typeOf[String]
exit
staticModule("java.lang")
cm.staticModule("java.lang")
res1.typeSignature
res2.members
res2.moduleClass.typeSignature
res1.moduleClass.typeSignature
res1.moduleClass.typeSignature.members
res1.moduleClass
IntTpe
JavaLangPackage
JavaLangPackage.parent
JavaLangPackage.owner
typeOf[{def foo(x: Int): Int}]
typeOf[Nothing]
typeOf[Null]
typeOf[scala.Null]
typeOf[Any]
typeOf[List[Any]]
typeOf[{def foo(x: Int): Int}]
cm.selectType(ScalaPackage, "AnyRef")
build.selectType(ScalaPackage, "AnyRef")
typeOf[{def foo(x: Int): Int}]
typeOf[(Int*) => Unit]
typeOf[(=> Int) => Unit]
typeOf[String].members(0)
typeOf[String].members.toList(0)
res0.typeSignature
val MethodType(params, ret) = res0.typeSignature
class Foo; object Foo
typeOf[Foo]
res1.typeSymbol
res0.typeSymbol
res0.typeSymbol.companionSymbol
showRaw(res0, printKinds = true)
class Foo

object Foo
typeOf[Foo.type]
showRaw(res0, printKinds = true)
res0.typeSymbol.companionSymbol
res0.typeSymbol
res0.typeSymbol.kinds
res0.typeSymbol.kind
res0.typeSymbol.companionSymbol.kind
res0.typeSymbol.companionSymbol.getClass
res0.typeSymbol.getClass
res0.typeSymbol.isModule
typeOf[Foo]
class Foo; object Foo
typeOf[Foo.type].typeSymbol
typeOf[Foo.type].typeSymbol.getClass
typeOf[Foo.type].typeSymbol.typeSignature
typeOf[Foo.type].typeSymbol.typeSignature.selfType
typeOf[Foo.type].typeSymbol.selfType
typeOf[Foo.type].typeSymbol.asClassSymbol
typeOf[Foo.type].typeSymbol.asClassSymbol.selfType
typeOf[Foo.type].typeSymbol.asClassSymbol.selfType.termSymbol
typeOf[Foo.type].typeSymbol.asClassSymbol.selfType.asInstanceOf[scala.tools.nsc.Global#Type].termSymbol
typeOf[{def foo(x: Int): Int}]
cm.selectType(ScalaModule.moduleClass, "AnyRef")
build.selectType(ScalaModule.moduleClass, "AnyRef")
build.selectType(staticModule("scala").moduleClass, "AnyRef")
build.selectType(cm.staticModule("scala").moduleClass, "AnyRef")
typeOf[{def foo(x: Int): Int}]
 def f1 = classManifest[Predef.ArrowAssoc[_]]
class A; class B { def foo(x: A) = 1 }
cval im = cm.reflect(new B)
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)
res0(new A)
exit
exity
exit
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
im.reflectMethod(method)
class A; class B { def foo(x: A) = 1 }; val im = cm.reflect(new B); val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol; im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val cm = reflect.runtime.currentMirror
val cm = scala.reflect.runtime.currentMirror
val u = cm.universe
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(u.newTermName("foo")).asMethodSymbol
im.reflectMethod(method)
 res0(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(u.newTermName("foo")).asMethodSymbol
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)
 res0(new A)
class A; class B { def foo(x: A) = 1 }; val im = cm.reflect(new B); val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol; im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
println(classOf[A].getName)
println(classOf[B].getName)
class A
class B { def foo(x: A) = 1 }
val cm = reflect.runtime.currentMirror
val u = cm.universe
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(u.newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
exit
class A;classB
class A;class B
class A; class B
class A
class A; class B
t1
t2
showRaw(t1)
showRaw(t2)
t1 == t2
showRaw(typeOf[scala.Int])
showRaw(typeOf[scala.Int], printMirrors = true)
showRaw(scala.Int)
showRaw(typeOf[scala.Int])
showRaw(typeOf[scala.Int], printMirrors = true)
showRaw(cm.typeOf[scala.Int], printMirrors = true)
exit
showRaw(typeOf[scala.Int], printMirrors = true)
typeOf[GenTraversable[_]]
typeOf[scala.collection.GenTraversable[_]]
scala.tools.reflect.mkConsoleFrontEnd()
reify { trait Foo { val a: Int } }
c{
}
class X { def foo(x: Int) = ??? }; val MethodType(_, t1) = typeOf[X].declaration(newTermName("foo")); val t2 = typeOf[scala.Int]
class X { def foo(x: Int) = ??? }; val MethodType(_, t1) = typeOf[X].declaration(newTermName("foo")).typeSignature; val t2 = typeOf[scala.Int]
class X { def foo(x: Int): Int = ??? }; val MethodType(_, t1) = typeOf[X].declaration(newTermName("foo")).typeSignature; val t2 = typeOf[scala.Int]
t1 == t2
t1 =:= t2
t1 == t2
2
t1 == t2
case class TypeRef(pre: Type, sym: Symbol, args: List[Type])
t1 == t2
class A
val a = new A
val b = new A
case class A
:type -v def foo: Int
:type -v def foo: Int = ???
class A { def foo(x: Int*) = 1 }
typeOf[A] member newTermName("foo") typeSignature
res0.asInstanceOf[u.MethodType].params.head
res0.asInstanceOf[MethodType].params.head
res1.typeSignature
res2.typeSignature
class A { def foo(x: Int*) = 1 }
typeOf[A] member newTermName("foo") typeSignature
res0.asInstanceOf[MethodType].params.head
res1.typeSignature
x.typeSignature
 typeOf[(Any, Any)]
typeOf[(Int, Int)].erasure =:= typeOf[(Any, Any)]
 typeOf[Map[_, _]]
def impl(c: Context) = { println(c.typeOf[Map[_, _]]); c.literalUnit }
def foo = macro impl
foo
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
typeOf[(Int, Int)]
showRaw(res0)
reify(2)
sealed trait LaunchExp extends LazyExp[LaunchExp] with BaseExp { 
   type OpSemExp = LaunchExp 
   type Val = Lam
}
class BaseExp
class LazyExp[T]
sealed trait LaunchExpr extends LazyExp[LaunchExp] with BaseExp {
type OpSemExp = LaunchExp
type Val = Lam
}
sealed trait LaunchExp extends LazyExp[LaunchExp] with BaseExp {
type OpSemExp = LaunchExp
type Val = Lam
}
class BaseExp
class LazyExp[T] { type Lam }
sealed trait LaunchExp extends LazyExp[LaunchExp] with BaseExp {
type OpSemExp = LaunchExp
type Val = Lam
}
trait BaseExp
class LazyExp[T] { type Lam }
sealed trait LaunchExp extends LazyExp[LaunchExp] with BaseExp {
type OpSemExp = LaunchExp
type Val = Lam
}
class BaseLam[T](a: Any, b: Any)
class Idn
case class Lam(override val x: Idn, override val e: LaunchExp) 
   extends BaseLam[LaunchExp](x, e) with LaunchExp
typeOf[List[Int]] <:< typeOf[List[Any]]
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
do 2 with 3
foo 2 bar 3
reify(reify(2))
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class A; def foo = 2
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A { def x = 2 }
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
exit
class A; class B
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
trait ThirdParty { def invoke = println("right") }
trait WeatherIcon { def invoke = println("wrong") }
class MyClass {
    object objA extends ThirdParty
    object objB extends WeatherIcon
}
val stuff = typeOf[MyClass].members.filter(_.isValue).filter(_.typeSignature <:< typeOf[ThirdParty])
val objASymbol = stuff.head.asModuleSymbol
cm.reflect(new MyClass).reflectModule(objASymbol)
res0.companion
res0.instance
class A {
  var x: Int = 42
}

val a = new A

val im: InstanceMirror = cm.reflect(a)
val cs = im.reflectClass.symbol
val f = cs.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f) 
fm.field.isVariable
class A {
  var x: Int = 42
}
val a = new A
val im: InstanceMirror = cm.reflect(a)
val f = im.symbol.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f) 
fm.field.isVariable
fm.symbol.isVariable
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
exit
def impl(c: Context) = {
def cc: c.type with scala.reflect.makro.Context = ???
}
def impl(c: Context) = {
val cc: c.type with scala.reflect.makro.Context = c
}
3 + 4
class World { def update(x: Int, v: Int): World = new World }
var w = new World
w(1) = 2
var w = new World
class World { def update(x: Int, v: Int): World = new World }
var w = new World
w(1) = 2
w
var x = List(1, 2)
x(0) = 3
List(1, 2).iterator
res0.mkString
exit
List(1, 2, 3).max
List(1, 2, 3).max(i => i * 2)
"lost".capitalize
exit
1.compare(2)
exit
val xs = SortedSet(3, 2, 5, 6, 1)
val xs = TreeSet(3, 2, 5, 6, 1)
val xs = collection.immutable.SortedSet(3, 2, 5, 6, 1)
xs take 3
import scala.reflect.runtime.universe._
List(List(), (1,2))
def x[T : TypeTag](t: T) = typeOf[T]
x(List(List(), (1,2)))
showRaw(res1)
 x(List(List(), (1,2)).head)
showRaw(res3)
typeOf[Product]
showRaw(res5)
exit
val rng = new scala.util.Random(42)
rng.nextInt(100)
import collection.immutable.SortedSet
SortedSet(10, 2) ++ SortedSet(5, 3)
SortedSet(10, 2) ++ SortedSet(5, 3) take 1
SortedSet(10, 2) ++ (SortedSet(5, 3) take 1)
collection.immutable.SortedSet(1, 2, 3, 2)
1.0.toInt
typeOf[X]
isDifferent(instance, instance)
Experiment.isDifferent(instance, instance)
exit
typeOf[X]
case class X(s: String)
typeOf[X].members
typeTag[scala.Predef.ArrowAssoc[_]]
classTag[scala.Predef.ArrowAssoc[String]]
classManifest[scala.Predef.ArrowAssoc[String]]
classManifest[List[_]]
classManifest[List[Int]]
classManifest[List[_]]
staticClass("scala.List"
)
cm.staticClass("scala.List")
res0.fullName
cm.staticModule("scala")
res2.moduleClass.typeSignature member newTypeName("List")
res3.fullName
case class Test(first: String, second: String)
typeOf[Test].declarations
Foo.foo
exit
reify { trait Foo { val a: Int } }
getModule("scala")
getModule(newTrrmName("scala"))
getModule(newTermName("scala"))
exit
getModule(newTermName("B.C"))
:power
getModule(newTermName("B.C"))
new B>.C
new B.C
getModule(newTypeName("B.C"))
getCLass(newTypeName("B.C"))
getClass(newTypeName("B.C"))
getClassByName(newTypeName("B.C"))
package B { class C { override def toString = "package" } }
object B { class C { override def toString = "package" } }
getClass(newTypeName("B.C"))
definitions.getModule(newTypeName("B.C"))
definitions.getClass(newTypeName("B.C"))
exit
object foo { class A; class B }
cm.staticModule("foo").typeSignature
cm.staticModule("foo").typeSignature.members
cm.staticModule("foo").moduleClass.typeSignature
cm.staticModule("foo").moduleClass
cm.staticModule("foo").moduleClass.asTypeSymbol
cm.staticModule("foo").moduleClass.asTypeSymbol.typeSignature
cm.staticModule("foo").moduleClass.asTypeSymbol.typeSignature.members
"aaa" contains "."
"a.aa" contains "."
:power
exit
trait Y
trait X extends { val x: Int } with Y
exit
:type -v def foo: BaseUniverse#TypeTag[Int]
:type -v def foo: scala.reflect.base.Universe#TypeTag[Int]
:type -v def foo: scala.reflect.base.Universe#TypeTag[Int] = ???
ru.reify{object Test {
println("Hello World!")
} }
ru.showRaw(res0.tree)
ru.showRaw(ru.definitions.IntTpe)
ru.showRaw(ru.definitions.IntClass)
ru.showRaw(ru.definitions.IntClass.asType)
object O { def impl[T: c.TypeTag](c: Context) = ??? }
cm.staticModule("O")
reify(O)
reify(O).tpe
reify(O).staticTpe
reify(O).staticTpe.typeSymbol
reify(O).staticTpe.typeSymbol.moduleClass
reify(O).staticTpe.typeSymbol.asModuleSymbol.moduleClass
reify(O).staticTpe.typeSymbol.typeSignature
reify(O).staticTpe.typeSymbol.typeSignature(1)
reify(O).staticTpe.typeSymbol.typeSignature.tail.head
reify(O).staticTpe.typeSymbol.typeSignature.member(newTermName("impl"))
object O { def impl[T: c.TypeTag](c: Context) = ??? }
ru.reify(O).staticTpe.typeSymbol.typeSignature.member(newTermName("impl"))
object O { def impl[T: c.TypeTag](c: Context) = ??? }
val meth = ru.reify(O).staticTpe.typeSymbol.typeSignature.member(newTermName("impl"))
showRaw(meth.typeSignature)
import scala.reflect.runtime.{universe => ru}
trait X { def foo: String }
ru.typeOf[X]
res0.members
def foo[T: ru.TypeTag](x: T) = ru.typeOf[T]
foo(List(1, 2, 3))
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox
val tree = Apply(Select(Literal(Constant(40)),
newTermName("$plus")), List(Literal(Constant(2))))
println(ru.mkToolBox().runExpr(tree))
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox
val tree = Apply(Select(Literal(Constant(40)), newTermName("$plus")), List(Literal(Constant(2))))
ru.mkToolBox()
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox
val tree = Apply(Select(Literal(Constant(40)),
newTermName("$plus")), List(Literal(Constant(2))))
val cm = ru.runtimeMirror(getClass.getClassLoader)
println(cm.mkToolBox().runExpr(tree))
typeTag[List[Int]]
scala.reflect.runtime.currentMirror
cm
typeOf[List[Int]]
class Foo extends StaticAnnotation
class Foo extends annotation.StaticAnnotation
def foo(x: Int @Foo)
 = ???
def (x: @Foo) = ???
class Proof(expr: Any) extends annotation.StaticAnnotation
def trans[T](x: T, y: T, z: T)(a: Int @Proof(eq(x, y))) = ???
def trans[T](x: T, y: T, z: T)(a: Int @Proof eq(x, y)) = ???
def impl(c: Context) = c.literal(42)
def foo = macro(impl)
def impl(c: Context) = c.literal(42)
def foo = macro(impl)
def impl(c: Context) = c.literal(42)
def foo = macro(impl)
exit
def impl(c: Context) = c.literal(42)
def foo = macro(impl)
foo
def foo[T: Manifest] = println("hello")
foo[Int]
exit
def foo = macro(bar)
exit
def foo = macro(impl)
def impl(c: Context) = ???
def foo = macro(impl)
exit
def impl(c: Context) = ???
def foo = macro(impl)
foo
exit
typeOf[Int] stat_<:< typeOf[Int]
def impl(c: scala.reflect.macros.Context) = c.literal(42)
def foo = macro impl
foo
typeOf[List[Int]]
class C(val x: Int, val y: Int)
typeOf[C].members
import scala.concurrent._
Promise.successful(12)
res5.future.mapTo[Int].value
(res0.future.mapTo: Future[Int]).value
(res0.future.mapTo[Int]).value
exit
import scala.concurrent._
Promise.successful(12)
res0.future.mapTo[Int].value
(res0.future.mapTo: Future[Int].value
(res0.future.mapTo: Future[Int]).value
exit
import scala.concurrent._
Promise.successful(12)
res0.future.mapTo[Int].value
(res0.future.mapTo: Future[Int]).value
exit
class C { val x: Int = 2; def x(y: Int) = y }
typeOf[(=> Int)] =:= typeOf[Int]
def impl(c: Context)(s: c.Expr[String]): c.Expr[Any] = ???
def test(s: String) = macro impl
def test(s: String): Int = macro impl
exit
type =>!IO![X, Y] = (X, Y)
type !IO![X, Y] = (X, Y)
type IO[X, Y] = (X, Y)
X IO Y
type Foo = X IO Y
type IO[X, Y] = (X, Y)
Int IO Int
type IO[X, Y] = (X, Y)
type Foo = Int IO Int
:type Int IO Int
:type Foo
def f(x: Int: Ordering) = ???
case class C(x: Int, y: Int)
typeOf[C].declarations
ListMap(1 -> "1", 2 -> "2")
scala.collection.immutable.ListMap(1 -> "1", 2 -> "2")
scala.collection.immutable.ListMap(1 -> "1", 2 -> "2").toListMap
class C { def foo[T <: Int] = ??? }
typeOf[C].member("foo")
typeOf[C].member(newTermName("foo"))
val meth = typeOf[C].member(newTermName("foo")).asMethod
meth.typeParams
meth.typeParams(0)
meth.typeParams(0).info
meth.typeParams(0).typeSignature
meth.typeParams(0).typeSignature.kind
class C
implicit def c2int(c: C): Int = ???
implicitly[C => Int]
implicitly[C => Int](new C)
implicitly[C => Int]()(new C)
res0(new C)
reify(2)
class C
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}
val ctor = typeOf[C].member(nme.CONSTRUCTOR)
class C
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}
val ctor = typeOf[C].member(nme.CONSTRUCTOR)
val ctor = typeOf[C].member(nme.CONSTRUCTOR).asMethodSymbol
cm.reflectClass(typeOf[C].typeSymbol).reflectConstructor(ctor)
val c = typeOf[C].typeSymbol.asClassSymbol
cm.reflectClass(c).reflectConstructor(ctor)
val mm = cm.reflectClass(c).reflectConstructor(ctor)
mm()
List(1, 2).length
exit
def foo[T](x :
ds
)
def foo[T](x: Int) = ???
val 
d
}
val "".r(foo) = ""
foo(x = 2)
def foo(xs: Any*) = xs.length
definitions.ArrayClass
definitions.ArrayClass.decls
definitions.ArrayClass.declarations
definitions.ArrayClass.typeSignature.declarations
definitions.ArrayClass.typeSignature.declarations.last
val clone = res4
val m = res4
Array(1, 2).clone()
Array(1, 2).clone
val m = definitions.ArrayClass.typeSignature.declarations.last.asMethodSymbol
val m = definitions.ArrayClass.typeSignature.declarations.last.asMethod
cm.reflect(Array(1, 2)).reflectMethod(m)()
val m = definitions.ArrayClass.typeSignature.declarations.last.asMethod
definitions.ArrayClass.typeSignature.declarations
definitions.ArrayClass.typeSignature.declarations.head.asTerm
val f = res1
cm.reflect(Array(1, 2)).reflectField(f)
definitions.AnyClass.typeSignature.declarations
definitions.AnyValClass.typeSignature.declarations
definitions.AnyRefClass.typeSignature.declarations
definitions.ObjectClass.typeSignature.declarations
cm.reflect(1).reflectMethod(res0.head.asMethodSymbol)(1)
cm.reflect(1).reflectMethod(res0.head.asMethod)(1)
definitions.NullClass
definitions.NullClass.typeSignature.declarations
definitions.NothingClass.typeSignature.declarations
definitions.SingletonClass.typeSignature.declarations
:power
SingletonClass
SingletonClass.info.decls
AnnotationDefaultAttr.info.decls
magicSymbols
magicSymbols.filter(_.isType)
magicSymbols.filter(_.isType).foreach(s => { println("
magicSymbols.filter(_.isType).foreach(s => { println("=========="); println(s.name); println(s.info.decls) })
val m = definitions.AnyRefClass.typeSignature.member(newTermName("getClass")).asMethod
cm.reflect(1).reflectMethod(m)
cm.reflect(1).reflectMethod(m)()
val ctor = definitions.AnyValClass.typeSignature.head.asMethod
val ctor = definitions.AnyValClass.typeSignature.declarations.head.asMethod
cm.reflectClass(definitions.AnyValClass)
cm.reflectClass(definitions.AnyValClass).reflectConstructor(ctor)
res3()
val ctor = definitions.AnyValClass.typeSignature.declarations.head.asMethod
cm.reflectClass(definitions.AnyValClass).reflectConstructor(ctor)()
definitions.AnyRefClass.typeSignature.declarations.head.owner
definitions.AnyRefClass.typeSignature.declarations.foreach(println(_.owner))
definitions.AnyRefClass.typeSignature.declarations.foreach(x => println(x_.owner))
definitions.AnyRefClass.typeSignature.declarations.foreach(x => println(x.owner))
val x = typeOf[Int].declarations.head
x match { case definitions.ArraySymbol => "" }
x match { case definitions.ArrayClass => "" }
class C { override def getClass = ??? }
class C { override def getClass() = ??? }
class C { override def getClass(x: Int) = ??? }
def foo(x: Int*)(y: Int) = ???
def foo(x: Int*)(y: Int*) = ???
2.getClass
val x: Any = 2
x.getClass
synchronized(2)
"".synchronized(2)
typeOf[Int].declarations
typeOf[Int].declaration(newTermName(
"+"))
typeOf[Int].declaration(newTermName("$plus"))
cm.reflect(2).reflectMethod(res2)
cm.reflect(2).reflectMethod(res2.asMethod)
typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(0).asMethod
cm.reflect(2).reflectMethod(res5)
class C { def +(c: C) = ??? }
typeOf[C].member(newTermName("+"))
typeOf[AnyRef].declaration(newTermName("asInstanceOf"))
typeOf[AnyRef].declarations
typeOf[Any].declarations
cm.reflect("2").reflectMethod(typeOf[AnyRef].member(newTermName("clone")))()
cm.reflect("2").reflectMethod(typeOf[AnyRef].member(newTermName("clone")).asMethod)()
class C { def test(x: => Int) = x }
typeOf[C].member(newTermName("x")).asMethod
typeOf[C].member(newTermName("test")).asMethod
cm.reflect(new C).reflectMethod(res1)
res2(2)
res2(() => 2)
res2((() => 2).asInstanceOf[Function0[Int]])
res2((() => 2).asInstanceOf[Function1[Int]])
exit
typeOf[AnyRef].member(newTermName("wait")).asMethod
def foo(x: => Int*) = ???
def foo(x: (=> Int)*) = ???
def foo(x: => Int) = ???
def foo(x: => (Int*)) = ???
class C { var x = 2 }
class D extends C { override x = 3 }
class D extends C { override var x = 3 }
case class C(x: Int, y: Int = 2)
typeOf[C].decls.filter(_.isDefaultParam)
typeOf[C].declarations.filter(_.isDefaultParam)
typeOf[C].declarations.collect(_.isTerm).filter(_.isDefaultParam)
typeOf[C].declarations.collect(sym => sym.isTerm).filter(_.isDefaultParam)
typeOf[C].declarations.collect{ case sym => sym.isTerm }.filter(_.isDefaultParam)
typeOf[C].declarations.collect{ case sym if sym.isTerm => sym }.filter(_.isDefaultParam)
typeOf[C].declarations.collect{ case sym if sym.isTerm => sym }
typeOf[C].declarations.collect({ case sym if sym.isTerm => sym }).filter(sym => sym.isDefaultParam)
val decls = typeOf[C].declarations.collect{ case sym if sym.isTerm => sym }
decls filter (_.isDefaultParam)
val decls = typeOf[C].declarations.collect{ case sym if sym.isTerm => sym.asTerm }
decls filter (_.isDefaultParam)
classManifest[Int]
exit
classManifest[Int]
def foo[T: ClassManifest] = ()
foo[Int[]
foo[Int]
case class C(x: Int, y: Int = 2)
typeOf[C].decl(nme.CONSTRUCTOR)
typeOf[C].declaration(nme.CONSTRUCTOR)
res1.params
typeOf[C].declaration(nme.CONSTRUCTOR).asMethod
res3.params
res3.params filter (_.isDefault)
res3.params filter (_.asTerm.isDefault)
res3.params.flatten filter (_.asTerm.isDefault)
res3.params.flatten filter (_.asTerm.isDefaultParam)
typeOf[C].declaration(nme.CONSTRUCTOR).asMethod
case class C(x: Int, y: Int = 2)
typeOf[C].declaration(nme.CONSTRUCTOR).asMethod
res3.params.flatten filter (_.asTerm.isDefaultParam)
res1.params.flatten filter (_.asTerm.isDefaultParam)
case class C(x: Int, y: Int = 2)
val ctor = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod
ctor.params.flatten filter (_.asTerm.isDefaultParam)
IntClass
def foo[@specialized T] = null.asInstanceOf[T]
class C { def foo[@specialized T] = null.asInstanceOf[T] }
typeOf[C].decls
typeOf[C].declarations
val m = typeOf[C].declarations.tail.asMethod
val m = typeOf[C].declarations.toList.tail.asMethod
val m = typeOf[C].declarations.toList.last.asMethod
m.params
m.typeParams
m.typeParams.head.isSpecialized
class C(val x: Int) extends AnyVal { def foo = x }
typeOf[C].declarations
val d = typeOf[C].declarations.toList
d(0)
d(0).fullName
d(0).flags
showRaw(d(0).flags)
show(d(0).flags)
ru.show(d(0).flags)
ru.show(d(1).flags)
d
cm.reflect(new C(10)).reflectMethod(d(0).asMethod)
res9()
new C(10)
AnyValClass.declarations
AnyValClass.typeSignature.declarations
AnyValTpe
AnyValTpe.declarations
AnyValTpe.declarations.toList(1)
cm.reflect(new C(10)).reflectMethod(res16)
cm.reflect(new C(10)).reflectMethod(res16.asMethod)
res18()
exit
class C(val x: Int) extends AnyVal { def foo = x }
classTag[C]
typeTag[C]
cm.reflect(2).reflectMethod(AnyValTpe.declarations.toList(1).asMethod)
val plus = IntTpe.member(newTermName("$plus")).asTerm.alternatives.head.asMethod
plus.typeSignature
cm.reflect(2).reflectMethod(plus)
val plus = IntTpe.member(newTermName("$plus")).asTerm.alternatives.head.asMethod
cm.reflect(2).reflectMethod(plus)
2.getClass
typeOf[Int].member(newTermName("$plus")).asTerm.alternatives
typeOf[Int].member(newTermName("$plus")).asTerm.alternatives.map(sym => sym.typeSignature)
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("+")).asTerm.alternatives(3).asMethod)(2)
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod)(2)
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod)(2, 2)
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod)()
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod)(2)
2.toByte == 2.toShort
2.asInstanceOf[{def ==(x: Byte): Boolean}] == 2.toByte
val plus = typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod
cm.reflect(2.asInstanceOf[AnyRef]).reflectMethod(plus)
plus.owner.toType.erasure
plus.owner.asClassSymbol.,toType.erasure
plus.owner.asClassSymbol.toType.erasure
plus.owner.asClass.toType.erasure
Set(1, 2) ++ List(3)
class C { def foo = () }
cm.reflect(new C).reflectMethod(typeOf[C].member(newTermName("foo")).asMethod)()
class C { def foo = () }
cm.reflect(new C).reflectMethod(typeOf[C].member(newTermName("foo")).asMethod)()
exit
val MethodType(params, ret) = sortMethod.typeSignature
showRaw(sortMethod.typeSignature)
val sortMethod = typeOf[::[_]].member(newTermName("sorted"))
val sortMethod = typeOf[::[_]].member(newTermName("sorted")).asMethod
sortMethod.params
sortMethod.params(0)(0).isImplicit
sortMethod.params(0)(0).asTerm.isImplicit
sortMethod.params(0)(0) hasFlag Flag.IMPLICIT
typeOf[Int]
Integer(2)
new Integer(2)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Id {

}
def foo[T: TypeTag] = typeOf[T]
import scala.{Int => Foobzie}
foo[Foobzie]
import scala.reflect.runtime.{universe => ru}
foo[ru.Type]
reify(ru)
build.newNestedSymbol(IntClass, newTypeName("Bash"), NoPosition, MODULE, true)
res0.info
res0.typeSignature
build.setTypeSignature(build.newNestedSymbol(IntClass, newTypeName("Bash"), NoPosition, MODULE, true), NoType)
res0.typeSignature
typeOf[{ def x(x: Int): Int }]
)
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("2 + 2"))
scala.collection.mutable.ListBuffer(1, 2, 3)
scala.collection.mutable.ListBuffer(List(1))
res1.flatten
trait Foo { type T }
type Bar = T forSome Foo
def foo(implicit x: Int*)
= ???
foo(1, 2)
def foo(implicit x: Int*) = ()
foo(1, 2)
foo(1)
foo()
foo
implicit val x: Int = 1
foo
def foo(implicit x: Int*) = ()
foo
implicit val x: Int = 1
foo
exit
List(1) zip List(0)
List(1) zip List()
exit
object Impls { private def impl(c: Context) = ??? }
def foo = macro Impls.impl
object Impls { private def impl(c: Context) = ??? }
def foo = macro Impls.impl
reify { class C { type T } }
reify { abstract C }
reify { abstract class C }
reify { trait C }
reify { class C[+T] }
class C { def foo(x: Int = 2) = ??? }
sealed abstract type T
show(9024791446044960)
show(9024791446044960L)
ru.show(9024791446044960L)
ru.show(9024791446044960L.asInstanceOf[FlagSet])
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
val t = typeTag[Outer[Int]].tpe
val m = t.member(newTermName("m"))
m.typeSignature
m.typeSignatureIn(t)
m.typeSignatureIn(t).narrow
m.typeSignatureIn(t.narrow)
t.narrow
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
val t = typeOf[Outer[Int]]
val m = t.member(newTermName("m"))
m.typeSignatureIn(SuperType(ThisType(t.typeSymbol), t))
m.typeSignatureIn(t.narrow)
res0 =:= res1
showRaw(res0)
showRaw(res1)
m.typeSignatureIn(ThisType(t.typeSymbol))
m.typeSignatureIn(t)
m.typeSignatureIn(t).narrow
trait Foo { 
   def apply(i: Int): String 

}
 reify(new Foo { def apply(i: Int) = "hello"+i })
showRaw(res0.tree)
showRaw(res0.tree, printKinds = true)
def foo[T: TypeTag <: String] = ???
def foo[T <: String: TypeTag] = ???
ClassManifest.Int <:< ClassTag.Int
ClassManifest.Int >:> ClassTag.Int
ClassManifest.Int == ClassTag.Int
ClassManifest.classType(classOf[Int])
ClassTag.Int == ClassManifest.classType(classOf[Int])
exist
exit
ClassManifest.Int.runtimeClass
ClassManifest.Int.erasure == ClassTag.Int.erasure
exit
Manifest.Int <:< TypeTag.Int
TypeTag.Int <:< Manifest.Int
trait X { self: D.type => }
trait X { self: D.type => }; object D extends X
lazy val x = 2
lazy val (x, y) = (2, 3)
Map(1 -> 2)(1)
Map(1 -> 2)(2)
Map(1 -> 2).get(2)
:power
NoSymbol.defString
def foo[T, U] = ???
foo[Int]
ru.showRaw(17592186077248L.asInstanceOf[FlagSet])
ru.show(17592186077248L.asInstanceOf[FlagSet])
new Exception().getMessage
new Exception().toString
"%noffender".format()
def foo[T[_]: TypeTag] = ???
def foo[T[_]] = ???
def foo[M[_]](implicit ev: TypeTag[M[_]]) = ev
foo
foo[List]
scala.util.Properties.ScalaCompilerVersion
scala.util.Properties.versionString
System.getProperties()
ClassTag.Nothing
ClassTag.Nothing.mkArray
ClassTag.Nothing.make
ClassTag.Nothing.getClass.getMethods
ClassTag.Nothing.newArray(10)
exit
def foo[T: TypeTag] = implicitly[TypeTag[T]]
def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo[Int]
def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo[Int]
def bar[T] = foo[T]
def bar[T: TypeTag] = foo[T]
def bar[T: TypeTag] = foo[List[T]]
def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo[Int]
foo[List[Int]]
def bar[T] = foo[T]
def bar[T] = foo[List[T]]
def bar[T: TypeTag] = foo[T]
bar[Int]
def bar[T: TypeTag] = foo[List[T]]
bar[Int]
bar[List[Int]]
val ru = scala.reflect.runtime.universe
1
object c { def x(x: Int) = ???; def x(x: String) = ??? }
val x = c.x
ClassTag.Int <:< ClassTag.AnyVal
tb.runExpr(tb.parseExpr(
exit
))
tb.runExpr(tb.parseExpr("class C; new C"))
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("class C; new C"))
res2.getClass
val cm = scala.reflect.runtime.universe.runtimeMirror(getClass.getClassLoader)
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("class C; scala.reflect.classTag[C].runtimeClass"))
import scala.tools.reflect.ToolBox
exit
:paste
scala> import scala.reflect.runtime._ // requires scala-reflect.jar
                                      // in REPL it's implicitly added 
                                      // to the classpath
                                      // but in your programs
                                      // you need to do this on your own
import scala.reflect.runtime
scala> val cm = universe.runtimeMirror(getClass.getClassLoader)
cm @ 41d0fe80: reflect.runtime.universe.Mirror = JavaMirror with scala.tools.nsc.interpreter.IMain$TranslatingClassLoader...
scala> import scala.tools.reflect.ToolBox // requires scala-compiler.jar
                                          // in REPL it's implicitly added 
                                          // to the classpath
                                          // but in your programs
                                          // you need to do this on your own
import scala.tools.reflect.ToolBox
scala> val tb = cm.mkToolBox()
tb: scala.tools.reflect.ToolBox[reflect.runtime.universe.type] = scala.tools.reflect.ToolBoxFactory$ToolBoxImpl@3a962da5
scala> tb.runExpr(tb.parseExpr("class C; scala.reflect.classTag[C].runtimeClass"))
res2: Any = class __wrapper$1$f9d572ca0d884bca9333e251c64e980d$C$1
val cm = universe.runtimeMirror(getClass.getClassLoader)
import scala.tools.reflect.ToolBox // requires scala-compiler.jar
                                          // in REPL it's implicitly added 
                                          // to the classpath
                                          // but in your programs
                                          // you need to do this on your own
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("class C; scala.reflect.classTag[C].runtimeClass"))
val tb = cm.mkToolBox()
import scala.reflect.runtime.universe._
val x = build.newFreeTerm("x", typeOf[Int], 2)
val tb = cm.mkToolBox()
val x = build.newFreeTerm("x", typeOf[Int], 2)
tb.runExpr(Apply(Select(Ident(x), newTermName("$plus")), List(Literal(Constant(2))))
)
List(1, 2, 3)
1 :: 2 :: 3
1 :: 2 :: 3 :: Nil
abstract class Funky(val i: Int) extends AnyVal
def C[T] { def foo[T] = ??? }
typeOf[C[_]].member(newTermName("foo")).asMethodSymbol
class C[T] { def foo[T] = ??? }
typeOf[C[_]].member(newTermName("foo")).asMethodSymbol
typeOf[C[_]].member(newTermName("foo")).asMethod
foo.typeParams
val meth = typeOf[C[_]].member(newTermName("foo")).asMethod
meth.typeParams
class C[T] { def foo(x: T) = ??? }
val meth = typeOf[C[_]].member(newTermName("foo")).asMethod
meth.paramss
meth.params
meth.typeParams
case class C(x: Int, y: Int)
typeOf[C].members.filter(_.isCaseAccessor)
typeOf[C].members.collect{case x: TermSymbol => x}.filter(_.isCaseAccessor)
typeOf[C].members.collect{case x: TermSymbol => x}.filter(sym => sym.isCaseAccessor && sym.isM)
typeOf[C].members.collect{case x: MethodSymbol => x}.filter(_.isCaseAccessor)
typeOf[C].members
case class C(x: Int, y: Int)
typeOf[C].members.collect{case x: MethodSymbol => x}.filter(_.isCaseAccessor)
 typeOf[C].members.collect{case m: MethodSymbol if m.isCaseAccessor => (m.name -> m.returnType)}
class C(val x: Int, val y: Int)
typeOf[C].members.sorted
case class C(val x: Int, val y: Int)
typeOf[C].members.sorted
  val Listing, Album = Value
}
typeOf[ResponseType.Value].asInstanceOf[TypeRef].pre.typeSymbol
typeOf[ResponseType.Value].owner
typeOf[ResponseType.Value].typeSymbol
typeOf[ResponseType.Value].typeSymbol.owner
cm.reflectModule(res0)
cm.reflectModule(res0.asModule)
val moduleClass = typeOf[ResponseType.Value].asInstanceOf[TypeRef].pre.typeSymbol
val module = moduleClass.owner.member(moduleClass.name.toTermName)
val module = moduleClass.owner.typeSignature.member(moduleClass.name.toTermName)
cm.reflectModule(res0.asModule)
val module = moduleClass.owner.typeSignature
val module = moduleClass.owner.typeSignature.member(moduleClass.name.toTermName)
cm.reflectModule(module.asModule)
cm.reflectModule(module.asModule).instance
val moduleClass = typeOf[ResponseType.Value].asInstanceOf[TypeRef].pre.typeSymbol
val module = moduleClass.owner.typeSignature.member(moduleClass.name.toTermName)
cm.reflectModule(module.asModule).instance
case class C
typeOf[C].declarations
typeOf[C.type].declarations
typeOf[C.type].typeSymbol
typeOf[C.type].typeSymbol.name
typeOf[C].typeSymbol
res2 == res4
typeOf[C].owner.typeSymbol
typeOf[C].typeSymbol.owner.typeSignature
typeOf[C.type].typeSymbol.owner.typeSignature
case class C; def C(x: Int) = ???
typeOf[C].typeSymbol.owner.typeSignature
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C"))
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C")).asModule
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C")).suchThat(_.isModule)
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C")).suchThat(_.isModule).asModule
showRaw(typeOf[Int])
showRaw(typeOf[Int].typeSymbol)
showRaw(typeOf[Int].typeSymbol, printKinds = true)
import scala.reflect.runtime.{universe => ru}
ru.showRaw(typeOf[Int])
ru.showRaw(typeOf[Int].typeSymbol, printKinds = true)
tb = cm.mkToolBox()
val tb = cm.mkToolBox()
tb.mirror.classLoader
val tb = cm.mkToolBox()
tb.mirror.classLoader
tb.mirror.classLoader.getClass.getMethods
tb.mirror.classLoader.getClass.getDeclaredMethods
val t1 = tb.parseExpr("1 to 3 map (_+1)")
tb.runExpr(t1)
val t1 = tb.parseExpr("1 to 3 map (_+1)")
val tb = cm.mkToolBox()
val t1 = tb.parseExpr("def foo = 1 to 3 map (_+1); foo")
tb.runExpr(t1)
{
  def main(args: Array[String]) 
  {
    println("test")
  }
}
exit
scala.util.Try(1.toString)
 'scala.util.Try(1.toString)
scala.util.Try(1.toString)
def impl[A](c: reflect.macros.Context) = c.universe.reify(())
def impl[A](c: scala.reflect.macros.Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl[Any]
decl
def impl(c: Context) = c.reify(new { val x = 2 })
def impl(c: Context) = c.universe.reify(new { val x = 2 })
def foo = macro impl
foo
scala.reflect.runtime.universe.reify(new {val x = 2 })
class C
type X = C with { val amount: Int }
type X = { val amount: Int }
type X = { val amount: Int } with C
type X = ({ val amount: Int }) with C
type X = C with ({ val amount: Int })
case class C(x: Int, y: Int)
typeOf[C].members.collect{ case x: TermSymbol => x }
typeOf[C].members.collect{ case x: TermSymbol if x.isCaseAccessor => x }
typeOf[C].members.collect{ case x: TermSymbol if x.isCaseAccessor && x.isMethod => x }
typeOf[C].members.sorted.collect{ case x: TermSymbol if x.isCaseAccessor && x.isMethod => x }
exit
case class Test(a:String,b:List[Int])
typeOf[Test]
res0.members
res1.filter(_.isMethod).map(_.asMethod).toArray
val ms = res2.toList
val methods = res2.toList
val mirroredMethods = methods.flatMap(e => try
 {Some(lookAtMe.reflectMethod(e))} catch {case e:Throwable =>
 e.printStackTrace();None})
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass
sym.isSealed
res0.isSealed
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.isSealed
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.initialize
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.typeSignature
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.isSealed
val n = 1
ClassTag.Int.runtimeClass
n.getClass
classManifest[Object]
classManifest[List]
classManifest[List[_]]
classTag[List[_]]
classManifest[Int]
classManifest[String]
exit
classTag[List[_]]
classManifest[List[_]]
classManifest[String]
classManifest[String].toString
classManifest[Array[Int]]
classTag[Int]
classTag[Array[Int]]
classManifest[Array[Int]].erasure
res7.isArray
import scala.runtime.ScalaRunTime._
arrayElementClass(res7)
class C[T]
reify { object O; O }
reify { object O; O.asInstanceOf[Object] }
classTag[String].newArray(10)
ClassTag.Object
ClassTag.Object.runtimeClass
class W extends scala.annotation.Annotation
trait A {
     | @W val a: Int
     | }
trait A { @W val a: Int }
typeOf[A].members.last
res0.annotations
res0.getAnnotations
res0.initialize
res0.typeSignature
res0.getAnnotations
typeOf[A].members
cla
class ValueClass(val x: Int) extends AnyVal
def foo(x: Any) = x
foo(new ValueClass(1))
val x = new ValueClass(1)
foo(x)
classTag[ValueClass].runtimeClass.isAssignableFrom(x.getClass)
x.getClass
class ValueClass(val x: Int) extends AnyVal
new ValueClass(1).getClass
exit
classManifest[List[_]]
manifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exity
exit
class W extends scala.annotation.StaticAnnotation
class A { @W def x: Int = ??? }
typeOf[A].members.last
res0.typeSignature
res0.getAnnotations
typeOf[A].members
typeOf[A].members.first
typeOf[A].members(0)
typeOf[A].members.toList(0)
res6.getAnnotations
exit
class W extends scala.annotation.Annotation
class A { @W def x: Int = ??? }
typeOf[A].members.toList(0)
res0.getAnnotations
res0.typeSignature
res0.getAnnotations
exit
class W extends scala.annotation.StaticAnnotation
trait A { @W val a : Int }
typeOf[A].members.last
res0.getAnnotations
res0.typeSignature
res0.getAnnotations
exit
class W extends scala.annotation.Annotation
class W extends scala.annotation.StaticAnnotation
trait A { @W val a: Int }
typeOf[A].members.last
res0.getAnnotations
trait A { @W def a: Int }
typeOf[A].members.last
res2.getAnnotations
class W extends scala.annotation.ClassfileAnnotation
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.isSealed
type Foo = Annotation
type Foo = java.reflect.Annotation
type Foo = java.lang.reflect.Annotation
type Foo = java.lang.Annotation
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
val t = typeOf[Outer[Int]]
 val m = t.member(newTermName("m"))
m.typeSignature
m.typeSignatureIn(SuperType(ThisType(t.typeSymbol), t))
m.typeSignatureIn(t)
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
val t = typeOf[Outer[Int]]
 val m = t.member(newTermName("m"))
m.typeSignatureIn(t)
m.typeSignatureIn(SuperType(ThisType(t.typeSymbol), t))
m.typeSignatureIn(SingleType(t))
m.typeSignatureIn(t.narrow)
t.narrow
m.typeSignatureIn(SingleType(NoPrefix, t))
reify('foo)
typeOf[String]
weakTypeOf[String]
val tb = cm.mkToolBox(options = "-Yreify-copypaste")
tb.parseExpr("scala.reflect.runtime.universe.reify(2)")
tb.runExpr(res0)
val tb = cm.mkToolBox(options = "-Yreify-copypaste")
tb.parseExpr("scala.reflect.runtime.universe.reify(2)")
tb.runExpr(res0)
val a = 0.9
cm.reflect(a).symbol.asType <:< typeOf[Double]
cm.reflect(a).symbol.typeSignature <:< typeOf[Double]
cm.reflect(a).symbol.typeSignature
cm.reflect(a).symbol.toType
val a = 0.9
val t = cm.reflect(a).symbol.toType
t <:< typeOf[Double]
tpnme.ANON_CLASS_NAME
Apply(Select(
  Block(List(ClassDef(
    Modifiers(FINAL), tpnme.ANON_CLASS_NAME, Nil, 
    Template(List(Ident(AnyRefClass)), emptyValDef, Nil))),
  Apply(Select(New(Ident(tpnme.ANON_CLASS_NAME)), nme.CONSTRUCTOR), Nil))
, sn.GetClass), Nil)
Apply(Select(
  Block(List(ClassDef(
    Modifiers(scala.tools.nsc.symtab.Flags.FINAL), tpnme.ANON_CLASS_NAME, Nil, 
    Template(List(Ident(AnyRefClass)), emptyValDef, Nil))),
  Apply(Select(New(Ident(tpnme.ANON_CLASS_NAME)), nme.CONSTRUCTOR), Nil))
, sn.GetClass), Nil)
val t = typeOf[Outer[Int]]
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
 val m = t.member(newTermName("m"))
val t = typeOf[Outer[Int]]
 val m = t.member(newTermName("m"))
m.typeSignatureIn(t)
m.typeSignatureIn(ThisType(t.typeSymbol))
m.typeSignatureIn(ThisType(t))
showRaw(t)
m.typeSignatureIn(ThisType(t.typeSymbol))
m.typeSignatureIn(t)
m.typeSignatureIn(t).narrow
m.typeSignatureIn(SingleType(t.pre))
m.typeSignatureIn(SingleType(t.pre, t.typeSymbol))
type T = { def x: Int }
type U = { def y: Int}
type Z = T with U
import scala.reflect.runtime.universe._
// example 1
implicit val intTag = typeTag[Int]
import scala.reflect.runtime.universe._
// example 1
def foo[T](implicit tag: TypeTag[T]) = typeTag[Array[T]]
foo[List[Int]]
// example 2
val tpe = typeOf[Int]
appliedType(definitions.ArrayClass.asType, tpe)
appliedType(definitions.ArrayClass.toType, tpe)
appliedType(definitions.ArrayClass.toType, List(tpe))
val tpe = typeOf[List[Int]]
appliedType(definitions.ArrayClass.toType, List(tpe))
trait C { def x: Int }
trait T { def x: Int }
type E = { def y: Int }
type U = T with E
class C extends C { def x = 2; def y = 2 }
class C extends T { def x = 2; def y = 2 }
val u: U = new C
u.x
u.y
(int)null
null.asInstanceOf[Int]
object Foo { def unapply(x: Int): Option[Boolean] = Some(true) }
2 match { case Foo(x) => x }
import scala.collection.immutable.ListMap
ListMap(List((1, 2)))
List((1, 2)).toListMap
List((1, 2)).toMap
ListMap(List((1, 2)).toMap)
ListMap(List(1 -> 2))
ListMap(List(1 -> 2): _*)
import scala.collection.immutable.ListMap
ListMap(1 -> 2)
ListMap(1 -> 2).toList
typeOf[Foo].typeSymbol
exit
typeOf[Foo].typeSymbol
exit
val b: Any = true
b match { case b: Boolean => println(b) }
b.getClass
b match { case b: scala.Boolean => println(b) }
Array(1).getClass.isArray
Array(1, 2).asInstanceOf[Array[_]]
"11".substring(0, 1)
import scala.collection.immutable.ListMap
ListMap(1 -> 2, 3 -> 4)
class W extends scala.annotation.StaticAnnotation
trait A { @W def x: Int }
typeOf[A].declarations.toList
typeOf[A].declarations.head.getAnnotations
trait A { @W val x: Int }
typeOf[A].declarations.head.getAnnotations
typeOf[A].declarations
typeOf[A].declarations.head
typeOf[A].declarations.head.asMethodSymbol
typeOf[A].declarations.head.asMethod
typeOf[A].declarations.head.asMethod.field
typeOf[A].declarations.head.asMethod.accessed
class W extends scala.annotation.StaticAnnotation
trait A { @W val x: Int }
class C extends A
class C extends A { val x = 2 }
typeOf[C].declarations
typeOf[C].declarations.toList(1)
typeOf[C].declarations.toList(1).getAnnotations
typeOf[C].declarations.toList(2).getAnnotations
class W extends scala.annotation.StaticAnnotation
trait T { @W val x: Int }
typeOf[T].declarations
typeOf[T].declarations.head.getAnnotations
trait T { @(W @scala.annotation.meta.getter) val x: Int }
typeOf[T].declarations.head.getAnnotations
class C { val x: Int }
class C extends T { val x: Int = 2 }
typeOf[C].declarations
typeOf[C].declarations.toList(1).getAnnotations
typeOf[C].declarations.toList(2).getAnnotations
class W extends scala.annotation.ClassfileAnnotation
implicit object Foo
lazy object Foo
classOf[Array[_]
]
res0.isArray
classOf[Array[_]]
import java.lang.annotation.Annotation
def foo(c: Context) = { import c.universe._; ??? }
typeOf[List[_]].typeSymbol.asClass
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass
res1.isSealed
exit
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass
res0.isSealed
exit
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass
res0.isSealed
exit
val tb1 = cm.mkToolBox()
var i = 0
val action = reify { i += 1; println(i) }.tree
tb1.runExpr(action)
tb1.eval(action)
tb1.frontEnd.reset()
tb1.eval(action)
cm.mkToolBox()
tb.parse("def x = {}")
res0.parse("def x = {}")
res0.parse("def x = {")
res0.parse("def x = {}")
def impl[A](c: Context) = c.reify(())
def impl[A](c: Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl
val tb = cm.mkToolBox()
val expr = tb.parse("1 to 3 map (_+1)")
tb.typeCheck(expr)
scala.reflect.runtime.universe.reify(2)
reflect.runtime.universe.reify("foo")
scala.reflect.runtime.universe.reify("foo")
exit
val x = 0, y = 1
val x = 0; val y = 1
val tb = cm.mkToolBox()
tb.eval(tb.parse("math.sqrt(4.0)"))
tb.eval(tb.parse("1 to 5"))
tb.frontEnd.reset
tb.eval(tb.parse("1 to 5"))
tb.eval(tb.parse("scala.math.sqrt(4.0)"))
tb.eval(tb.parse("import scala._; import Predef._; math.sqrt(4.0)"))
tb
tb.eval(tb.parse("object C"))
tb.eval(ModuleDef(NoMods, newTermName("C"), Template(Nil, emptyValDef, Nil)))
scala.reflect.runtime.universe.typeOf[List].isSealed
scala.reflect.runtime.universe.typeOf[List[_]].isSealed
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass.isSealed
exit
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass.isSealed
exit
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass.isSealed
exit
tb.eval(tb.parse("object C; C"))
tb.eval(tb.parse("object C"))
tb.eval(tb.parse("scala.math.sqrt(4.0)"))
def echoThisImpl(c:Context): c.Expr[Any] = {
  import c.universe._
  val selfTree = This(c.enclosingClass.symbol)
  c.Expr[AnyRef](selfTree)
}
def echoThisImpl(c:Context): c.Expr[Any] = {
import c.universe._
val selfTree = This(c.enclosingClass.symbol)
c.Expr[AnyRef](selfTree)
}
def echoThis: Any = macro CallMacro.echoThisImpl
def echoThis: Any = macro echoThisImpl
val thisValue = CallMacro.echoThis
val thisValue = echoThis
class C { this }
Map(1 -> 1, 1 ->2 )
typeOf[Int]
classTag[Int]
classOf[Int]
typeOf[Int]
classOf[Int]
typeOf[Int]
typeOf[List[Int]]
reify(2)
classOf[Array[Int]]
classOf[Int]
clssTag[Int]
classTag[Int]
classTag[List[Int]]
classOf[Int]
classTag[Int]
classTag[List[Int]]
typeTag[List[Int]]
typeTag[Int]
def foo[T: ru.TypeTag] = manifest[T]
def foo[T: ClassTag: ru.TypeTag] = manifest[T]
"1\n2".split("\n")
typeOf[Int]
scala.reflect.runtime.universe.typeOf[Int]
exit
typeOf[scala.reflect.runtime.SymbolTable]
res0.baseClasses
res0.typeSymbol.name
res0.typeSymbol.fullName
def allBaseClasses = { def loop(tpe: Type): List[Type] = tpe.baseClasses.filter(_.typeSymbol.fullName.toString startsWith "scala.reflect").map(loop); loop(res0) }
def allBaseClasses = { def loop(tpe: Symbol): List[Symbol] = tpe.baseClasses.filter(_.typeSymbol.fullName.toString startsWith "scala.reflect").map(loop); loop(res0.typeSymbol) }
def allBaseClasses = { def loop(tpe: Symbol): List[Symbol] = tpe.asClass.baseClasses.filter(_.typeSymbol.fullName.toString startsWith "scala.reflect").map(loop); loop(res0.typeSymbol) }
def allBaseClasses = { def loop(tpe: Symbol): List[Symbol] = tpe.asClass.baseClasses.filter(_.fullName.toString startsWith "scala.reflect").map(loop); loop(res0.typeSymbol) }
def allBaseClasses = { def loop(tpe: Symbol): List[Symbol] = tpe.asClass.baseClasses.filter(_.fullName.toString startsWith "scala.reflect").map(loop).flatten; loop(res0.typeSymbol) }
allBaseClasses
def loop(tpe: Symbol): List[Symbol] = { val bases = tpe.asClass.baseClasses.filter(_.fullName.toString startsWith "scala.reflect"); bases.head +: bases.tail.map(loop).flatten }
loop(res0.typeSymbol)
def loop(tpe: Symbol): List[Symbol] = { val bases = tpe.asClass.baseClasses.filter(_.fullName.toString startsWith "scala.reflect.internal"); bases.head +: bases.tail.map(loop).flatten }
loop(res0.typeSymbol)
loop(res0.typeSymbol) map (_.asClass) map (_.typeSignature)
1
val sigs = res7
sigs.flatMap(_.declarations.toList)
val decls = sigs.flatMap(_.declarations.toList)
decls.filter(sym => sym.isVal || sym.isVar).foreach(println)
decls.collect{case ts: TermSymbol => ts}.filter(sym => sym.isVal || sym.isVar).foreach(println)
decls.collect{case ts: TermSymbol => ts}.filter(sym => !sym.name.toString.endsWith("Tag") && (sym.isVal || sym.isVar)).foreach(println)
decls.collect{case ts: TermSymbol => ts}.filter(sym => !sym.name.toString.trim.endsWith("Tag") && (sym.isVal || sym.isVar)).foreach(println)
Some(1).collect{case 1 => 2}
Some(1).collect{case 2 => 2}
import ru.QuasiQuote
import scala.reflect.runtime.universe
import universe.QuasiQuote
exit
:power
val tpe = UniqueConstantType(Constant(StringTpe))
val tpe = ConstantType(Constant(StringTpe))
val tpe = ConstantType(Constant(definitions.StringTpe))
val tpe = ConstantType(Constant(IntTpe))
tpe.underlying
Constant(IntTpe).tpe
afterPhase(1)
afterPhase(erasurePpahse)
afterPhase(erasurePhase)
afterPhase(erasure)
afterPhase(phaseNamed(erasure))
afterPhase(erasure)
afterPhase(run.erasure)
afterPhase(currentRun.erasure)
afterPhase(currentRun.erasurePhase)
ConstantType(Constant(IntTpe)).erasure
typed(1)
typed(Literal(Constant(1))
)
typed(Literal(Constant(1)))
typed(Literal(Constant(1))).tpe
typed(Literal(Constant(1))).tpe.underlying
typed(Literal(Constant(IntTpe))
)
typed(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe))))
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
typed(Apply(Ident(ListModule), List(Literal(Constant(1))))).tpe
afterPhase(currentRun.erasurePhase)(typed(Apply(Ident(ListModule), List(Literal(Constant(1))))).tpe)
New(ConsClass, Literal(Constant(1)), Ident(NilModule))
typed(New(ConsClass, Literal(Constant(1)), Ident(NilModule)))
New(appliedType(ConsClass, List(Ident(IntTpe))), Literal(Constant(1)), Ident(NilModule))
New(appliedType(ConsClass, List(Ident(IntClass))), Literal(Constant(1)), Ident(NilModule))
New(appliedType(ConsClass, Ident(IntClass)), Literal(Constant(1)), Ident(NilModule))
New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule))
typed(New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule)))
typed(New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(Apply(Ident(ListModule), List(Literal(Constant(1))))).tpe)
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule))).tpe)
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(1)), Ident(NilModule))).tpe
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe)
:power
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe)
typed(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
:power
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe)
typed(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
typed(Literal(Constant(IntClass.asTypeConstructor))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntClass.asTypeConstructor)))).tpe.underlying
macro def foo = ???
exit
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntClass.asTypeConstructor)))).tpe.underlying
exit
val head = typeOf[List[Int]].member(newTermName("head")).asMethod
head.returnType
println(showRaw(head.returnType))
val head = typeOf[List[Int]].member(newTermName("head")).asMethod
val head_a = head.returnType.typeSymbol
val TypeRef(_,_,List(a)) = typeOf[List[_]].typeSymbol.asType.toType
val list_a = a.typeSymbol
head_a eq list_a\
head_a eq list_a
val list = typeOf[List[_]].typeSymbol.asType.toType
val head = typeOf[List[Int]].member(newTermName("head")).asMethod
showRaw(list)
showRaw(head.typeSignature)
showRaw(list.returnType, printIds = true, printKinds = true)
showRaw(list, printIds = true, printKinds = true)
showRaw(head.returnType, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].member(newTermName("head")).typeSignature)
showRaw(typeOf[List[_]].member(newTermName("head")).typeSignature, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].member(newTermName("tail")).typeSignature, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].declaration(newTermName("tail")).typeSignature, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].declaration(newTermName("head")).typeSignature, printIds = true, printKinds = true)
val TypeRef(_, _, List(a)) = typeOf[List[_]].dealias.typeSymbol.asType.toType
val TypeRef(_, _, List(a)) = typeOf[List[_]].normalize.typeSymbol.asType.toType
showRaw(a, printIds = true, printKinds = true)
val TypeRef(_, _, List(type_parameter_of_list)) = typeOf[List[_]].dealias.typeSymbol.asType.toType
val TypeRef(_, _, List(type_parameter_of_list)) = typeOf[List[_]].normalize.typeSymbol.asType.toType
val NullaryMethodType(type_parameter_of_head) = typeOf[List[_]].declaration(newTermName("head")).typeSignature
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
ConstantType(Constant(IntTpe))
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(IntTpe)))
typed(Literal(Constant(StringTpe))).tpe.underlying
typed(Literal(Constant(StringTpe))).tpe.getClass
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(StringTpe)))
afterPhase(currentRun.erasurePhase)(Literal(Constant(IntTpe)))
afterPhase(currentRun.erasurePhase)(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
Constant(IntTpe).tpe
Constant(IntTpe).typeValue
afterPhase(currentRun.erasurePhase)(Constant(IntTpe).typeValue)
afterPhase(currentRun.erasurePhase)(Constant(IntTpe))
afterPhase(currentRun.erasurePhase)(Constant(IntTpe).tpe)
:power
RootClass
RootClass.id
JavaPackage
JavaLangPackageClass.id
JavaLangPackage.id
JavaLangPackageClass.owner
JavaLangPackageClass.owner.id
showRaw(StringTpe, printIds = true)
:power
transformedType
transformedType(IntTpe)
showRaw(res1, printIds = true)
ConstantType(Constant(res1))
ConstantType(Constant(res1)).underlying
typed(Literal(Constant(res2)))
typed(Literal(Constant(res2))).tpe
typed(Literal(Constant(res1))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(res1))))
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(res1)))).tpe
ConstantType(Constant(res1)).getClass
transformedType(StringClass.toType)
showRaw(res11, printIds = true)
ConstantType(Constant(res11))
ConstantType(Constant(res11)).underlying
res11
ConstantType(Constant(res11)).underlying
ConstantType(Constant(res11))
exit
val s = transformedType(StringClass.toType)
:power
val s = transformedType(StringClass.toType)
showRaw(s)
ConstantType(Constant(s))
exit
val s = transformedType(StringClass.toType)
ConstantType(Constant(s))
Constant(s).##
new UniqueConstantType(Constant(s)).##
unique
new UniqueConstantType(Constant(s)) == new UniqueConstantType(Constant(s))
ConstantType(Constant(s)) == ConstantType(Constant(s))
ConstantType(Constant(s)) eq ConstantType(Constant(s))
ConstantType(Constant(s))
ConstantType(Constant(s)).##
:power
val s = transformedType(StringClass.toType)
val s = transformedType(StringClass.asTypeConstructor)
showRaw(s)
ConstantType(Constant(s))
System.identityHashCode(ConstantType(Constant(s)))
uniques
unique
exit
:power
val s = transformedType(StringClass.asTypeConstructor)
val s = transformedType(StringClass.toType)
Constant(StringClass.toType)
Constant(s)
res0.##
res1.##
Constant(s)
Constant(s).##
Constant(StringClass.toType).##
ConstantType(res0).##
ConstantType(res1).##
exit
val s = transformedType(StringClass.toType)
ConstantType(Constant(s))
{ ConstantType(Constant(s)); ConstantType(Constant(s)) }
{ println(ConstantType(Constant(s))); afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); }
exit
:power
val s = transformedType(StringClass.toType)
{ val t1 = ConstantType(Constant(s))); println(t1.underlying); val t2 = afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); println(t2.underlying); }
{ val t1 = ConstantType(Constant(s)); println(t1.underlying); val t2 = afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); println(t2.underlying); }
{ val t1 = ConstantType(Constant(s)); println(t1.underlying); val t2 = afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); println(t2.underlying); println(t2) }
{ val t1 = ConstantType(Constant(s)); println(t1.underlying); println(afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))); }
{ val t1 = ConstantType(Constant(s)); println(afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))); }
{ println(afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))); }
Seq(1, 2).toString
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
{ afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); ConstantType(Constant(s)) }
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
cm.staticModule("scala.math.package")
cm.reflectModule(res0)
res1.runtimeClass
res1.instance
NoSymbol.baseClasses
EnumType(NoSymbol)
EnumType(IntClass)
q""
typeOf[List[_]].typeSymbol.asClass.isSealed
trait A { type T <: A }
trait B { type T <: B }
glb(typeOf[A], typeOf[B])
glb(List(typeOf[A], typeOf[B]))
ru.asInstanceOf[scala.reflect.internal.Types].uniques
ru.asInstanceOf[scala.reflect.internal.Types].uniques.asInstanceOf[scala.reflect.internal.util.HashSet[_]]
trait A { type T <: A }
trait B { type T <: B }
uniques
glb(List(typeOf[A], typeOf[B]))
uniques
glb(List(typeOf[A], typeOf[B]))
uniques
trait A1 { type T <: A1 }
trait B1 { type T <: B1 }
uniques
glb(List(typeOf[A1], typeOf[B1]))
uniques
glb(List(typeOf[A1], typeOf[B1]))
uniques
Runtime.freeMemort
Runtime.freeMemory
Runtime.freeMemory()
java.lang.Runtime.freeMemory()
Runtime.getRuntime().freeMemory()
Array(1, 2).sum
val arr = Array(1, 2)
arr.toArray[Any]
trait A { type T <: A }
trait B { type T <: B }
typeOf[A with B]
typeOf[List[List[A with B]]]
scala.math.`package`
def impl(c: Context) = c.literal(c.compilerSettings)
def impl(c: Context) = c.literal(c.compilerSettings.toString)
def foo = macro impl
foo
def impl(c: Context) = c.literal(show(c.libraryClassLoader))
def foo = macro impl
foo
val cache = scala.collection.mutable.HashMap[scala.reflect.macros.Context#Run, Int]()
def impl(c: Context) = c.literal(cache(c.currentRun) = cache.getOrElseUpdate(c.currentRun, 0) + 1)
def impl(c: Context) = c.literal({cache(c.currentRun) = cache.getOrElseUpdate(c.currentRun, 0) + 1; cache(c.currentRun)})
def foo = macro impl
foo
{ foo; foo }
def foo[T] = println(showRaw(weakTypeOf[List[T]]))
foo
typeOf[scala.math.type]
typeOf[scala.math.`package`.type]
res1.typeSymbol
showRaw(res1.typeSymbol.flags)
res1.typeSymbol.isPackageClass
res1.typeSymbol.isModuleClass
List() forall (_ % 2 == 1)
List[Int]() forall (_ % 2 == 1)
shiowRaw(res0.staticCpe)
showRaw(res0.staticTpe)
showRaw(res0.)
showRaw(res0.ac
showRaw(res0.ac))
showRaw(res0.actualTpe)
res0.
))
showRaw(res0.staticType)
List().toHashSet
exit
1 to 10 foreach (_ => Thread.sleep(1000))
exit
class S(x: Int, y: Int) extends scala.annotation.StaticAnnotation
@S(1 + 1, 2) class C
import scala.reflect.runtime._
import scala.reflect.runtime.universe._
import scala.reflect.runtime.currentMirror
import scala.reflect.runtime.{currentMirror => cm}
val c = typeOf[C].typeSymbol
val c = cm.staticClass("C")
val c = typeOf[C].typeSymbol
c.annotations
showRaw(c.annotations)
showRaw(c.annotations(0))
c.annotations(0).scalaArgs
c.annotations(0).javaArgs
val x = 2
@S(x, 2) class C
val c = typeOf[C].typeSymbol
c.annotations(0).scalaArgs
import scala.reflect.runtime.universe._
class C(x: Int, y: Int) extends scala.annotation.StaticAnnotation
class S(x: Int, y: Int) extends scala.annotation.StaticAnnotation
val x = 2
@S(x, 2) class C
val c = typeOf[C].typeSymbol
c.annotations
showRaw(c.annotations(0).scalaArgs(0))
showRaw(c.annotations(0).scalaArgs(1))
class J(x: Int, y: Int) extends scala.annotation.ClassfileAnnotation
import scala.reflect.runtime.universe._
showRaw(reify{ class C { def x = 2 } }.tree)
showRaw(typeOf[{ def x: Int; val y: List[Int] }])
showRaw(typeOf[{ def x: Int; val y: List[Int] }], printIds = true, printKinds = true)
show(cm.classLoader)
import scala.reflect.runtime.universe._
val tree = reify{ class C { def x = 2 } }
val tree = reify{ class C { def x = 2 } }.tree
import scala.reflect.runtime.universe._
show(reify{ class C { def x = 2 } }.tree)
import scala.reflect.runtime.universe._
show(reify{ class C { def x = 2 } }.tree)
showRaw(reify{ class C { def x = 2 } }.tree)
show(typeOf[{ def x: Int; val y: List[Int] }])
showRaw(typeOf[{ def x: Int; val y: List[Int] }])
showRaw(typeOf[{ def x: Int; val y: List[Int] }], printIds = true, printKinds = true)
import scala.tools.reflect.ToolBox._ // requires scala-compiler.jar
import scala.tools.reflect.ToolBox // requires scala-compiler.jar
import scala.reflect.runtime.{currentMirror => cm}
cm.mkToolBox().typeCheck(reify{ class C { def x = 2 } })
cm.mkToolBox().typeCheck(reify{ class C { def x = 2 } }.tree)
showRaw(cm.mkToolBox().typeCheck(reify{ class C { def x = 2 } }.tree), printTypes = true)
show(reify{ final class C { def x = 2 } }.tree)
def tree = reify{ final class C { def x = 2 } }.tree
showRaw(tree)
showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)
def tree = reify{ final class C { def x = 2 } }.tree
showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)
def tree = reify{ final class C { def x = 2 } }.tree
showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)
def tree = reify{ final class C { def x = 2 } }.tree
showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)
def m(x: Int*) = ???
class C { def m(x: Int*) = ??? }
val m = typeOf[C].member(newTermName("m")).asMethod
m.params
m.params(0)(0).typeSignature
showRaw(m.params(0)(0).typeSignature)
import scala.reflect.runtime.universe._
class C { def m(x: => Int) = ??? }
val m = typeOf[C].member(newTermName("m")).asMethod
m.params(0)(0).typeSignature
showRaw(m.params(0)(0).typeSignature)
import scala.reflect.runtime.universe._
reify(x + 2)
val x = 2
reify(x + 2)
reify(x + 2).tree
res2.getClass
res2.getClass.toString
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}
import scala.reflect.runtime.ToolBox
import scala.tools.reflect.ToolBox
val tb = cm.mkToolBox()
tb.parse("x + 2")
val mirror = runtimeMirror(getClass.getClassLoader)
tb.eval(tb.parse("2 + 2"))
showRaw(reify{ trait X { def x: Int } })
showRaw(reify{ trait X { def x: Int } }.tree)
showRaw(reify{ trait X { def x = 2 } }.tree)
showRaw(reify{ 2 match { case x @ List(_) => } }.tree)
showRaw(reify(2 match { case x @ List(_) => }).tree)
showRaw(reify(2).tree)
showRaw(2 match { case x => x })
showRaw(2 match { case x => x }.tree)
showRaw(reify(2 match { case x => x }))
showRaw(reify(2 match { case x => x }).tree)
showRaw(reify(2 match { case x @ List(_) => x }).tree)
showRaw(reify(2 match { case _ => x }).tree)
showRaw(reify(2 match { case _ => }).tree)
showRaw(reify(2 match { case List(_) => }).tree)
showRaw(reify(2 match { case List(x) => }).tree)
showRaw(reify(2 match { case List(_) => }).tree)
showRaw(reify(List(2) match { case List(_) => }).tree)
showRaw(reify(List(2) match { case List(x) => }).tree)
exit
trait Foo { self: scala.reflect.api.Universe =>
def foo(x: Any) = x match { case expr: Expr[_] => }
}
showRaw(reify(this))
showRaw{ def foo[T <: Int] = ??? }
showRaw(reify{ def foo[T <: Int] = ??? })
showRaw(reify{ def foo[T] = ??? })
object i 
reify{val x = i; x} 
res0.eval
val x: i.type = i; x 
reify{val x: i.type = i; x} 
res3.eval
import scala.reflect.runtime.universe._
val cm = runtimeMirror(getClass.getClassLoader)
val list = cm.staticClass("scala.List")
val list = typeOf[List].typeSymbol
val list = typeOf[List[_]].typeSymbol
list.typeSignature.member("map": TermName)
val map = list.typeSignature.member("map": TermName).asMethod
map.params
map.params(0)(0)
val f = map.params(0)(0)
val filter = map.params(0)(0)
filter.name
filter.typeSignature
map.typeParams
val list = typeOf[List[_]].typeSymbol
list.member("mkString": TermName)
list.typeSignature.member("mkString": TermName)
val mkString = list.typeSignature.member("mkString": TermName)
val mkString = list.typeSignature.member("mkString": TermName).asTerm
mkString.isMethod
mkString.alternatives
mkString.alternatives foreach println
mkString.alternatives foreach (alt => println(alt.typeSignature))
def foo(x: Int*) = ???
def foo(xs: Int*) = ???
def foo(xs: Int*) = xs.sum
def add(xs: Int*) = xs.sum
def impl(c: Context)(xs: c.Expr[Int]*): c.Expr[Int] = {
import c.universe._
val map = list.typeSignature.member("map": TermName).asMethod
val filter = map.params(0)(0)
filter.typeSignatureIn(typeOf[List[Int]])
map.typeSignatureIn(typeOf[List[Int]])
filter.typeSignatureIn(res1)
map.typeSignature
map.typeSignatureIn(typeOf[List[Int]])
typeOf[List[Int]]
showRaw(res0)
res0.typeSignature
res0.members
typeOf[scala.List[_]] =:= typeOf[scala.collection.immutable.List[_]]
typeOf[scala.List[_]] == typeOf[scala.collection.immutable.List[_]]
import scala.reflect.runtime.universe._
typeOf[List[_]].members take 5 foreach println
typeOf[List[_]].members.sorted take 5 foreach println
def test[T: TypeTag](x: T) = s"I've been called for x with the type ${typeOf[T]}"
test(2)
test(List(2, "x"))
import scala.reflect.runtime.universe._
val cm = runtimeMirror(getClass.getClassLoader)
cm.classSymbol(List(1, 2).getClass)
typeOf[List[Int]]
cm.classSymbol(List(1, 2).getClass).typeSignature
cm.classSymbol(List(1, 2).getClass).toType
typeOf[List[Int]]
def invokeHead(x: Any): Any = ???
def invokeHead[T: TypeTag](x: T): Any = ???
def invokeHead(x: Any): Any = {
// type of x is unknown, the best we can do is
// cm.classSymbol(x.getClass).toType
???
}
def invokeHead[T: TypeTag](x: T): Any = {
// type of x is preserved by the compiler
println(typeOf[T])
}
invokeHead(List(1, 2))
invokeHead(List("x"))
def invokeHead(x: Any): Any = {
// type of x is unknown, the best we can do is
println(cm.classSymbol(x.getClass).toType)
}
invokeHead(List(1, 2))
invokeHead(List("x"))
typeOf[List[Int]].member("head": TermName).asMethod
val head = typeOf[List[Int]].member("head": TermName).asMethod
val im = cm.reflect(List(1, 2))
val mm = im.reflectMethod(head)
mm()
def foo(x: Int = 2) = ???
class C { def foo(x: Int = 2) = ??? }
typeOf[C].declarations
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro filter_impl[T]
}
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro filter_impl[T]
} object Coll
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro Macros.filter[T]
}
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro Macros.filter[T]
} object Macros {
class Coll[T] {
def filter(p: T => Boolean): Coll[T] = macro Macros.filter[T]
}; object Macros {
def filter[T](c: Context { type PrefixType = Coll[T] })(p: c.Expr[T => Boolean]): c.Expr[Coll[T]] = { println(c.prefix); c.prefix }
}
new Coll[Int]().filter(_ % 2 == 0)
val x = new Coll[String]()
x.filter(_ != "")
def impl(c: Context)(x: c.Expr[Int]) = {
println(s"compile-time value is: ${c.eval(x)}")
x
}
def test(x: Int) = macro impl
test(2)
def impl(c: Context)(x: c.Expr[Int]) = {
val x1 = c.Expr[Int](c.resetAllAttrs(x.tree.duplicate))
println(s"compile-time value is: ${c.eval(x1)}")
x
}
def test(x: Int) = macros impl
def test(x: Int) = macro impl
test(2)
test(2 + 2)
def impl(c: Context)(x: c.Expr[String]) = {
val x1 = c.Expr[String](c.resetAllAttrs(x.tree.duplicate))
println(s"compile-time value is: ${c.eval(x1)}")
x
}
def test(x: String) = macro impl
test("x")
test("x" + "y")
val x = "x"
test(x + "y")
{ val x = "x"; test(x + "y") }
trait Foo { implicit def manifest = implicitly[Manifest[Element]] }
trait Foo { implicit def manifest = implicitly[Manifest[Int]] }
trait Foo { implicit def manifest = implicitly[Manifest[Foo]] }
class C
trait Foo { implicit def manifest = implicitly[Manifest[C]] }
new Foo{}
new Foo{}.manifest
typeOf[String].typeSymbol.asType.isAliasType
showRaw(typeOf[String])
typeOf[String].typeSymbol.typeSignature
typeOf[String].typeSymbol.asType.isAliasType
typeOf[String].typeSymbol
typeOf[String].flags
typeOf[List].flags
typeOf[List[_]].flags
showRaw(typeOf[List[_]])
typeOf[String].typeSymbol.asType.isAliasType
val TypeRef(_, sym, _) = typeOf[String]
sym.typeSymbol.asType.isAliasType
sym.asType.isAliasType
showRaw(typeOf[String])
typeOf[String].typeSymbol
def foo(c: Context): c.Tree = ???
def bar(c: Context): c.Tree = foo(c)
def bar(c: Context): c.Tree = c.literalUnit.tree
class Helper(c: Context) {
def generate: c.Tree = ???
}
class Helper(val c: Context) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper(c)
c.Expr(helper.generate)
}
class Helper(val c: Context) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper
}
abstract class Helper {
val c: Context
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val c1: c.type
}
def impl(c1: Context): c1.Expr[Unit] = {
val helper = new { val c: c1.type = c1 } with Helper
c.Expr(helper.generate)
}
def impl(c1: Context): c1.Expr[Unit] = {
val helper = new { val c: c1.type = c1 } with Helper
c1.Expr(helper.generate)
}
class Helper[C <: Singleton]
class Helper[C <: Singleton](val c: Context) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper(c)
c.Expr(helper.generate)
}
class Helper[C <: Singleton](val c: C) {
def generate: c.Tree = ???
}
class Helper[C <: Context with Singleton](val c: C) {
def generate: c.Tree = ???
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper(c)
c.Expr(helper.generate)
}
def impl(c: Context): c.Expr[Unit] = {
val helper = new Helper[c.type](c)
c.Expr(helper.generate)
}
class C(val x: Any) { def cast[T]: T = x.asInstanceOf[T] }
new C("xxx").cast[Int]
class C(val x: Any) { def cast[T]: Any = x.asInstanceOf[T] }
new C("xxx").cast[Int]
class C(val x: Any) { def cast[T <: Int]: Any = x.asInstanceOf[T] }
new C("xxx").cast[Int]
def foo[T: TypeTag] = println(typeOf[T])
foo[Int]
foo[String]
foo[List[Int]]
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typetag = c.inferImplicitValue(weakTypeOf[T])
if (typeTag == EmptyTree) c.abort(
}
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags= c.mirror.staticClass("scala.reflect.api.TypeTags)
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags= c.mirror.staticClass("scala.reflect.api.TypeTags"
)
}
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags= c.mirror.staticClass("scala.reflect.api.TypeTags")
val typeTag = typeTags.typeSignature.member(newTypeName("TypeTag")).asClass.toType
val typeTagOfT = appliedType(typeTag, List(weakTypeOf[T])
val inferred = c.inferImplicitValue(typeTagOfT)
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags = c.mirror.staticClass("scala.reflect.api.TypeTags")
val typeTag = typeTags.typeSignature.member(newTypeName("TypeTag")).asClass.toType
val typeTagOfT = appliedType(typeTag, List(weakTypeOf[T]))
val inferred = c.inferImplicitValue(typeTagOfT)
if (inferred == EmptyTree) c.abort("can't provide a weak type here")
c.literalUnit
}
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags = c.mirror.staticClass("scala.reflect.api.TypeTags")
val typeTag = typeTags.typeSignature.member(newTypeName("TypeTag")).asClass.toType
val typeTagOfT = appliedType(typeTag, List(weakTypeOf[T]))
val inferred = c.inferImplicitValue(typeTagOfT)
if (inferred == EmptyTree) c.abort("can't provide a weak type here")
}
def impl[T: c.WeakTypeTag](c: Context) = {
import c.universe._
val typeTags = c.mirror.staticClass("scala.reflect.api.TypeTags")
val typeTag = typeTags.typeSignature.member(newTypeName("TypeTag")).asClass.toType
val typeTagOfT = appliedType(typeTag, List(weakTypeOf[T]))
val inferred = c.inferImplicitValue(typeTagOfT)
if (inferred == EmptyTree) c.abort(c.enclosingPosition, "can't provide a weak type here")
c.literalUnit
}
def foo[T] = macro impl[T]
foo[List[Int]]
def bar[T] = foo[T]
new Exception().getStackTraceString
new Exception().printStackTrace
scala.tools.nsc.util.stackTraceString(new Exception)
def impl[T: c.WeakTypeTag](c: Context) = c.universe.reify { val x: T = null.asInstanceOf[T] }
def foo[T] = macro impl[T]
foo[Int]
def foo[T] = println("1")
def foo[T](x: T) = println("2")
foo[Int]
foo[Int]()
def foo[T] = println("1"); def foo[T](x: T) = println("2")
foo[Int]
foo(1)
class C { def foo[T <: Int]: T = ??? }
typeOf[C].member(newTermName("foo"))
vak foo = typeOf[C].member(newTermName("foo")).asMethod
val foo = typeOf[C].member(newTermName("foo")).asMethod
foo.typeParams(0)
foo.typeParams(0).typeSignature
foo.typeParams(0).typeSignature.erasure
def foo[T] = weakTypeOf[Map[Int, T]]
foo[Int]
def foo[T] = weakTypeOf[Map[Int, T]].erasure
foo[Int]
def foo[T] = weakTypeOf[Map[String, T]].erasure
foo[Int]
(params: Seq[Any]) => params(0).asInstanceOf[math.Numeric[_]].mkNumericOps (params(1).asInstanceOf[Object]))
(params: Seq[Any]) => params(0).asInstanceOf[math.Numeric[_]].mkNumericOps (params(1).asInstanceOf[Object])
type T1 = T forSome { type T }
type T = T1 forSome { type T1 }
(params: Seq[Any]) => params(0).asInstanceOf[math.Numeric[T]].mkNumericOps (params(1).asInstanceOf[T])
type T = T forSome { type T }
(params: Seq[Any]) => params(0).asInstanceOf[math.Numeric[T]].mkNumericOps (params(1).asInstanceOf[T])
case class C(val x: Int, val y: Int)
typeOf[C].declarations.collect{case x: MethodSymbol if x.isCaseAccessor}
typeOf[C].declarations.collect{case x: MethodSymbol if x.isCaseAccessor => x}
case class C(val x: Int, val y: Int)
typeOf[C].declarations.collect{case x: MethodSymbol if x.isCaseAccessor => x}
class C { def x = 2 }
val m = ru.runtimeMirror(getClass.getClassLoader)
val im = m.reflect(new C)
val mm = m.reflectMethod(typeOf[C].declaration(newTermName("x")).asMethod)
val mm = im.reflectMethod(typeOf[C].declaration(newTermName("x")).asMethod)
mm()
val methodX = typeOf[C].declaration(newTermName("x")).asMethod
val mm = im.reflectMethod(methodX)
class C { var x = 2 }
class C { val x = 2; var y = 3 }
val fieldX = typeOf[C].declaration(newTermName("x")).asTerm.accessed
val fieldY = typeOf[C].declaration(newTermName("y")).asTerm.accessed
val im = m.reflect(new C)
val fmX = im.reflectField(fieldX)
val fieldX = typeOf[C].declaration(newTermName("x")).asTerm.accessed.asTerm
val fieldY = typeOf[C].declaration(newTermName("y")).asTerm.accessed.asTerm
val fmX = im.reflectField(fieldX)
val fmY = im.reflectField(fieldY)
fmX.get
fmX.set(3)
fmY.get(3)
fmY.get
fmY.set(4)
fmY.get
case class C(val x: Int)
val classC = typeOf[C].typeSymbol
val cm = im.reflectClass(classC)
val classC = typeOf[C].typeSymbol.asClass
val cm = im.reflectClass(classC)
val cm = m.reflectClass(classC)
val ctorC = typeOf[C].declaration(ru.nme.CONSTRUCTOR).asMethod
val ctorm = cm.reflectConstructor(ctorC)
ctorm(2)
object C { def x = 2 }
val objectC = typeOf[C.type].termSymbol.asModule
val modm = m.reflectModule(objectC)
modm.instance
val mod = modm.instance
val mm = m.reflectModule(objectC)
val obj = mm.instance
