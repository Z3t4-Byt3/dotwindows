exit
def foo: Int = x
var x = 2
}
import scala.reflect._
import scala.reflect.api._ 
import scala.reflect.mirror._ 
import scala.reflect.api.Modifier._ 
import scala.reflect.internal.Flags._
val a = 5
val b = a * a
val x: Code[Int] = a + b
val x: Code[ => Int] = a + b
val x: Code[() => Int] = a + b
val d = new Date()
val d = new java.util.Date()
val sdf = new java.text.SimpleDateFormat("d MMMM yyyy, HH:mm:ss")
sdf.formt(d)
sdf.format(d)
java.util.Locale.ru_RU
java.util.Locale("ru
java.util.Locale("ru", "RU")
new java.util.Locale("ru", "RU")
Charset.forName("UTF-8")
java.nio.Charset.forName("UTF-8")
java.nio.charset.Charset.forName("UTF-8")
res7.encode(res1)
java.nio.charset.Charset.default
java.nio.charset.Charset.defaultCharset()
val s = res1
val utf8 = res7
val cp1251 = res10
s.getBytes("UTF-8")
new String(s.getBytes(utf8), utf8)
new String(s.getBytes(cp1251), utf8)
new String(s.getBytes(cp1251), cp1251)
new String(s.getBytes(utf8), cp1251)
val sdf = new java.text.SimpleDateFormat("MMMM")
sdf.format(new java.util.Date())
new String(s.getBytes(utf8), "ISO-8859-1")
new String(s.getBytes(cp1251), "ISO-8859-1")
new String(s.getBytes(utf8), cp1251)
new String(s.getBytes(cp1251), utf8)
new String(s.getBytes(cp1251), cp1251)
val sdf = new java.text.SimpleDateFormat("MMMM")
sdf.format(new java.util.Date())
val utf8 = java.nio.charset.Charset.forName("UTF-8")
val cp1251 =  java.nio.charset.Charset.defaultCharset()
val s = sdf.format(new java.util.Date())
new String(s.getBytes(cp1251), utf8)
new String(s.getBytes(utf8), cp1251)
res2
s.getBytes(utf8)
val utf16 = java.nio.charset.Charset.forName("UTF-16")
new String(s.getBytes(utf16), cp1251)
(2: Any) * 2
class oh1
class oh2
implicit val ohh1 = new oh1
implicit val ohh2 = new oh2
class C {
def foo[T](implicit ohp1: oh1) { println("hello") }
def foo(implicit ohp2: oh2) { println("HAHAHA") }
}
new C().foo
new C().foo[Int]
new C().foo()
class C {
def foo[T]()(implicit ohp1: oh1) { println("hello") }
def foo()(implicit ohp2: oh2) { println("olleh") }
}
new C().foo()
new C().foo[Int]()
object C {
type C = Int
object C
}
C.C
new C.C
val x: Nothing = 1
def x: Nothing = throw new Error("foo")
x
val s: Dynamic = "Hello, world!"
val s: Dynamic = Dynamic("Hello, world!")
List(1, 2, 3)
val s: Dynamic = new Dynamic("Hello, world!")
val s: Dynamic = null
s.foo
{
class C
class C[T]
}
def foo* = 2
class Code {
implicit def code2int() = 2
}
val x: Int = new Code
{
class Code
object Code {
implicit def code2int(code: Code) = 2
}
{}
}
val x: Int = new Code
object Code
class Code; object Code { implicit def code2int(code: Code) = 2 }
val x: Int = new Code
'hey.getClass
def x[T: Manifest]() = println(implicitly[Manifest[T]].toString)
x(1)
x[Int]()
x[String]()
x[scala.reflect.Code[Int]]()
def f[T](x: T) = null
f[Int => Int]{x => x + 2}
def f[Int => T](x: Int => T) = x(2)
def f[T](x: Int => T) = x(2)
def f[T](x: T) = x.asInstanceOf[Int => Int](2)
f{x => x + 2}
f[Int => Int]{x => x + 2}
{x => x}(2)
({x => x})(2)
({x: Int => x})(2)
(x: Int => x)(2)
val s = "foo(bar"
s.substring(s.indexOf("("))
exit
Some(1).getOrElse(2)
None.getOrElse(2)
Some(2).flatMap(_ * 2)
Some(2).flatMap{_ * 2}
Some(2).map{_ * 2}
Some(2).map(_ * 2)
2 + 2
import scala.reflect._
import scala.reflect.api._ 
import scala.reflect.mirror._ 
import scala.reflect.api.Modifier._ 
import scala.reflect.internal.Flags._
Code.lift{2}
exit
import scala.reflect.Code
class C
class D extends C
val code: Code[C] = Code.lift{new C}
val code: Code[C] = Code.lift{new D}
import scala.reflect._
import scala.reflect.Code._
new Quasiquote
new Quasiquote(List("qwe", ""), List({foo * bar}), List("bar"))
val foo = 2
val bar = 4
new Quasiquote(List("qwe", ""), List({foo * bar}), List("bar"))
foo * bar
foo
val foo = 2
foo
new Quasiquote(List("qwe", ""), List({2 * 3}), List("bar"))
res0
res7
res8
import scala.reflect._
import scala.reflect.Code._
class Quasiquote(parts: List[String], splices: List[Code[_]], formats: List[String])
new Quasiquote(List("qwe", ""), List({2 * 3}), List("bar"))
new Quasiquote(List("qwe", ""), List(lift{2 * 3}), List("bar"))
x
"\u0033"
val foo = 2
Some(2) match {
case Some(`foo`) => println("hey")
case _ => println("boo!")
}
val foo = 1
Some(2) match {
case Some(`foo` + `foo`) => println("hey")
}
foo + foo
x
import scala.util.parsing.input._
val x = 2
exit
import scala.util.parsing.input._
val cr = new CharArrayReader("foo\\nbar")
val cr = new CharArrayReader("foo\\nbar".toArray)
cr.next
cr.ch
cr.first
cr.first.rest
cr.rest
cr.first
res4.first
res4.rest
res7.rest
res8.first
res8.next
res8.rest
res11.first
import scala.util.parsing.combinator._
class Unesc extends JavaTokenParsers
Unesc.stringLiteral.parse("foo")
object Unesc extends JavaTokenParsers
Unesc.stringLiteral.parse("foo")
Unesc.stringLiteral.parseAll(Unesc.stringLiteral, "foo")
Unesc.parseAll(Unesc.stringLiteral, "foo")
Unesc.parseAll("\"foo\"")
Unesc.parseAll(Unesc.stringLiteral, "\"foo\"")
Unesc.parseAll(Unesc.stringLiteral, "\"fo\\no\"")
Unesc.parseAll(Unesc.stringLiteral, "\"fo\\no\"").get
Unesc.parseAll(Unesc.stringLiteral, "\"fo\\no").get
Unesc.parseAll(Unesc.stringLiteral, "\"fo\\no")
Unesc.parseAll(Unesc.stringLiteral, "\"fo\\no").isEmpty
import scala.reflect.Code._
import scala.tools.nsc.reporters._
import scala.tools.nsc.Settings
import reflect.runtime.Mirror.ToolBox
def x = 2
lift{x}
val code = res0
  val settings = new Settings
  settings.debug.value = true

  val reporter = new ConsoleReporter(settings)
  val toolbox = new ToolBox(reporter)
  val ttree = toolbox.typeCheck(code.tree)
  toolbox.runExpr(ttree)
val x = c"2"
val y = c"2"
println(c"$x + $y")
x
import scala.reflect.mirror._
val x = c"2"
showRaw(x.tree)
2.$plus(2)
false.$bar$bar(true)
1.$equal$equal(1)
1.$eq$eq(1)
true.&amp&amp(false)
true.$amp$amp(false)
val x = c"2"
val c"$two + 2" = c"$x + $x"
two
c"$x + $x" match {
case c"$two + 2" => println("yay!")
}
val c"$two + 2" = c"$x + $x".tree
two
val world = "world"
println("hello, $world!")
println(s"hello, $world!")
val x = 2
val x = c"2"
val y = c"2"
val four = c"$x + $y".tree
four match {
case c"$two + 2" => println($two)
case _ => println("fail")
}
four match {
case c"$two + 2" => println(two)
case _ => println("fail")
}
two
import scala.tools.nsc.reporters._
import scala.tools.nsc.Settings
import reflect.runtime.Mirror.ToolBox
  val reporter = new ConsoleReporter(new Settings)
  val toolbox = new ToolBox(reporter)
toolbox.typeCheck(four)
val toolbox = new ToolBox(reporter)
val reporter = new ConsoleReporter(new Settings)
val toolbox = new ToolBox(reporter)
toolbox.typeCheck(four)
res6.tpe
toolbox.runExpr(four)
exit
val list = List
val list(1) = List(1)
val list(qqqq) = List(1)
val qwe(100) = List
def qwe(x: Int) = List
val list(qqqq) = List(1)
val qwe(100)(qqqq) = List(1)
val moo = qwe(100)
val moo(qqqq) = List(1)
object Foo {
def Some = scala.Predef.Som
}
object Foo {
def Some = scala.Predef.Some
}
Some
object Foo {
def Some = scala.Some
}
Foo.Some
Some2 match { case Foo.Some(2) => println("hey") }
Some(2) match { case Foo.Some(2) => println("hey") }
val Foo.Some(x) = Some(2)
val List(foo, bar) = List(1, 2)
definitions.ListModule
definitions.ListModule.asSeenFrom(NoType, NoSymbol)
val list = List(2, 3)
list.zip(list) { case (foo, bar) => println(foo + bar) }
list.zip(list) foreach { case (foo, bar) => println(foo + bar) }
exit
import scala.reflect.Code._
lift{2 + 2}
res0.tree
val a = 2
val b = 2
lift{a + b}
showRaw(res2.tree)
import scala.reflect.mirror._
showRaw(res2.tree)
val world = "world"
println("hello ${world}!")
val s = "foo = bar"
val pattern = """(?<login>\w+) (?<id>\d+)""".r
import scala.util.matching._
val s = """^(?<key>.*?)\s*=\s*(?<value>.*)$"""
val r = """\(\?\<(\w+)\>.*?\)""".r
r.findFirstIn(s)
val r = """\(\?\<(\w+)\>(.*?)\)""".r
r.findFirstIn(s)
r.findAllIn(s)
res2.head
res2.first
res2.toList.head
res5.getClass
r.findFirstMatchIn(s)
r.findFirstMatchIn(s).get
res8.groupNames
res8.groups(0)
res8.group(0)
res8.group(1)
res8.group(2)
r.findAllIn(s)
r.findAllIn(s).matchData.toList
"""\(\?\<(\w+)\>(.*?)\)""".r.findAllIn(s).matchData.toList
"""\((\?\<(\w+)\>)?(.*?)\)""".r.findAllIn(s).matchData.toList
"""\((\?\<(\w+)\>)?(.*?)\)""".r.findAllIn(s).matchData.toList.head
val s = """^(?<key>.*?)\s*(=)\s*(?<value>.*)$"""
"""\((\?\<(\w+)\>)?(.*?)\)""".r.findAllIn(s).matchData.toList.head
"""\((\?\<(\w+)\>)?(.*?)\)""".r.findAllIn(s).matchData.toList
"""\((\?\<(\w+)\>)?(.*?)\)""".r.findAllIn(s).matchData.toList.head
res21.group(1)
res21.group(2)
res21.group(3)
res21.group(4)
"""\((\?\<(\w+)\>)?(.*?)\)""".r.findAllIn(s).matchData.toList.tail.head
res26.group(1)
res26.group(2)
res26.group(3)
Map("foo" -> 1)
res0.key
res0.keys
import scala.reflect.Code._
import scala.reflect.mirror._
lift{2}
val x = 2
lift { 2 + x}
showRaw(res1.tree)
def ident[A](x: A) = x 
val ident1 = ident _
val ident1 = ident
def f[A](x: A => A) = x x
def f[A](x: A => A) = x(x)
def f[A](x: A => A) = x.asInstanceOf[A => A](x.asInstanceOf[A])
def id(x: Int) = x
f(id)
def f[A](x: A => A) = x(x.asInstanceOf[A])
def id(x: Int) = x
def f[A](x: A => A) = x(x.asInstanceOf[A])
def test[A](x: A => A) = x
f(test)
f(test[Int])
f(test[Int])(2)
f(test[Int])(test[Int])
f(test[Int])(test[Int] _)
f(test[Int] _)(test[Int] _)
f(test[Int] _)
f(test[Int] _)(2)
def f[A](x: A => A) = x(x.asInstanceOf[A])
def test(x: Int => Int) = x
test(2)
def id(x: Int) = x
f(test)(id)(2)
f(test)(id _)(2)
def f[A](x: A => A) = x(x.asInstanceOf[A]).asInstanceOf[A => A]
f(test)(id _)(2)
def foo[A](a: A) = a
def bar = foo
def bar = foo _
val bar = foo _
exit
mirror.classToType(classOf[String])
import reflect.mirror
mirror.classToType(classOf[String])
mirror.classToType(res1.getClass)
class A
classToType(classOf[A])
import scala.reflect.mirror._
classToType(classOf[A])
import scala.reflect.mirror._
class A
classToType(classOf[A])
tpe.allMembers
exit
def macro foo() = Block(List(), Literal(Constant(())))
foo
object X extends () => Int
object X extends Function0[Int] {
def apply(): Int = 2 
}
object X extends Function1[Int, Int] {
def apply(x: Int): Int = x * 2 
}
List(1, 2, 3) map X
class Foo
""
class SubScriptInterpolation(script: StringContext) {
  def subscript() = ???
     }
""
class SubScriptInterpolation(script: ScriptContext) {
  def subscript(splices: Any*) = ???
     }
      SubScriptInterpolation(script: StringContext) {
  def subscript(splices: Any*) = ???
        
     }
class SubScriptInterpolation(script: StringContext) {
  def subscript(splices: Any*) = ???
     }
     ript"hello"
subscript"hello"
implicit def sc2ss(script: StringContext) = new SubScriptInterpolation(script)
subscript"hello"
exit
c"2"
exiy
exit
c"2"
exit
import scala.reflect.mirror._
showRaw(scala.reflect.Code.lift{2})
exit
val four = c"$two + $two"
exit
val four = c"$two + $two"
val two = c"2"
val four = c"$two + $two"
four match { case c"2 + $x" => println(showRaw(x)) }
import scala.reflect.mirror._
four match { case c"2 + $x" => println(showRaw(x)) }
four.tree match { case c"2 + $x" => println(showRaw(x)) }
exit
def macro foo = ???
def f = ???
def f = 2
def macro f = ??? // raw
val x = 2 // show
def macro x = ???
def macro x = ??/
def macro x = ???
def macro f = ???
def macro f = ??
def macro f = ???
f
def macro boo = new java.util.Date.toString
def macro boo = (new java.util.Date).toString
macro def two = Literal(Constant(2))
def macro two = Literal(Constant(2))
two
implicitly[Int]
2 with { def foo = "bar" }
"s" with { def foo = "bar" }
class C[T](T: Int)
""."
""a"
java.util.UUID.randomUUID().toString
def foo: Int = _
classOf[List]
classOf[List[_]]
class C {
type T = Int
}
class C {
type T = Int
}; object C {
type T = String
}
def x = { (y:Int => Int) => y}
def y = {a:Int => a}
x {a:Int => a}
x y
def foo[A](A: Int)
= A.asInstanceOf[A]
val foo = ?
val ? = 1
printAfterEachPhase(ListClass.info.members.size)
:power
printAfterEachPhase(ListClass.info.members.size)
changesAfterEachPhase(ListClass.info.nonPrivateMembers map (_.defString)) foreach println
def foo(x: Int) = 2; def foo(x: String) = 3; val boo = foo _
def foo[A <% Int](x: A) = 100
def foo[A <% Int] = ???
def foo: => String = "s"
val x = new {
val y = 2
val z = y + y
}
x.y
class VanillaLogger {
def debug(msg: String) = println(msg)
}
class MacroLogger {
var isDebugEnabled = true
def macro debug(msg: String) = {
  
}
|
}
class MacroLogger {
val logger = new VanillaLogger
var isDebugEnabled = true
def macro debug(msg: String) = {
  If(Select(_this, newTermName("isDebugEnabled")), Apply(Select(Select(_this, newTermName("logger")), newTermName("debug")), List(msg)), Block())
}
class VanillaLogger {
  def vanillaDebug(msg: String) = println(msg)
}
class MacroLogger {
val vanillaLogger = new VanillaLogger
var isDebugEnabled = true
def macro debug(msg: String) = 
  If(Select(_this, newTermName("isDebugEnabled")), Apply(Select(Select(_this, newTermName("vanillaLogger")), newTermName("vanillaDebug")), List(msg)), Literal(Constant(())))
}
val macroLogger = new MacroLogger
macroLogger.debug("foo")
macroLogger.isDebugEnabled = false
macroLogger.debug("bar")
s"""some ${3+4}"""
s"""foo
def macro foo(x: Int) = x
def macro foo(x: Int) = { println(x); x }
foo(1 + 3)
def Foo[+T]
class Foo[+T]
val foo: Foo[Object] = new Foo[List[Int]]
val foo: Foo[List[Int]] = new Foo[Object]
List[Predef.type]()
List[Predef.type](Predef)
println(2, 3, 4)
println("¢ëè¥« § ©ç¨ª ¯®£ã«ïâì")
import scala.reflect.macro.api.{Context => Ctx}
def impl(c: Ctx) = { import c._, c.mirror._; Bind(newTermName("x"), Ident(newTermName("_"))) }
def foo = macro impl
val x: String = 2
"2".toInt
2.toInt()
2.toInt
def foo() = 42
foo
def foo(x: Int, y: Int) = x - y
foo(2, -40)
foo(y=-40, x=2)
foo(y:-40, x:2)
foo(x=2,y=-40)
def foo(x: Int, y: Int) = x + y
def foo(x: Int, y: Int) = x - y
foo(2, -40)
foo(x=2,y=-40)
def foo(x: Int, y: Int) = x - y
foo(2, -40)
foo(x = -2, y = 40)
foo(y = -2, x = 40)
{
1;
2
}
type TT = scala.reflect.api.TypeTags#TypeTage
type TT = scala.reflect.api.TypeTags#TypeTag
type TT = scala.reflect.api.TypeTags#TypeTag[_]
implscala.reflect.api.TypeTags#TypeTag[Int]]
implicitly[scala.reflect.api.TypeTags#TypeTag[Int]]]
implicitly[scala.reflect.api.TypeTags#TypeTag[Int]]
type TT = scala.reflect.api.TypeTags
implicitly[TT#TypeTag[Int]]
type TTs = scala.reflect.api.TypeTags
implicitly[TTs#TypeTag]
}
{
type TTs = scala.reflect.api.TypeTags
implicitly[TTs#TypeTag[Int]]
}
{
type TT = scala.reflect.api.TypeTags#TypeTag
implicitly[TT[Int]]
}
{
type TT[T] = scala.reflect.api.TypeTags#TypeTag[T]
implicitly[TT[Int]]
}
val x = y val y = 5
val x = y; val y = 5
exit
import scala.reflect.makro.{Context => Ctx}
def foo(c: Ctx) = { import c.mirror._; Literal(Constant("hai!")) }
def foomac = macro foo
def foo(c: Ctx) = c.reify { println("hello world!") }
def foomac = macro foo
foo
foomac
exit
def foo_impl(c: scala.reflect.makro.Context) = c.reify { println("hello world") }
def foo = macro foo_impl
foo
exit
trait Foo
val x = new Object with Foo
val x = 2 with Foo
val x = x with Foo
val y = new Object
val x = y with Foo
object M {
def m(a: String)() = macro mImpl[Int];
def mImpl[A: c.TypeTag](c: reflect.makro.Context)(a: c.Expr[String])() = a
}
M.m("foo")()
object M {
def m(a: String)() = macro mImpl[Int];
def mImpl[A: c.TypeTag](c: reflect.makro.Context)(a: c.Expr[String])() = a
}
M.m("foo")()
""a"
val x = true
reify(!x)
scala.reflect.mirror.reify(!x)
type X = scala.reflect.mirror.Expr[_}
type X = scala.reflect.mirror.Expr[_]
System.getProperties
System.getProperties foreach println
System.getProperties.list(System.out)
System.out.println(System.getProperty("sun.boot.class.path"))
reify { List(2) }
import scala.reflect.mirror._
reify { List(2) }
package Foo {
package Foo { object Bar }
implicitly[scala.reflect.mirror.TypeTag[String]]
exit
def impl(c: scala.reflect.makro.Context) = ???
def foo = macro impl
foo
exit
import scala.reflect.mirror._
reify(reify(2))
res0.eval
res0.eval.eval
reify(reify(reify(2)))
reify(reify(x))
import scala.reflect.mirror._
reify(reify(x))
reify(reify(2))
res2.eval.eval
res2.eval
res2.value
res2.eval
import scala.reflect.makro._
def foo(c: Context) = {
println(c.mirror.staticClass("scala.Int").tpe)
???
}
def foo(c: Context) = {
println(c.mirror.staticClass("scala.Int").asType)
???
}
def impl = macro foo
impl
def foo(x: String, y: String)(z: Int) = ???
foo(y = "a", x = "b")(42)
import scala.reflect.mirror._
val x = 2
reify(x)
reify(reify(x))
reify(reify(reify(x)))
reify(reify(reify(reify(x))))
reify(reify(reify(x)))
res4.eval.eval.eval
reify(reify(x))
import scala.reflect.mirror._
reify(reify(x))
val x = 2
reify(reify(x))
def foo[T <% Int](x: T) = x
import scala.reflect.makro.Context
def impl(c: Context) = {
println(c.fresh(newTermName("qwe"))
println(c.fresh(newTypeName("qwe"))
???
}
def impl(c: Context) = {
println(c.fresh(newTermName("qwe")))
println(c.fresh(newTypeName("qwe")))
???
}
def impl(c: Context) = {
import c.mirror._
println(c.fresh(newTermName("qwe")))
println(c.fresh(newTypeName("qwe")))
???
}
def foo = macro impl
foo
def impl(c: Context) = {
import c.mirror._
println(c.fresh(newTermName("qwe")))
println(c.fresh(newTypeName("qwe")))
c.abort(NoPosition, "blargh")
}
def foo = macro impl
var (foo, bar) = (1, 2)
foo = 3
val arr = Array("wazzup", "dawg")
arr map (x => (x, x))
val xs: Array[_] = Array(1, 2)
xs map (x => (x, x))
implicitly[TypeTag[Int]]
exit
implicitly[TypeTag[Int]]
implicitly[ClassTag[Int]]
implicitly[TypeTag[Nothing]]
implicitly[TypeTag[Int]]
import scala.reflect.mirror._
reify{2}
{
val x = 2;
val y = x;
{
val x = y;
println(x);
}
{ 
val x = 2
val y = x
val x = y
println(x)
}
val foo = List(1, 2, 3, 4, 5)
val _ :: x :: _ :: z = foo
val _ :: x :: _ :: z :: _ = foo
val foo = List(1, 2, 3, 4, 5, 6, 7)
val _ :: x :: _ :: z :: _ = foo
val _ :: x :: _ :: z :+ _ = foo
val (_ :: x :: _ :: z) :+ _ = foo
val (_ :: (x: Int) :: _ :: z) :+ _ = foo
val (_ :: (x: Int) :: _ :: (z: List[Int]) :+ _ = foo
val ((_ :: (x: Int) :: _ :: (z: List[Int]) :+ _) = foo
scala.reflect.`package`.mirror
def */ = ???
def /* = ???
ds
}
*/
???
=
?
def `/*` = ???
(1, 2, 3) splitAt 1
List(1, 2, 3) splitAt 1
List(1, 2, 3) splitAt 0
val $mr: scala.reflect.`package`.mirror.type = scala.reflect.`package`.mirror;
import $mr._
import scala.reflect.api.Modifier._
val code = Expr[Unit](Block(List(ClassDef(Modifiers(), newTypeName("C"), List(), Template(List(TypeTree(staticClass("scala.ScalaObject").asTypeConstructor)), emptyValDef, List(DefDef(Modifiers(), newTermName("<init>"), List(), List(List()), TypeTree(), Block(List(Apply(Select(Super(This(newTypeName("")), newTypeName("")), newTermName("<init>")), List())), Literal(Constant(())))), ValDef(Modifiers(Set(`private`, local)), newTermName("x "), TypeTree(), Literal(Constant(2))), DefDef(Modifiers(), newTermName("x"), List(), List(), TypeTree(), Select(This(newTypeName("C")), newTermName("x "))))))), Apply(Select(Select(This(staticModule("scala").moduleClass), newTermName("Predef")), newTermName("println")), List(Select(Apply(Select(New(Ident(newTypeName("C"))), newTermName("<init>")), List()), newTermName("x"))))))(TypeTag[Unit](staticClass("scala.Unit").asTypeConstructor))
mkToolBox().runExpr(code)
import scala.reflect.mirror._
reify
lift
scala.reflect.Code
def Qwe = 42
43 match { case Qwe => "" ]
43 match { case Qwe => "" }
val Qwe = 42
43 match { case Qwe => "" }
val qwe = 42
43 match { case qwe => "" }
def foo[T](x: => T) = ???
foo{2}
import scala.reflect.mirror._
reify{reify{2}}
res0.eval
res1.eval
reify{reify{2}}.eval.eval
reify{reify{reify{2}}.eval.eval}
{ val x = 2; reify{x}.eval }
import scala.reflect.mirror._
{ val x = 2; reify{x}.eval }
object C { type T = Int; List[T]() }
object C { val c = C }
import scala.reflect.mirror._
reify(2)
val map = 1 -> 2
val map: Map[Int, Int] = 1 -> 2
val map = Map(1 -> 2)
import scala.reflect.mirror._
reify{List[Int]()}
List[Int](2l)
class C { def foo[T]() = ???; def foo[T, U]() = ??? }
val list = List
list(2)
list[String](2)
list[String]("2")
trait T { type A }
type Pair = (T, T#A)
val t: T = _
val t: T = null
(t, t.l)
(t, t.A)
type X = (t, t.A) forSome t:T
type X = (t, t.A) forSome {t:T}
type X = (t, t.A) forSome {t: T}
trait T { type L }
(x.type, x.L) forSome { val x: T }
(x, x.L) forSome { val x: T }
type Pair = (x.type, x.L) forSome { val x: T }
Pair
val x: T = null
val l: x.L = null
val l: x.L = null.asInstanceOf[x.L]
val pair: Pair = (x, l)
type Pair = (x.type, x.L) forSome { val x: T }
trait T { type L }
type Pair = (x.type, x.L) forSome { val x: T }
val x: T = null
trait T { type L <: Null }
type Pair = (x.type, x.L) forSome { val x: T }
val x: T = null
val l: x.L = null
trait T { type L >: Null }
val l: x.L = null
trait T { type L }
val x: T = ???
trait T { type L }
type Pair = (x.type, x.L) forSome { val x: T }
lazy val x: T = ???
lazy val l: x.L = ???
val pair: Pair = (x, l)
import scala.reflect.makro.Context
def impl(c: Context) = {
println("prefix = " + c.prefix)
println("pos = " + c.expandee.pos)
}
def impl(c: Context) = {
println("prefix = " + c.prefix)
println("pos = " + c.expandee.pos)
c.literalInt(42)
}
def impl(c: Context) = {
println("prefix = " + c.prefix)
c.literalInt(42)
}
def impl(c: Context) = {
println("prefix = " + c.prefix)
println("pos = " + c.expandee.pos)
c.literal(42)
}
implicit def foo = macro impl
implicitly[Int]
implicit val x = 40
implicitly[Int]
def impl(c: Context) = {
println("prefix = " + c.prefix)
println("pos = " + c.expandee.pos)
c.literal(42)
}
import scala.reflect.makro.Context
def impl(c: Context) = {
println("prefix = " + c.prefix)
println("pos = " + c.expandee.pos)
c.literal(42)
}
implicit def foo = macro impl
implicitly[Int]
def bar(implicit x: Int) = x
bar
trait T { type L }
lazy val x: T = ???
lazy val l: x.L = ???
trait T { type L }
scala.reflect.Code.lift
def macro lift(tree: Any) = reify(tree)
lift(2)
lift(scala.reflect.mirror)
showRaw(lift(scala.reflect.mirror))
scala.reflect.mirror.showRaw(lift(scala.reflect.mirror))
lift(List(scala.reflect.mirror))
lift(List[scala.reflect.mirror.type]())
import scala.reflect.mirror._
showRaw(res5)
def macro lift(tree: Any) = println(reify(tree))
def macro lift(tree: Any) = { println(reify(tree)); Literal(Constant(())) }
lift(List[scala.reflect.mirror.type]())
class C(val x: => Int)
class C(x: => Int)
var counter = 0
lazy val x = { counter += 1; counter }
lazy val y = { counter += 1; counter }
class C(val: => Int) { def value = val }
class C(_value: => Int) { def value = _value }
val c1 = new C(x)
val c2 = new C(y)
c2.value
c1.value
x
y
class C(lazy val x: Int)
class C(val x: => Int)
import scala.reflect.mirror._
def foo[T: TypeTag] = reify{List[T]()}
println(foo)
import scala.reflect.mirror._
staticObject("scala.reflect.package")
staticModule("scala.reflect.package")
class C
staticClass("C")
import scala.reflect.makro.Context
def impl(c: Context) = { println(c.prefix.pos.isRange); c.literalUnit }
def impl(c: Context) = { println(c.prefix.tree.pos.isRange); c.literalUnit }
def foo = macro impl
foo
def impl(c: Context) = { println(c.prefix.tree.pos); c.literalUnit }
foo
def foo = macro impl
foo
object Foo { class C }; class Foo { val c: C = new C }
import scala.reflect.mirror._
reify{1 -> 2}
def foo; def bar
;
def foo[T: Manifest]: Int = foo[T]
exit
def foo[T: Ma: Int = foo[T]
def foo[T: Manifest]: Int = foo[T]
import scala.reflect.makro.Context
class C
class D
implicit def c2d(c: C) = new D
def impl(c: Context) = c.reify { new C }
implicit def foo: C = macro Impl
implicit def foo: C = macro impl
val q1(implicit c: C) = println(c)
def q1(implicit c: C) = println(c)
q1
def q2(implicit d: D) = println(d)
q2
class D extends C
implicit def foo: D = macro impl
def impl(c: Context) = c.reify { new D }
implicit def foo: D = macro impl
def q1(implicit c: C) = println(c)
q1
def q1(implicit c: C): Int = q1(c)
def q1(implicit c: C): Int = q1
def q1(implicit c: C): Int = { println(c); q1 }
q1
case class C
class D extends C
case class C(x: Int)
case class D extends C(x: Int)
case class D(x: Int) extends C(x: Int)
def impl[T: TypeTag](x: Int)(y: Int) = ???
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: Int) = ???
def impl[T: c.TypeTag](c: Context)(foo: c.Expr[T]) = ???
def impl[T: c.TypeTag](c: Context)(foo: c.Expr[T]): c.Expr[Unit] = ???
import scala.reflect.mirror._
reify(reify(reify(2)))
res0.eval.eval.eval
trait Foo[+T]
trait Bar[T] extends Foo[T]
class C extends Bar
class C
class D extends C
lazy val fooc: Foo[C] = ???
lazy var fooc: Foo[C] = ???
def qq(fooc: Foo[C]) = ???
def qq(fooc: Foo[C]) {}
lazy val food: Foo[D] = ???
qq(food)
lazy val food: Foo[D] = null
qq(food)
def qq(barc: Bar[C]) {}
lazy val bard: Bar[D] = null
qq(bard)
type T <: Int
class C { type T <: Int; println(classOf[T]) }
class C { type T <: Int; def foo[T: ClassManifest] = println(classManifest[T]) }
new C
res0.foo
trait X { val foo: Foo; abstract class Foo }
class Y { case class foo; object Foo extends foo }
class Y extends X { case class foo; object Foo extends foo }
class Y extends X { case class foo; object Foo extends Foo }
trait X { val foo: FooExtractor; abstract class FooExtractor }
class Y extends X { case class foo; object Foo extends FooExtractor }
class Y extends X { case class foo; object foo extends FooExtractor }
class Z extends Y { override val foo = new FooExtractorImpl; class FooExtractorImpl extends FooExtractor }
class Z extends Y { override val foo = new FooExtractorImpl; class FooExtractorImpl extends foo }
class Z extends Y { override val foo = new Y.foo {} }
class Z extends Y { override val foo = new Y.super.foo {} }
class Z extends Y { override val foo = new Y.this.foo {} }
trait X { trait T }
class Y extends X { case class T extends X.super.T }
class Y extends X { case class T extends X.super#T }
class Y extends X { case class T extends X.T }
class Y extends X { case class T extends X#T }
class Y extends X { case class T(x: Int) extends X#T }
class Y extends X { case class T(x: Int) extends T }
class Y extends X { case class T(x: Int) extends super.T }
trait X { trait T; def foo(t: T) = ??? }
class Y extends X { case class T(x: Int) extends super.T; foo(T(2)) }
new Y
type Foo[T] = Object
new Foo[Nothing]
type X = Array[List[String]]
import scala.reflect.mirror._
reify { new Array[Int] }
import scala.reflect.mirror._
import scala.reflect.makro.Context
def impl[T: c.ClassTag](c: Context): c.Expr[Array[T]] = c.reify { new Array[T] }
def impl[T: c.mirror.ClassTag](c: Context): c.Expr[Array[T]] = c.reify { new Array[T] }
def impl[T: ClassTag](c: Context): c.Expr[Array[T]] = c.reify { new Array[T] }
def impl[T](c: Context): c.Expr[Array[T]] = c.reify { new Array[T] }
import scala.reflect.makro.Context
def impl[T: c.mirror.ClassTag](c: Context): c.Expr[Array[T]] = c.reify { Array[T]() }
def impl[T: ClassManifest](c: Context): c.Expr[Array[T]] = c.reify { Array[T]() }
2.isInstanceOf[Nothing]
type foo = Nothing
2.asInstanceOf[foo]
2.isInstanceOf[Nothing]
(new Object).isInstanceOf[Nothing]
type Foo = Nothing
(new Object).isInstanceOf[Foo]
2.isInstanceOf[Foo]
2.isInstanceOf[Nothing]
def foo(erasure: java.lang.Class[_]) = foo match { case java.lang.Int.TYPE => "foo"; case _ => "bar" }
def foo(erasure: java.lang.Class[_]) = erasure match { case java.lang.Int.TYPE => "foo"; case _ => "bar" }
def foo(erasure: java.lang.Class[_]) = erasure match { case java.lang.Integer.TYPE => "foo"; case _ => "bar" }
def foo[T] = Array[T]()
def foo[T <: Int] = Array[T]()
def foo[T: ClassManifest] = Array[T]()
List[Int]
val x: List[Int] = null
implicitly[ClassTag["s".type]]
def classTag[T](x: T) = implicitly[ClassTag[T]]
def classTag[T: ClassTag](x: T) = implicitly[ClassTag[T]]
classTag("s")
val x = 2
classTag(x.type)
classTag(x)
implicitly[ClassTag[x.type]]
val x = "2"
implicitly[ClassTag[x.type]]
val x = Array[Int]()
val x = Array[Int](2)
manifest[Int]
scala.reflect.mirror
manifest[Int]
class C
import scala.reflect.mirror._
reify { classOf[C] }
classToType(classOf[C])
import scala.reflect.mirror._
classToType(classOf[C])
manifest[Int]
manifest[T]
manifest[Int]
import scala.reflect.mirror._
class A
val c = classToType(classOf[A])
val cl = Thread.currentThread.getContextClassLoader
val mirror = scala.reflect.mkMirror(cl)
import mirror._
class A
val c = classToType(classOf[A])
println(c.typeSymbol == classToSymbol(classOf[A]))
scala.reflect.mirror.reflectionClassLoader
scala.reflect.mirror.asInstanceOf[scala.reflect.runtime.Mirror].reflectionClassLoader
import scala.reflect.mirror._
TypeTag[Int]
implicitly[TypeTag[Int]]
class A
classToType(classOf[A])
def foo[T: ClassManifest](xs: Array[T]) = xs.toArray
foo(Array(1, 2, 3))
def foo[T: Manifest] = Array[T]()
def foo[T: Manifest] = implicitly[Manifest[T]]
classManifest[List[Unit]]
(Array("1", "2") : Array[_ <: AnyRef]).size
(List(1, 2) : List[_]).size 
(Array(1, 2) : Array[_]).size
def foo[T] = Array[Array[T]]()
def foo[T <: Int] = Array[T]()
def foo[T] = Array[T]()
def foo[T] = Array[List[T]]()
implicit def c = new C
def foo(implicit val c: C) = implicitly[C]
def foo(implicit c: C) = implicitly[C]
implicit def c1 = new C
def foo(implicit c: C) = implicitly[C]
classManifest[Array[Int]]
trait X { val x: Int }
class X { def x = 2 }
List(1, 2).tabulate(x => 10 * x)
List.tabulate(1, 2)(x => 10 * x)
List.iterate(1, 2)(x => 10 * x)
List.iterate(1, 1)(x => 10 * x)
Array(1, 2)
Array[Int]()
Array(Array[Int]())
new Array(Array[Int]())
new Array[Int]()
new Array[Int](10)
new Array[Array[Int]](10)
new Array(Array[Int]())
new Array[Array[Int]](10)
val x: Array[Array[Int]] = new Array[Array[Int]](10)
val x: Array[Array[Int]] = (new Array[Array[Int]](10): Array[Array[Int]]
)
def foo[T: ClassTag] = new Array[Array[T]](10)
manifest[Int] <:< manifest[Int]
manifest[List] <:< manifest[Object]
manifest[List[Int]] <:< manifest[Object]
manifest[List[String]] <:< manifest[List[Object]]
classManifest[List[String]] <:< classManifest[List[Object]]
classManifest[List[Object]] <:< classManifest[List[String]]
import scala.reflect.api.Universe
import scala.reflect.makro.Context
import scala.reflect.api.Universe
import scala.reflect.makro.Context
def materializeClassTag[T: c.TypeTag <: ClassTag[_]](c: Context): c.Expr[T] = ???
def materializeClassTag[T <: ClassTag[_]](c: Context): c.Expr[T] = ???
def materializeClassTag[T <: ClassTag[_] : c.TypeTag](c: Context): c.Expr[T] = ???
def materializeTypeTag[T <: u.TypeTag[_] forSome { val u: Universe } : c.TypeTag](c: Context): c.Expr[T] = ???
implicit def foo[T]: List[T] = ???
implicitly[List[Int]]
implicit def foo[T: TypeTag]: List[T] = { println(implicitly[TypeTag[T]]); List[T]() }
implicitly[List[Int]]
class C { def foobar = "" }
new Object().foobar
implicit def foo[T: TypeTag](what: T): C = new C
new Object().foobar
import scala.reflect.makro.Context
def foo_impl[T: c.TypeTag](context: Context)(what: c.Expr[T]): c.Expr[C] = c.reify { println(c.literal(implicitly[c.TypeTag[T]].toString).eval); new C }
def foo_impl[T: c.TypeTag](c: Context)(what: c.Expr[T]): c.Expr[C] = c.reify { println(c.literal(implicitly[c.TypeTag[T]].toString).eval); new C }
implicit def foo[T: TypeTag](what: T): C = macro foo_impl[T]
implicit def foo[T](what: T): C = macro foo_impl[T]
new Object().foobar
2.foobar
import scala.reflect.makro.Context
import scala.reflect.mirror._
reify(2)
import scala.reflect.makro.Context
def foo[T: c.TypeTag](c: Context)(x: c.Expr[Int]) = c.reify { println("hello"); x.eval + 2 }
def qwe(x: Int) = macro foo
def qwe[T](x: Int) = macro foo[T]
qwe[String](2)
case class A(val c:Int, val b:Int, val a:Int)
 val clazz = classOf[A]
val tpe = classToType(clazz)
import scala.reflect.mirror._
val tpe = classToType(clazz)
tpe.members.filter(m => m.isTerm && !m.isMethod).foreach( println(_))
tpe.members.filter(m => m.isMethod).foreach( println(_))
implicitly[TypeTag[Int]]
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: c.Expr[Int]): c.Expr[Int] = c.reify { println(c.literal(implicitly[c.TypeTag[T]]).eval); c.eval + 2 }
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: c.Expr[Int]): c.Expr[Int] = c.reify { println(c.literal(implicitly[c.TypeTag[T]]).eval); c.eval + 2 }
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: c.Expr[Int]): c.Expr[Int] = c.reify { println(c.literal(implicitly[c.TypeTag[T]]).eval); c.eval + 2 }
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: c.Expr[Int]): c.Expr[Int] = c.reify { println(c.literal(implicitly[c.TypeTag[T]]).eval); c.eval + 2 }
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: c.Expr[Int]): c.Expr[Int] = c.reify { println(c.literal(implicitly[c.TypeTag[T]]).eval); c.eval + 2 }
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: c.Expr[Int]): c.Expr[Int] = c.reify { println(c.literal(implicitly[c.TypeTag[T]]).eval); c.eval + 2 }
tag[Int]
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: c.Expr[Int]): c.Expr[Int] = c.reify { println(c.literal(implicitly[c.TypeTag[T]]).eval); c.eval + 2 }
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: c.Expr[Int]): c.Expr[Int] = c.reify { println(c.literal(implicitly[c.TypeTag[T]]).eval); c.eval + 2 }
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: c.Expr[Int]): c.Expr[Int] = c.reify { println(c.literal(implicitly[c.TypeTag[T]]).eval); c.eval + 2 }
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: c.Expr[Int]): c.Expr[Int] = c.reify { println(c.literal(implicitly[c.TypeTag[T]]).eval); c.eval + 2 }
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: c.Expr[Int]): c.Expr[Int] = c.reify { println(c.literal(implicitly[c.TypeTag[T]]).eval); c.eval + 2 }
import scala.reflect.makro.Context
def impl[T: c.TypeTag](c: Context)(x: c.Expr[Int]): c.Expr[Int] = c.reify { println(c.literal(implicitly[c.TypeTag[T]]).eval); c.eval + 2 }
import scala.io.File
import java.io.File
new File("D:\deadlock.txt")
new File("D:\\deadlock.txt")
res0.getCanonicalPath
new File("d:\\deadlock.txt")
res0.getCanonicalPath
manifest[Int]
tag[Int]
manifest[Int]
concreteTag[Int]
manifest[Int]
import scala.reflect.mirror._
classToType(2.getClass)
val x = 2
classToType(x.getClass)
case class DynamicReflectBoxed[T](ttag: TypeTag[T], value: Any)
case class DynamicReflectBoxed[T](ttag: TypeTag[T], value: Any); object DynamicReflectBoxed {
implicit def box[@specialized T: TypeTag](v: T) = DynamicReflectBoxed(v)
}
case class DynamicReflectBoxed[T: TypeTag](value: Any) { val tag = typeTag[T] }; object DynamicReflectBoxed { implicit def box[@specialized T: TypeTag](v: T) = DynamicReflectBoxed(v) }
val x: DynamicReflectBoxed[_] = 2
val x: DynamicReflectBoxed[Int] = 2
case class DynamicReflectBoxed[T: TypeTag](value: Any) { val tag = typeTag[T] }; object DynamicReflectBoxed { implicit def box[T: TypeTag](v: T) = DynamicReflectBoxed(v) }
val x: DynamicReflectBoxed[_] = 2
x.tag
package qwe
package qwe {}
def foo = macro bar
val macro = 2
{ val macro = 2; macro }
def foo[T] = manifest[T]
def foo[T: Manifest](x: T) = manifest[T]
class Bar[T]
foo(new Bar[String] { def f = "abc" })
res0
res0.toString
exist
exit
  val x = "2"
val tt = implicitly[TypeTag[x.type]]
println(tt)
  val x = "2"
val tt = implicitly[TypeTag[x.type]]
println(tt)
class SomeClass
println(tt)
def x[T](implicit mf: Manifest[T]) = mf
x[SomeClass]
{ val x = "2"; val tt = typetag[x.type]; println(tt) }
{ val x = "2"; val tt = typeTag[x.type]; println(tt) }
def foo[T](x: T) = x.asInstanceOf[T]
def foo[T](x: Any) = x.asInstanceOf[T]
foo[String](2)
class C
class D
foo[C](new D)
 case class A(val c:Int, val b:Int, val a:Int)
import scala.reflect.mirror._
val clazz = classOf[A]
val tpe = classToType(clazz)
 tpe.members.filter(m => m.isTerm && !m.isMethod).foreach( println(_))
 case class A(val c:Int, val a:Int, val b:Int)
val tpe = classToType(clazz)
 tpe.members.filter(m => m.isTerm && !m.isMethod).foreach( println(_))
class A(val c:Int, val a:Int, val b:Int)
 case class A(val c:Int, val a:Int, val b:Int)
val clazz = classOf[A]
val tpe = classToType(clazz)
 tpe.members.filter(m => m.isTerm && !m.isMethod).foreach( println(_))
class C[T]
case class D[T: C]
class C[T]
replay
class C[T]
Syste.getProperties()
System.getProperties()
System.getProperties.propertyNames
System.getProperties.propertyNames.toList
System.getProperties.propertyNames.iterator
System.getProperties.propertyNames
  private def systemProperties: Iterator[(String, String)] = {
    import scala.collection.JavaConverters._
    System.getProperties.asScala.iterator
  }
 def systemProperties: Iterator[(String, String)] = {
    import scala.collection.JavaConverters._
    System.getProperties.asScala.iterator
  }systemProperties.toList
def systemProperties: Iterator[(String, String)] = {
    import scala.collection.JavaConverters._
    System.getProperties.asScala.iterator
  }
systemProperties.toList
new Array[Int]()
new Array[Int](2)
manifest[Int]
exit
xs map (x => x)
class Foo[T]
class Foo[+T]
class Bar[+T] extends Foo[+T]
class Bar[+T] extends Foo[T]
import scala.reflect.mirror._
classTag[Int]
Array("1")
import scala.reflect.mirror._
Array(123)
Array("123")
exit
tag[Int]
Array(1)
new Array[Int](1)
tag[Int]
res0.erasure
concreteTag[Int]
res2.erasure
exit
tag[Int]
import scala.reflect.mirror._
tag[Int]
exit
:power
:type -v def foo[T]
:type -v def foo[T] = ???
import scala.reflect.makro.Context
:type -v def foo[T: c.TypeTag](c: Context)(foo: c.Expr[Int]) = ???
Array[Array[Unit]]()
Array[Unit]()
ClassTag.Unit.wrap.newArray(2)
ClassTag.Int.wrap.newArray(2)
Array[Array[Int]]()
classOf[Array[Unit]]
classOf[Array[java.lang.Void]]
Array[Unit]
Array[Unit]()
Array[Array[Unit]]()
exit
Array[Unit]()
Array[Unit]((), (), ())
res1(0)
val res2 = res1(0)
res2
res2.getClass
Array[Array[Unit]]()
Array[Unit]()
new Array[Unit](2)
res1(0)
res1(0).getClass
res1.getClass
new Array[Int](2)
res5.getClass
res5(0).getClass
classOf[Array[Unit]]
new Array[Int](2)
res0.getClass
res0(0).getClass
new Array[Unit](2)
res3.getClass
res3(0).getClass
res3(0).isInstanceOf[Unit]
res3(0).isInstanceOf[BoxedUnit]
res3(0).isInstanceOf[scala.runtime.BoxedUnit]
classOf[Unit]
classOf[BoxedUnit]
classOf[scala.runtime.BoxedUnit]
new Array[Unit](2)
res3.getClass
new Array[Unit](2)
res3.getClass
res4.getClass
res4(0).getClass
def foo[T <: AnyVal : Manifest] = ???
Array[Unit]()
new Array[Unit](2)
res1.getClass
res1(0).getClass
val x = ()
val y = new Array[Unit](2)
x == y(0)
val z = y(0)
x == z
classTag[Byte]
val reg: Regex = null
var reg: scala.text.Regex = null
var reg: scala.Regex = null
class Regex
var reg: Regex = null
scala.reflect.mirror.reify(reg)
{ var reg: Regex = null; scala.reflect.mirror.reify(reg) }
5.getClass
def foo[T: => Int] = ???
def foo[T : => Int] = ???
type Foo[T: List]
type T[+U]
=
Object
def foo[+T] = ???
(x: Int) = ???
type T = Int
T
val x: T = 2
type U
;
class C {
type U
type W <: Int
}
C.U
C#U
tag[C#U]
tag[C#W]
def foo(x: Int, y: x.type) = ???
def foo(x: String, y: x.type) = ???
def foo(x: String, y: Int = x.Length) = ???
def foo(x: String)(y: Int = x.Length) = ???
def foo(x: String)(y: Int = x.length) = ???
def foo[T] = new T()
2 match { case x: List[Int] => ??? }
val x: Any = 2
2 match { case x: List[Int] => ??? }
x match { case x: List[Int] => ??? }
ClassManifest.fromClass[Int](classOf[Int])
ClassManifest.fromClass(classOf[Int])
Array[Unit]((), ())
res0.getClass
res0(0).getClass
new Array[Unit](2)
res3.getClass
res3(0).getClass
res3(0)
val x = res3(0)
x.getClass
class Reporter
class Global { class Reporter }
val global = new Global
import global._
new Reporter
import global.{Importer => _}
import global#{Importer => _}
(0 to 5).map(_ => ()).toArray
def foo[A] = A()
val x = null
x.asInstanceOf[String]
import scala.reflect.makro.Context
tag[Int]
classTag[Int]
erasureTag[Int]
arrayTag[Int]
erasureTag[Int]
arrayTag[Int]
erasureTag[Int].erasure
Array[Array[Int]]()
def foo[T: TypeTag] = Array[T]()
typeTag[Int]
def foo[T] = typeTag[T]
foo[Int]
res1.tpe
res1.erasure
def foo[T]=println(typeTag[T].erasure)
foo
def bind[T](name: String, value: T): IR.Result = bind((name, value)def bind[T](name: String, value: T): IR.Result = bind((name, value)))
def bind[T](name: String, value: T) = typeTag[T]
bind
bind("foo", 2)
res1
res1.erasure
:power
exit
import scala.reflect.mirror._
reify(2)
import scala.reflect.mirror._
reify(2)
res1.erasure
res1.tpe.erasure
res1.tpe
def foo[T](clazz: Class[T]): Class[T] = clazz
val x: Object = "x"
x.getClass
foo(x.getClass)
val y : Class[_] = x.getClass
foo(y)
tag[Int]
res0.erasure
arrayTag[List[Int]]
arrayTag[Class[Int]]
arrayTag[Array[List[Int]]]
arrayTag[List[Int]]
arrayTag[Array[List[Int]]]
Array[Nothing]()
Array[Nothing]().getClass
Array[Array[Nothing]]().getClass
class Foo { def _1: Class[_] = ??? }
case class ClassTag[T](erasure: Class[_]) extends Foo
class C
class D extends C
classOf[D].asSubClass(classOf[C])
classOf[D].asSubclass(classOf[C])
tag[Int]
classTag[Int]
arrayTag[Int]
classTag[Int]
erasureTag[Int]
tag[Array[Int]]
classTag[Array[Int]]
arrayTag[Array[Int]]
erasureTag[Array[Int]]
def foo[T: ArrayTag] = erasureTag[T]
exit
def foo[T: ArrayTag] = erasureTag[T]
arrayTag[Int].newArray(0).getClass.getComponentType
def foo[T: ArrayTag] = erasureTag[T]
foo[Int]
res1.erasure
res1.tpe
typeTag[Unit]
typeTag[Unit].tpe.erasure
typeTag[Null].tpe.erasure
scala.Array.apply(1, scala.this.Predef.wrapIntArray(Array[Int]{2})).asInstanceOf[Array[Object]]
Array.apply(1, Predef.wrapIntArray(Array[Int]{2})).asInstanceOf[Array[Object]]
Array.apply(1)(Predef.wrapIntArray(Array[Int]{2})).asInstanceOf[Array[Object]]
Array.apply(1)(Predef.wrapIntArray(Array[Int](2))).asInstanceOf[Array[Object]]
Array.apply(1, Predef.wrapIntArray(Array[Int](2))).asInstanceOf[Array[Object]]
Array.apply(1, Predef.wrapIntArray(Array[Int](2)): _*).asInstanceOf[Array[Object]]
Array.apply(1, Predef.wrapIntArray(Array[Int](2)): _*)
Array(1).toArray[AnyRef]
Array(1).toArray[Object]
Array(1).map(_ => new Object).toArray
Array(1).map(_ => 1: Object).toArray
Array(1).toArray[AnyVal]
Array(1).toArray[AnyVal].getClass
sys.SystemProperties.traceSourcePath setValue ""
def f = sys.error("hi mom")
f
lastException.show
throw new Exception
lastException
throw new Exception
lastException.show
import scala.reflect.makro.Context
def impl(c: Context)(x: c.Expr[Any]) = { println(c.reifyTree(x.tree)); c.literalUnit }
def impl(c: Context)(x: c.Expr[Any]) = { println(c.reifyTree(c.reflectMirrorPrefix, x.tree)); c.literalUnit }
def foo(x: Any) = macro impl
foo(2)
val x = 2
foo(x)
def impl(c: Context)(x: c.Expr[Any]) = { println(x.tree); c.literalUnit }
def foo(x: Any) = macro impl
foo(x)
def impl(c: Context)(x: c.Expr[Any]) = { println(x); c.literalUnit }
def foo(x: Any) = macro impl
foo(x)
import scala.reflect.makro.Context
def impl(c: Context)(x: c.Expr[Any]) = { println(c.reifyTree(c.reflectMirrorPrefix, x.tree)); c.literalUnit }
def foo(x: Any) = macro impl
{ val x = 2; foo(x) }
Array[Int]()
Array[Array[Int]]()
(1 to 5).toArray
(1 to 5).toArray.elemTag
class Foo[+CC[X] <: Traversable[X]]
type Bar[CC[_]] = Foo[CC]
type Bar[+CC[X] <: Traversable[X]] = Foo[CC]
manifest[Int]
implicitly[Manifest[Int]]
manifest[String with Int]
def foo[T: ClassManifest] = manifest[T]
typeTag[Int]
res0.tpe
typeTag[String].tpe
typeTag[Array[Int]].tpe
typeTag[List[Int]]
import scala.reflect.reify
import scala.reflect.mirror._
reify { 1 match { case 0 => 0 } }
import scala.reflect.mirror._
reify { 1 match { case 0 => 0 } }
import scala.reflect.makro.Context
def impl(c: Context) = { println(c.enclosingApplication); c.literal(2) }
def foo = macro impl
foo
def qwe(x: Int) = x
qwe(foo)
tag[Int]
arrayTag[Int]
arrayTag[Array[Int]]
arrayTag[Int]
arrayTag[Array[Int]]
Array[Int]()
def foo[T: ArrayTag] = Array[T]()
def foo[T: ArrayTag] = new Array[T]()
def foo[T: ArrayTag] = new Array[T](2)
foo[Int]
res0.getClass
arrayTag[Int]
def foo[T: ArrayTag] = classTag[T]
foo[Array[Int]]
manifest[Int]
manifest[java.io.File]
typeTag[java.io.File]
typeTag[Array[java.io.File]]
Array[Int]()
List(1, 2).toArray
Array[Array[Int]]()
manifest[Array[Int]]
import scala.reflect.makro.Context
def foo[T: c.TypeTag](c: Context) = implicitly[c.TypeTag[T]]
def foo[T: c.TypeTag](c: Context) = implicitly[c.TypeTag[T]].toString
def foo[T: c.TypeTag](c: Context) = c.reify { implicitly[c.TypeTag[T]].toString }
def foo[T: ArrayTag] = classTag[T]
def foo = classTag[Int]
def foo = classTag[List[Int]]
def foo = classTag[Array[Int]]
import scala.reflect.makro.Context
def foo[T: c.TypeTag](c: Context) = c.literal(tag[T].typeSymbol.isLocatable)
def foo[T: c.TypeTag](c: Context) = c.literal(tag[T].sym.isLocatable)
def foo[T: c.TypeTag](c: Context) = c.literal(c.isLocatable(tag[T].sym))
def foo[T: c.TypeTag](c: Context) = c.literal(c.isLocatable(c.tag[T].sym))
class C
foo[C]
def f[T] = macro foo[T]
f[C]
class D { class C }
f[D#C]
import scala.reflect.makro.Context
def foo(c: Context) = c.literal(2)
def foomacro = macro foo
object Test extends APp
object Test extends App
object Test extends App { val x = foomacro }
import scala.reflect.mirror._
reify(classOf[Int])
reify{ class C; classOf[C]; ()}
import scala.reflect.mirror
reify
import scala.reflect.mirror._
reify
import scala.reflect.mirror._
reify
def decl[A] = macro impl[A]
decl
import scala.reflect.mirror._
reify
import scala.reflect.mirror._
reify
import language.experimental.macros
import scala.reflect.makro.Context

object Level extends Enumeration {
  val Error = Value(5)
}

object Logger {
  def error(message: String): Unit = macro LoggerMacros.error
}

private object LoggerMacros {

  type LoggerContext = Context { type PrefixType = Logger.type }

  def error(c: LoggerContext)(message: c.Expr[String]): c.Expr[Unit] =
    log(c)(c.reify(Level.Error), message)

  private def log(c: LoggerContext)(level: c.Expr[Level.Value], message: c.Expr[String]): c.Expr[Unit] = 
    if (level.eval.id < 4) // TODO Remove hack!
      c.reify(())
    else {
      c.reify(println(message.eval))
    }
}
:power
power.trees
power.context
intp.allImplicits
intp.virtualDirectory
intp.typeOfTerm(2)
val x = 2
intp.typeOfTerm("X")
intp.typeOfTerm("x")
res3.baseTypeSeq
:type -v def foo[T]
:type -v def foo[T] = ???
:type -v x
showRaw(Literal(Constant(2))
)
import scala.reflect.makro.Context
:type -v def impl[T: c.TypeTag](c: Context) = ???
import scala.reflect.mirror
trait X { def foo: String }
typeTag[X { def foo = "hi!" }]
typeTag[X]
res1.tpe.members
import scala.reflect.mirror._
reify(2+2)
showRaw(res0)
showRaw(res0.tree)
reify(2.toString)
showRaw(res3.toString)
showRaw(res3.tree)
import scala.reflect.mirror._
reify{ val x = 2 }
showRaw(res0.tree)
def foo = { object Foo; Foo }
def foo = { object Foo { def x = 2 }; Foo }
:power
class A
class A { def bar = 10 }
import scala.reflect.mirror._
classToType(classOf[A])
res2.members
classTag[Int]
res4.erasure
res4.newArray(2)
classTag[Int with String]
typeTag[Int with String]
typeTag[List[Int]]
typeTag[List[_]]
def foo[T] = typeTag[T]
foo[Int]
res11.tpe
res11.tpe.typeSymbol
def foo[T: TypeTag] = typeTag[T]
foo[String]
foo[String](typeTag[String])
def foo[T: Manifest] = manifest[T]
foo[String]
def foo[T] = typeTag[T]
def foo[T] = manifest[T]
def foo[T] = typeTag[T]
def foo[T] = concreteTypeTag[T]
def foo[T] = concreteTypeTag[List[T]]
def foo[T: ConcreteTypeTag] = concreteTypeTag[List[T]]
def foo[T: ClassTag] = classTag[List[T]]
foo[Int]
def foo[T: ClassTag] = classTag[Array[T]]
foo[Int]
scala.reflect.mirror.reify(2)
res2.tpe
appliedType(definitions.ListClass.asType, List(definitions.IntClass.asType))
import scala.reflect.mirror._
appliedType(definitions.ListClass.asType, List(definitions.IntClass.asType))
import scala.reflect.mirror._
staticClass("Int")
staticClass("scala.Int")
import scala.reflect.mirror._
classToType(classOf[Int])
import Macros._
println("hello %s!")
printf("hello %s!")
exit
scala.reflect.mirror.reify(object Test {
  println("Hello World!")
}}
scala.reflect.mirror.reify{object Test {
  println("Hello World!")
}}
showRaw(res0)
scala.reflect.mirror(showRaw(res0))
scala.reflect.mirror.showRaw(res0)
scala.reflect.mirror.showRaw(res0.tree)
def foo(x: Int) =???
def foo(x: Int) = ???
foo("2")
scala.reflect.mirror.reify(2)
scala.reflect.mirror.reify("hello world")
scala.reflect.mirror.reify("hello " + "world")
scala.reflect.mirror.reify(2.toString)
def foo[T] = println(classOf[T])
def foo[T: TypeTag] = println(classOf[T])
def foo[T: ClassTag] = println(classOf[T])
def foo[T](x: T) = println(x.getClass)
foo({ object Bar; Bar })
def foo[T: TypeTag](x: T) = println(typeTag[T])
foo({ object Bar; Bar })
def foo[T](x: T) = println(x.getClass)
foo(List(1, 2, 3))
def foo[T: TypeTag](x: T) = println(typeTag[T])
foo(List(1, 2, 3))
def foo[T](x: T) = println(x.getClass)
val list = List(1, 2, 3)
foo(list)
val list = List(1, 2, 3).toList
foo(list)
def foo[T](x: T) = x.getClass
foo(list)
def foo[T: TypeTag](x: T) = typeTag[T]
foo(list)
def foo[T](x: T) = x.getClass
foo(List(1, 2, 3))
def foo[T: TypeTag](x: T) = typeTag[T]
foo(List(1, 2, 3))
res1.tpe
def ?=[T](my: T, oldnew: (T, T)) =???
def ?=[T](my: T, oldnew: (T, T)) = ???
import scala.reflect.mirror._
definitions.IntClass match { case TypeRef(pre, sym, args) => sym }
???
def foo = ???
type Foo[T] = ClassManifest[T]
implicitly[Foo[Int]]
1 -> 2
import math.Numeric.Implicits._
import Ordering.Implicits._
def plus[T](a: T, b: T)(implicit n: Numeric[T]) = a + b
classOf[Int]
classOf[Integer]
classTag[List[_]]
classManifest[List[_]]
classTag[Predef.ArrowAssoc[
]]
classTag[Predef.ArrowAssoc]
classTag[Predef.ArrowAssoc[_]]
classManifest[Predef.ArrowAssoc[_]]
import reflect.mirror._
typeToClass(tag[String].tpe)
typeToClass(tag[List[String]].tpe)
case class Artist(name: String)
typeToClass(tag[Artist].tpe)
tag[Artist].tpe
val m = classToType(classOf[Artist]).members.filter(!_.isMethod).head
val t = m.typeSignature
typeToClass(t)
 import reflect.mirror._
typeToClass(tag[String].tpe)
typeToClass(tag[List[String]].tpe)
case class Artist(name: String)
typeToClass(tag[Artist].tpe)
classTag[Int]
classTag[Array[Int]]
def tagme[T](x: T) = typeTag[T]
val foo = tagMe{object Bar; Bar}
val foo = tagme{object Bar; Bar}
foo.tpe
def tagme[T: TypeTag](x: T) = typeTag[T]
val foo = tagme{object Bar; Bar}
def tagme[T: TypeTag](x: T) = typeTag[T]
val foo = tagme{object Bar; Bar}
def tagme[T: TypeTag](x: T) = typeTag[T]
val foo = tagme{object Bar; Bar}
def tagme[T: TypeTag](x: T) = typeTag[T]
import scala.reflect.mirror._
reify { 1 match { case 0 => 0 } }
exit
typeTag[Int]
c;assTag[Int]
classTag[Int]
exit
typeTag[Int]
classTag[Int]
exit
typeTag[Int]
typeTag[List[Int]]
import scala.reflect.makro.Context
def impl(c: Context) = c.literalUnit
def foo = macro impl
foo
def foo[T] = typeTag[T]
typeTag[Int]
typeTag[List[Int]]
(1 -> 2).toMap
Map(1 -> 2)
Map(1 -> 2) map { case (k, v) => ??? }
2+2
exit
typeTag[Int]
exit
typeTag[Int]
exit
typeTag[Int]
exit
typeTag[Int]
exit
typeTag[Int]
exit
typeTag[Int]
Map(1->2)
res0.keys
res0.values
typeTag[List[Int]]
class C
trait T extends C
IntClass
lub(IntClass, StrinClass)
IntClass.tpe.lub(StringClass.tpe)
lub(List(IntClass.tpe, StringClass.tpe))
glb(List(IntClass.tpe, StringClass.tpe))
class D
trait X extends C with D
abstract class Foo(x: Int)
new { val foo = "" } with Foo(2)
type Base; object Base
class X { type Base; object Base }
class A { val a = 2; var b = 3 }
classToType(classOf[A]).tpe
import scala.reflect.mirror._
classToType(classOf[A]).tpe
classToType(classOf[A]).declarations
classToType(classOf[A]).declarations.toList
res2(1)
classToType(classOf[A]).declarations.filter(!_.isMethod).toList
res5(0).modifiers
res5(1).modifiers
class A { val a = 2; var b = 3 }
import scala.reflect.mirror._
classToType(classOf[A]).declarations.filter(!_.isMethod).toList
res8(0).modifiers
res8(1).modifiers
classTag[List[Int]]
res0.erasure
class Foo { val FooTag = classTag[Foo] }
new Foo().FooTag
new Foo().FooTag.erasure
class Foo { implicit val FooTag = classTag[Foo] }
new Foo().FooTag.erasure
val f : Int => Int = _ + 10
List(1,2,3).par.view.map(f).find(_ > 11)
val f : Int => Int = _ + 10
List(1,2,3).par.view.map(f).find(_ > 11)
exit
class X
class Y extends X
object Ambiguous {
  def f(x: X) = 1
  def f(ys: Y*) = 2
}
 Ambiguous.f(new X)
Ambiguous.f(new Y)
exit
type AI = Array[Int]
import scala.reflect.mirror._
reify{ val x: AI = null }
reify { val x: Array[Int] = null }
import scala.reflect.mirror._
reify{
def callme(x: Int): (Int, Int) = (1, 2)
val (one, two) = callme(10)
})
reify{
def callme(x: Int): (Int, Int) = (1, 2)
val (one, two) = callme(10)
}
reify{
def callme(x: Int): (Int, Int) = { println("a"); (1, 2) }
val (one, two) = callme(10)
}
def callme(x: Int): (Int, Int) = { println("a"); (1, 2) }
reify{
val (one, two) = { println("stuff"); callme(10); }
}
type q = List[=> Int]
typeTag[Int]
exit
typeTag[Int]
type B
;
type A = Int
type B = String
class Q { type C <: A <: B }
class Q { type C <: A, B }
trait A
trait A { def a = 100 }
trait B { def b = 200 }
abstract class C { type D <: A with B; def foo(d: D) = println(s"${d.a} ${d.b}") }
class E extends A with B
class F extends C { type D = E }
new F().foo(new F())
new F().foo(new E())
cas
case class C
case class X(x: Int)
case class X(x: Int, y: Int)
def Apply(x: Int) = ???
case class Apply(s: String)
val Apply(foo) = Apply("bar")
def Apply(x: Int) = ???
class ApplyExtractor {
class Apply
def Apply(x: Int) = ???
class ApplyExtractor {
def apply(x: Int) = new Apply
def unapply(apply: Apply): Option[Int] = Some(42)
}
val Apply: ApplyExtractor = new ApplyExtractor
val Apply(x) = new Apply
case class TypeTree()
case class Blah()
typeTag[Int]
typeTag[List[Int]]
exit
typeTag[List[String]]
typeTag[List[Int]]
typetag[Int]
typeTag[Int]
typeTag[List[Int]]
exit
typeTag[Int]
typeTag[List[Int]]
exit
def foo
= ???
class C
classOf[C].getName
object D { class C }
classOf[D.C].getName
classOf[scala.tools.nsc.io.File].getName
class C
new {} with C
new { self: C => } with C
2 + 2
2121
2 + 2
val a = 2
class C
val c = new C
import a._, c._
Nil drop 1
object c { object f }
object d
import d._, c._, f._
object c { object f { def foo = "" } }
import d._, c._, f._
foo
trait C { type Q <: AnyRef }
trait C { type Q <: AnyRef; var q: Q = null }
import scala.reflect.base.Universe
:type -v def foo[T](tt: scala.reflect.base.Universe # TypeTag[T]) = ???
:type -v def foo[T](tt: scala.reflect.api.Universe # TypeTag[T]) = ???
scala.reflect.mirror
val ru = scala.reflect.miror
val ru = scala.reflect.mirror
def impl(c: scala.reflect.makro.Context)(x: c.Expr[String]): c.Expr[String] = ???
import scala.reflect.mirror._
typeTag[List[Int]]
implicitly[manifest[List[Int]]
\
]
implicitly[manifest[List[Int]]]
implicitly[Manifest[List[Int]]]
implicitly[Manifest[
\\
]]]]
implicitly[Manifest[List[Int]]
]
implicitly[Manifest[List[String]]]
reify{ val x = 2 + 2 }
val x = 2
reify { val y = x + 2 }
{ val x = 2; reify { val y = x + 2 } }
import scala.reflect.mirror._
{ val x = 2; reify { val y = x + 2 } }
val x = 2
scala.reflect.Code.lift{val y = x + 2}
res0.tree
{ val x = 2; scala.reflect.Code.lift{val y = x + 2} }
res2.tree
exit
{ val x = 2; scala.reflect.Code.lift{val y = x + 2} }
exit
{ val x = 2; scala.reflect.Code.lift{val y = x + 2} }
exit
type L = List[_ <: Any]
type L = List[T] forSome { type T <: Any }
type S = Set[T] forSome { type T <: Any }
def foo(s: collection.mutable.Set[T] forSome { type T <: Any }) = ???
def foo(s: collection.mutable.Set[T forSome { type T <: Any }]) = ???
foo(Set(1, 2, 3))
foo(collection.mutable.Set(1, 2, 3))
2 + 2
exit
class Foo { override def toString = "foo" }
case class Bar() extends Foo
Bar()
def T1 { println("hello 1") }
def T2 { println("hello 2") }
class C extends T1 with T2
trait T2 { println("hello 2") }
trait T1 { println("hello 1") }
class C extends T1 with T2
new C
class C extends T2 with T1
new C
:power
definitions.ListClass
appliedType(definitions.ListClass.asType, List(definitions.IntClass.asType))
appliedType(definitions.SeqClass.asType, List(definitions.IntClass.asType))
res1 <:< res2
definitions.IntClass.asType <:< definitions.LongClass.asType
definitions.LongClass.asType <:< definitions.IntClass.asType
case class LitInt(i: Int)
val map = collection.mutable.Map[Int, Int]()
map += 1 -> 2
"%d".format(null)
"foo%dbar".format(null)
"%d".format(2.0)
val c: Int with Character = 'a'
def foo[T](x: Int) = x
def foo[T, U](x: Int) = x
foo(1)
def foo[T, U](x: Int) = x + 1
foo(1)
class C(x = 2)
:type -v def foo(x: => Int) = ???
:type -v => Int
def foo(implicit x: Int) = x; def foo(y: Int)(implicit x: Int) = x + y
implicit val x = 2
foo
def foo(y: Int)(implicit x: Int) = x + y
foo
def foo(y: Int = 0)(implicit x: Int) = x + y
foo
foo()
import scala.reflect.mirror
def typeOf[T: ConcreteTypeTag] = implicitly[ConcreteTypeTag[T]]
typeOf[Int]
def typeOf[T: ConcreteTypeTag](x: T = null.asInstanceOf[T]) = implicitly[ConcreteTypeTag[T]]
typeOf[Int]
collection.mutable.ArrayBuffer[Int](1, 2)
collection.mutable.ArrayBuffer[Int](List(1, 2))
collection.mutable.ArrayBuffer[Int](List(1, 2): _*)
case class C(var x: Int = 2)
C()
C().copy
C().copy()
import scala.reflect.mirror._
staticClass("scala.Nothing")
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
exit
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
exit
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
exit
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
exit
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
exit
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
exit
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
scala.reflect.runtime.currentMirror
res1.staticClass("scala.Nothing")
scala.reflect.runtime.universe.rootMirror.staticClass("scala.Nothing")
scala.reflect.runtime.universe.rootMirror.staticModule("scala.Nothing")
scala.reflect.runtime.universe.rootMirror.staticModule("scala")
scala.reflect.runtime.universe.rootMirror.staticModule("scala").moduleClass.asTypeSymbol.asType.typeSignature
scala.reflect.runtime.universe.rootMirror.staticModule("scala").moduleClass.asTypeSymbol.asType.members.toList
scala.reflect.runtime.universe.currentMirror.staticModule("scala")
scala.reflect.runtime.currentMirror.staticModule("scala")
res9.staticModule("scala").moduleClass.asTypeSymbol.asType.members.toList
res9.moduleClass.asTypeSymbol.asType.members.toList
exit
cm
exit
root
rootMirror.staticClass("scala.Nothing")
cm.staticClass("scala.Nothing")
rootMirror.EmptyPackageClass.asTypeSymbol.asTypeConstructor
rootMirror.EmptyPackageClass.asTypeSymbol.asTypeConstructor.typeSignature
rootMirror.EmptyPackageClass.typeSignature
rootMirror.EmptyPackage.typeSignature
rootMirror.EmptyPackageClass.initialize.typeSignature
rootMirror.EmptyPackageClass.asInstanceOf[scala.reflect.internal.Symbol].initialize
rootMirror.EmptyPackageClass.asInstanceOf[scala.reflect.internal.Symbols#Symbol].initialize
rootMirror.EmptyPackageClass.typeSignature
rootMirror.RootClass.typeSignature
rootMirror.RootClass.typeSignature.member(newTermName("scala"))
rootMirror.RootClass.typeSignature.member(newTermName("scala")).typeSignature
rootMirror.RootClass.typeSignature.member(newTermName("scala")).moduleClass.typeSignature
rootMirror.RootClass.typeSignature.member(newTermName("scala")).asModuleSymbol.moduleClass.typeSignature
rootMirror.RootClass.typeSignature.member(newTermName("scala")).asModuleSymbol.moduleClass.typeSignature.member(newTermName("Nothing"))
rootMirror.RootClass.typeSignature.member(newTermName("scala")).asModuleSymbol.moduleClass.typeSignature.member(newTermName("scala.Nothing"))
2
exit
2
exit
2
exit
exit\
2
22
exit
2
exit
2
cm.staticClass("scala.Nothing")
definitions.ScalaPackageClass
cm.staticModule("scala").moduleClass
cm.staticModule("scala").companionSymbol
cm.staticModule("scala").moduleClass
exit
definScalaPackage
definitions.ScalaPackage
cm.staticModule("scala")
rm.staticModule("scala")
val m = ru.runtimeMirror(null)
rb
ru
val ru = scala.reflect.runtime.universe
val m = ru.runtimeMirror(null)
rm
exit
rm
cm
ru.runtimeMirror(null)
exit
cm
rm
runtimeMirror(null)
runtimeMirror(null).staticClass("scala")
cm.classLoader
cm.classLoader.parent
cm.classLoader.getParent
scala.reflect.runtime.show(cm.classLoader.getParent)
scala.reflect.runtime.ReflectionUtil.show(cm.classLoader.getParent)
scala.reflect.runtime.ReflectionUtils.show(cm.classLoader.getParent)
rm
rm.classLoader.loadClass("scala.package")
res6.loadClass("scala.package")
exit
rm
cm
exit
show(cm.classLo
d
)
show(cm.classLoader)
exit
show(cm.classLoader)
println show(cm.classLoader)
println(show(cm.classLoader))
exit
ScalaPackageClass
rm.staticClass("scala")
rm.staticPackage("scala").moduleClass
rm.staticModule("scala").moduleClass
ScalaPackage
rm.staticModule("scala")
cm.staticModule("scala")
RootPackage
exit
rm
exit
rm // aka scala.reflect.runtime.universe.rootMirror
cm // aka scala.reflect.runtime.currentMirror
ScalaPackage
rm.staticModule("scala")
cm.staticModule("scala")
exit
cm
exit
cm
2
exit
cm
exit
rm.staticClass("scala.Any")
AnyClass
rm.staticClass("scala.AnyRef")
rm.staticClass("scala.AnyVal")
AnyValClass
cm.staticClass("scala.Any")
cm.staticClass("scala.AnyVal")
cm.staticClass("scala.Int")
rm.staticClass("scala.Int")
IntClass
exit
reify { def foo[T <: String with Singleton] = ??? }
exit
import scala.reflect.mirror._
reify{ def foo[T <: String with Singleton] = ??? }
reify{ def foo[T <: String] = ??? }
reify { abstract class C extends Seq[Int] with TraversableOnce[Int] }
exit
typeOf[{ def x: Int }]
exit
def foo[T] = classOf[T]
def foo[T] = classOf[List[T]]
foo[Int]
def foo[T] = classOf[Array[T]]
foo[Int]
def foo[T] = classOf[Array[Array[T]]]
foo
def foo[T] = classOf[Array[Int]]
foo
def foo[T] = classOf[Array[T]]
foo
foo == classOf[Object]
exit
cm
exit
import scala.reflect.mirror._
implicitly[TypeTag[List[Int]]
]
implicitly[TypeTag[List[Int]]]
implicitly[TypeTag[List[Int]]].tpe
typeOf[List[Int]]
{
  import scala.reflect.runtime.universe._
  val x = "2"
  val tt = implicitly[TypeTag[x.type]]
  println(tt)
}
val x = "2"
typeOf[x.type]
{
val y = "2"
typeOf[y.type]
}
exit
{
  import scala.reflect.runtime.universe._
  val x = "2"
  val tt = implicitly[TypeTag[x.type]]
  println(tt)
}
parse this
parse
exit
{
  import scala.reflect.runtime.universe._
  val x = "2"
  val tt = implicitly[TypeTag[x.type]]
  println(tt)
}
exit
classOf[Array[_ <: Object]]
classTag[Array[_ <: Object]]
def foo[T <: Object] = classTag[Array[T]]
def foo[T <: Object] = classOf[Array[T]]
foo
:type scala.reflect.mirror.Type
:type -v scala.reflect.mirror
:type -v scala.reflect.Code
:type -v scala.reflect.ScalaSignature
val List(1, 2, _*) = List(1, 2, 3, 4)
val List(1, 2, _) = List(1, 2, 3, 4)
val List(1, 2) = List(1, 2, 3, 4)
val List(x, y) = List(1, 2, 3, 4)
val List(1, 2) = List(1, 2, 3, 4)
val List(1) = List(1)
cm
cm.staticClass("Nothing")
cm.staticClass("scala.Nothing")
exit
class C {
type T
implicit val tag: ClassT
}
class C {
type T[U]
implicit val tag: ClassTag[T]
}
cm
cm.staticClass("scala.Nothing")
cm.staticClass("java.lang.String")
exit
class C { s"$this" }
class C { s"$yield" }
case clas
class foo extends StaticAnnotation
class foo extends annotation.StaticAnnotation
case class C(@foo x: Int)
case class C(x: Int)
cm.reflectClass(classOf[C])
res0.asTypeSymbol.asTypeConstructor
res0.symbol.asTypeSymbol.asTypeConstructor
res2.member(nme.CONSTRUCTOR)
val MethodType(params, _) = res3.typeSignature
params.map(_.typeSignature)
List(1, 2, 3) map (x => new { i = x })
List(1, 2, 3) map (x => new { val i = x })
res1(0).i
List(1, 2, 3) map (x => new { val i = x })
res1(0).i
res0(0).i
reify(new { val a = 1; val b = 2 })
val c: scala.reflect.makro.Context = null
:type c.universe
:type c.mirror
:type c.mirror.type
:type -v c.mirror
def q: c.mirror.type = ???
:type -v q
def q(x: Int): c.mirror.type = ???
:type -v q
:type -v def q: c.mirror.type = ???
"2".asInstanceOf[type { def toString: String }]
"2".asInstanceOf[{ def toString: String }]
"2".asInstanceOf[{ def toString: String }].toString
def foo = foo
classTag[Int]
scala.reflect.classTag[Int]
exit
scala.reflect.classTag[Int]
ru.typeOf[Int]
ru.typeOf[List[Int]]
exit
typeTag[List[Int]]
typeOf[List[Int]]
exit
typeTag[Int]
exit
typeTag[Int]
typeTag[List[Int]]
reify
typeTag
exit
classTag[Int]
typeTag[List[Int]]
exit
scala.reflect.runtime.currentMirror
scala.reflect.runtime.universe
scala.reflect.mirror
exit
class A {
 var x: Int = 42
}

val a = new A
val im: InstanceMirror = cm.reflect(a)
val cs = im.reflectClass.symbol
val f = cs.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f)
fm.field.isVariable
class A {
 var x: Int = 42
}

val a = new A

val im: InstanceMirror = cm.reflect(a)
val cs = im.reflectClass.symbol
val f = cs.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f)
fm.field.isVariable
reify { class A { var x = 42 } }
class A {
 var x: Int = 42
}

val a = new A

val im: InstanceMirror = cm.reflect(a)
val cs = im.reflectClass.symbol
val f = cs.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f)
fm.field.isVariable
"%x".format(22222)
"%x8".format(22222)
"%x:8".format(22222)
"%08x".format(22222)
"%%d".format(42)
def f: Function0[Int] = ???
def foo[T: TypeTag] = Array[T]()
def foo[T: ClassTag] = Array[T]()
reify(2)
exit
typeOf[List[Int]]
typeof[List[Int]]
typeOf[List[Int]]
m { val x = 1; x }
import scala.reflect.makro._
object Fun { def fun[A: c.TypeTag](c: Context)(x: c.Expr[A]) = c.reify( () => x.eval ) }
object Fun { def fun[A: c.TypeTag](c: Context)(x: c.Expr[A]) = c.reify( () => x.splice
)}
def m[A](x: A) = macro Fun.fun[A]
m(1)
m { val x = 1; 2 }
m { val x = 1; x }
scala.Nil
List(1, 2, 3).foldRight(0)(_ + _)
List(1, 2, 3).foldRight(0)((x, y) => { println(x); x + y })
{ val x = 2; reify(x) }
object Foo { val x = 2 }
import Foo._
reify(x)
exit
:type -v def foo = ???
:type def foo = ???
:type -v def foo = ???
:type def foo = ???
:type -v def foo = ???
List(1, 2, 3).productIterator
List(1, 2, 3).productIterator.toList
class Foo { def bar(x: Int) = x }
import scala.reflect.runtime.universe._ // requires scala-reflect.jar
val foo = new Foo
runtimeMirror(getClass.getClassLoader).reflect(foo)
res0.declaration(newTermName("foo"))
res0.symbol.typeSignature.declaration(newTermName("foo"))
res0.symbol.typeSignature.declarations()
res0.symbol.typeSignature.declarations
class Foo { def bar(x: Int) = x }
val foo = new Foo
runtimeMirror(getClass.getClassLoader).reflect(foo)
res0.symbol.typeSignature.declaration(newTermName("bar"))
res0.reflectMethod(res1.asMethodSymbol)(42)
class C { class D }
:type -v def foo(x: C#D) = ???
:type -v x: C#D = ???
:type -v def x: C#D = ???
