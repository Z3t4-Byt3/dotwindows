Array.apply(1, Predef.wrapIntArray(Array[Int]{2})).asInstanceOf[Array[Object]]
Array.apply(1)(Predef.wrapIntArray(Array[Int]{2})).asInstanceOf[Array[Object]]
Array.apply(1)(Predef.wrapIntArray(Array[Int](2))).asInstanceOf[Array[Object]]
Array.apply(1, Predef.wrapIntArray(Array[Int](2))).asInstanceOf[Array[Object]]
Array.apply(1, Predef.wrapIntArray(Array[Int](2)): _*).asInstanceOf[Array[Object]]
Array.apply(1, Predef.wrapIntArray(Array[Int](2)): _*)
Array(1).toArray[AnyRef]
Array(1).toArray[Object]
Array(1).map(_ => new Object).toArray
Array(1).map(_ => 1: Object).toArray
Array(1).toArray[AnyVal]
Array(1).toArray[AnyVal].getClass
sys.SystemProperties.traceSourcePath setValue ""
def f = sys.error("hi mom")
f
lastException.show
throw new Exception
lastException
throw new Exception
lastException.show
import scala.reflect.makro.Context
def impl(c: Context)(x: c.Expr[Any]) = { println(c.reifyTree(x.tree)); c.literalUnit }
def impl(c: Context)(x: c.Expr[Any]) = { println(c.reifyTree(c.reflectMirrorPrefix, x.tree)); c.literalUnit }
def foo(x: Any) = macro impl
foo(2)
val x = 2
foo(x)
def impl(c: Context)(x: c.Expr[Any]) = { println(x.tree); c.literalUnit }
def foo(x: Any) = macro impl
foo(x)
def impl(c: Context)(x: c.Expr[Any]) = { println(x); c.literalUnit }
def foo(x: Any) = macro impl
foo(x)
import scala.reflect.makro.Context
def impl(c: Context)(x: c.Expr[Any]) = { println(c.reifyTree(c.reflectMirrorPrefix, x.tree)); c.literalUnit }
def foo(x: Any) = macro impl
{ val x = 2; foo(x) }
Array[Int]()
Array[Array[Int]]()
(1 to 5).toArray
(1 to 5).toArray.elemTag
class Foo[+CC[X] <: Traversable[X]]
type Bar[CC[_]] = Foo[CC]
type Bar[+CC[X] <: Traversable[X]] = Foo[CC]
manifest[Int]
implicitly[Manifest[Int]]
manifest[String with Int]
def foo[T: ClassManifest] = manifest[T]
typeTag[Int]
res0.tpe
typeTag[String].tpe
typeTag[Array[Int]].tpe
typeTag[List[Int]]
import scala.reflect.reify
import scala.reflect.mirror._
reify { 1 match { case 0 => 0 } }
import scala.reflect.mirror._
reify { 1 match { case 0 => 0 } }
import scala.reflect.makro.Context
def impl(c: Context) = { println(c.enclosingApplication); c.literal(2) }
def foo = macro impl
foo
def qwe(x: Int) = x
qwe(foo)
tag[Int]
arrayTag[Int]
arrayTag[Array[Int]]
arrayTag[Int]
arrayTag[Array[Int]]
Array[Int]()
def foo[T: ArrayTag] = Array[T]()
def foo[T: ArrayTag] = new Array[T]()
def foo[T: ArrayTag] = new Array[T](2)
foo[Int]
res0.getClass
arrayTag[Int]
def foo[T: ArrayTag] = classTag[T]
foo[Array[Int]]
manifest[Int]
manifest[java.io.File]
typeTag[java.io.File]
typeTag[Array[java.io.File]]
Array[Int]()
List(1, 2).toArray
Array[Array[Int]]()
manifest[Array[Int]]
import scala.reflect.makro.Context
def foo[T: c.TypeTag](c: Context) = implicitly[c.TypeTag[T]]
def foo[T: c.TypeTag](c: Context) = implicitly[c.TypeTag[T]].toString
def foo[T: c.TypeTag](c: Context) = c.reify { implicitly[c.TypeTag[T]].toString }
def foo[T: ArrayTag] = classTag[T]
def foo = classTag[Int]
def foo = classTag[List[Int]]
def foo = classTag[Array[Int]]
import scala.reflect.makro.Context
def foo[T: c.TypeTag](c: Context) = c.literal(tag[T].typeSymbol.isLocatable)
def foo[T: c.TypeTag](c: Context) = c.literal(tag[T].sym.isLocatable)
def foo[T: c.TypeTag](c: Context) = c.literal(c.isLocatable(tag[T].sym))
def foo[T: c.TypeTag](c: Context) = c.literal(c.isLocatable(c.tag[T].sym))
class C
foo[C]
def f[T] = macro foo[T]
f[C]
class D { class C }
f[D#C]
import scala.reflect.makro.Context
def foo(c: Context) = c.literal(2)
def foomacro = macro foo
object Test extends APp
object Test extends App
object Test extends App { val x = foomacro }
import scala.reflect.mirror._
reify(classOf[Int])
reify{ class C; classOf[C]; ()}
import scala.reflect.mirror
reify
import scala.reflect.mirror._
reify
import scala.reflect.mirror._
reify
def decl[A] = macro impl[A]
decl
import scala.reflect.mirror._
reify
import scala.reflect.mirror._
reify
import language.experimental.macros
import scala.reflect.makro.Context

object Level extends Enumeration {
  val Error = Value(5)
}

object Logger {
  def error(message: String): Unit = macro LoggerMacros.error
}

private object LoggerMacros {

  type LoggerContext = Context { type PrefixType = Logger.type }

  def error(c: LoggerContext)(message: c.Expr[String]): c.Expr[Unit] =
    log(c)(c.reify(Level.Error), message)

  private def log(c: LoggerContext)(level: c.Expr[Level.Value], message: c.Expr[String]): c.Expr[Unit] = 
    if (level.eval.id < 4) // TODO Remove hack!
      c.reify(())
    else {
      c.reify(println(message.eval))
    }
}
:power
power.trees
power.context
intp.allImplicits
intp.virtualDirectory
intp.typeOfTerm(2)
val x = 2
intp.typeOfTerm("X")
intp.typeOfTerm("x")
res3.baseTypeSeq
:type -v def foo[T]
:type -v def foo[T] = ???
:type -v x
showRaw(Literal(Constant(2))
)
import scala.reflect.makro.Context
:type -v def impl[T: c.TypeTag](c: Context) = ???
import scala.reflect.mirror
trait X { def foo: String }
typeTag[X { def foo = "hi!" }]
typeTag[X]
res1.tpe.members
import scala.reflect.mirror._
reify(2+2)
showRaw(res0)
showRaw(res0.tree)
reify(2.toString)
showRaw(res3.toString)
showRaw(res3.tree)
import scala.reflect.mirror._
reify{ val x = 2 }
showRaw(res0.tree)
def foo = { object Foo; Foo }
def foo = { object Foo { def x = 2 }; Foo }
:power
class A
class A { def bar = 10 }
import scala.reflect.mirror._
classToType(classOf[A])
res2.members
classTag[Int]
res4.erasure
res4.newArray(2)
classTag[Int with String]
typeTag[Int with String]
typeTag[List[Int]]
typeTag[List[_]]
def foo[T] = typeTag[T]
foo[Int]
res11.tpe
res11.tpe.typeSymbol
def foo[T: TypeTag] = typeTag[T]
foo[String]
foo[String](typeTag[String])
def foo[T: Manifest] = manifest[T]
foo[String]
def foo[T] = typeTag[T]
def foo[T] = manifest[T]
def foo[T] = typeTag[T]
def foo[T] = concreteTypeTag[T]
def foo[T] = concreteTypeTag[List[T]]
def foo[T: ConcreteTypeTag] = concreteTypeTag[List[T]]
def foo[T: ClassTag] = classTag[List[T]]
foo[Int]
def foo[T: ClassTag] = classTag[Array[T]]
foo[Int]
scala.reflect.mirror.reify(2)
res2.tpe
appliedType(definitions.ListClass.asType, List(definitions.IntClass.asType))
import scala.reflect.mirror._
appliedType(definitions.ListClass.asType, List(definitions.IntClass.asType))
import scala.reflect.mirror._
staticClass("Int")
staticClass("scala.Int")
import scala.reflect.mirror._
classToType(classOf[Int])
import Macros._
println("hello %s!")
printf("hello %s!")
exit
scala.reflect.mirror.reify(object Test {
  println("Hello World!")
}}
scala.reflect.mirror.reify{object Test {
  println("Hello World!")
}}
showRaw(res0)
scala.reflect.mirror(showRaw(res0))
scala.reflect.mirror.showRaw(res0)
scala.reflect.mirror.showRaw(res0.tree)
def foo(x: Int) =???
def foo(x: Int) = ???
foo("2")
scala.reflect.mirror.reify(2)
scala.reflect.mirror.reify("hello world")
scala.reflect.mirror.reify("hello " + "world")
scala.reflect.mirror.reify(2.toString)
def foo[T] = println(classOf[T])
def foo[T: TypeTag] = println(classOf[T])
def foo[T: ClassTag] = println(classOf[T])
def foo[T](x: T) = println(x.getClass)
foo({ object Bar; Bar })
def foo[T: TypeTag](x: T) = println(typeTag[T])
foo({ object Bar; Bar })
def foo[T](x: T) = println(x.getClass)
foo(List(1, 2, 3))
def foo[T: TypeTag](x: T) = println(typeTag[T])
foo(List(1, 2, 3))
def foo[T](x: T) = println(x.getClass)
val list = List(1, 2, 3)
foo(list)
val list = List(1, 2, 3).toList
foo(list)
def foo[T](x: T) = x.getClass
foo(list)
def foo[T: TypeTag](x: T) = typeTag[T]
foo(list)
def foo[T](x: T) = x.getClass
foo(List(1, 2, 3))
def foo[T: TypeTag](x: T) = typeTag[T]
foo(List(1, 2, 3))
res1.tpe
def ?=[T](my: T, oldnew: (T, T)) =???
def ?=[T](my: T, oldnew: (T, T)) = ???
import scala.reflect.mirror._
definitions.IntClass match { case TypeRef(pre, sym, args) => sym }
???
def foo = ???
type Foo[T] = ClassManifest[T]
implicitly[Foo[Int]]
1 -> 2
import math.Numeric.Implicits._
import Ordering.Implicits._
def plus[T](a: T, b: T)(implicit n: Numeric[T]) = a + b
classOf[Int]
classOf[Integer]
classTag[List[_]]
classManifest[List[_]]
classTag[Predef.ArrowAssoc[
]]
classTag[Predef.ArrowAssoc]
classTag[Predef.ArrowAssoc[_]]
classManifest[Predef.ArrowAssoc[_]]
import reflect.mirror._
typeToClass(tag[String].tpe)
typeToClass(tag[List[String]].tpe)
case class Artist(name: String)
typeToClass(tag[Artist].tpe)
tag[Artist].tpe
val m = classToType(classOf[Artist]).members.filter(!_.isMethod).head
val t = m.typeSignature
typeToClass(t)
 import reflect.mirror._
typeToClass(tag[String].tpe)
typeToClass(tag[List[String]].tpe)
case class Artist(name: String)
typeToClass(tag[Artist].tpe)
classTag[Int]
classTag[Array[Int]]
def tagme[T](x: T) = typeTag[T]
val foo = tagMe{object Bar; Bar}
val foo = tagme{object Bar; Bar}
foo.tpe
def tagme[T: TypeTag](x: T) = typeTag[T]
val foo = tagme{object Bar; Bar}
def tagme[T: TypeTag](x: T) = typeTag[T]
val foo = tagme{object Bar; Bar}
def tagme[T: TypeTag](x: T) = typeTag[T]
val foo = tagme{object Bar; Bar}
def tagme[T: TypeTag](x: T) = typeTag[T]
import scala.reflect.mirror._
reify { 1 match { case 0 => 0 } }
exit
typeTag[Int]
c;assTag[Int]
classTag[Int]
exit
typeTag[Int]
classTag[Int]
exit
typeTag[Int]
typeTag[List[Int]]
import scala.reflect.makro.Context
def impl(c: Context) = c.literalUnit
def foo = macro impl
foo
def foo[T] = typeTag[T]
typeTag[Int]
typeTag[List[Int]]
(1 -> 2).toMap
Map(1 -> 2)
Map(1 -> 2) map { case (k, v) => ??? }
2+2
exit
typeTag[Int]
exit
typeTag[Int]
exit
typeTag[Int]
exit
typeTag[Int]
exit
typeTag[Int]
exit
typeTag[Int]
Map(1->2)
res0.keys
res0.values
typeTag[List[Int]]
class C
trait T extends C
IntClass
lub(IntClass, StrinClass)
IntClass.tpe.lub(StringClass.tpe)
lub(List(IntClass.tpe, StringClass.tpe))
glb(List(IntClass.tpe, StringClass.tpe))
class D
trait X extends C with D
abstract class Foo(x: Int)
new { val foo = "" } with Foo(2)
type Base; object Base
class X { type Base; object Base }
class A { val a = 2; var b = 3 }
classToType(classOf[A]).tpe
import scala.reflect.mirror._
classToType(classOf[A]).tpe
classToType(classOf[A]).declarations
classToType(classOf[A]).declarations.toList
res2(1)
classToType(classOf[A]).declarations.filter(!_.isMethod).toList
res5(0).modifiers
res5(1).modifiers
class A { val a = 2; var b = 3 }
import scala.reflect.mirror._
classToType(classOf[A]).declarations.filter(!_.isMethod).toList
res8(0).modifiers
res8(1).modifiers
classTag[List[Int]]
res0.erasure
class Foo { val FooTag = classTag[Foo] }
new Foo().FooTag
new Foo().FooTag.erasure
class Foo { implicit val FooTag = classTag[Foo] }
new Foo().FooTag.erasure
val f : Int => Int = _ + 10
List(1,2,3).par.view.map(f).find(_ > 11)
val f : Int => Int = _ + 10
List(1,2,3).par.view.map(f).find(_ > 11)
exit
class X
class Y extends X
object Ambiguous {
  def f(x: X) = 1
  def f(ys: Y*) = 2
}
 Ambiguous.f(new X)
Ambiguous.f(new Y)
exit
type AI = Array[Int]
import scala.reflect.mirror._
reify{ val x: AI = null }
reify { val x: Array[Int] = null }
import scala.reflect.mirror._
reify{
def callme(x: Int): (Int, Int) = (1, 2)
val (one, two) = callme(10)
})
reify{
def callme(x: Int): (Int, Int) = (1, 2)
val (one, two) = callme(10)
}
reify{
def callme(x: Int): (Int, Int) = { println("a"); (1, 2) }
val (one, two) = callme(10)
}
def callme(x: Int): (Int, Int) = { println("a"); (1, 2) }
reify{
val (one, two) = { println("stuff"); callme(10); }
}
type q = List[=> Int]
typeTag[Int]
exit
typeTag[Int]
type B
;
type A = Int
type B = String
class Q { type C <: A <: B }
class Q { type C <: A, B }
trait A
trait A { def a = 100 }
trait B { def b = 200 }
abstract class C { type D <: A with B; def foo(d: D) = println(s"${d.a} ${d.b}") }
class E extends A with B
class F extends C { type D = E }
new F().foo(new F())
new F().foo(new E())
cas
case class C
case class X(x: Int)
case class X(x: Int, y: Int)
def Apply(x: Int) = ???
case class Apply(s: String)
val Apply(foo) = Apply("bar")
def Apply(x: Int) = ???
class ApplyExtractor {
class Apply
def Apply(x: Int) = ???
class ApplyExtractor {
def apply(x: Int) = new Apply
def unapply(apply: Apply): Option[Int] = Some(42)
}
val Apply: ApplyExtractor = new ApplyExtractor
val Apply(x) = new Apply
case class TypeTree()
case class Blah()
typeTag[Int]
typeTag[List[Int]]
exit
typeTag[List[String]]
typeTag[List[Int]]
typetag[Int]
typeTag[Int]
typeTag[List[Int]]
exit
typeTag[Int]
typeTag[List[Int]]
exit
def foo
= ???
class C
classOf[C].getName
object D { class C }
classOf[D.C].getName
classOf[scala.tools.nsc.io.File].getName
class C
new {} with C
new { self: C => } with C
2 + 2
2121
2 + 2
val a = 2
class C
val c = new C
import a._, c._
Nil drop 1
object c { object f }
object d
import d._, c._, f._
object c { object f { def foo = "" } }
import d._, c._, f._
foo
trait C { type Q <: AnyRef }
trait C { type Q <: AnyRef; var q: Q = null }
import scala.reflect.base.Universe
:type -v def foo[T](tt: scala.reflect.base.Universe # TypeTag[T]) = ???
:type -v def foo[T](tt: scala.reflect.api.Universe # TypeTag[T]) = ???
scala.reflect.mirror
val ru = scala.reflect.miror
val ru = scala.reflect.mirror
def impl(c: scala.reflect.makro.Context)(x: c.Expr[String]): c.Expr[String] = ???
import scala.reflect.mirror._
typeTag[List[Int]]
implicitly[manifest[List[Int]]
\
]
implicitly[manifest[List[Int]]]
implicitly[Manifest[List[Int]]]
implicitly[Manifest[
\\
]]]]
implicitly[Manifest[List[Int]]
]
implicitly[Manifest[List[String]]]
reify{ val x = 2 + 2 }
val x = 2
reify { val y = x + 2 }
{ val x = 2; reify { val y = x + 2 } }
import scala.reflect.mirror._
{ val x = 2; reify { val y = x + 2 } }
val x = 2
scala.reflect.Code.lift{val y = x + 2}
res0.tree
{ val x = 2; scala.reflect.Code.lift{val y = x + 2} }
res2.tree
exit
{ val x = 2; scala.reflect.Code.lift{val y = x + 2} }
exit
{ val x = 2; scala.reflect.Code.lift{val y = x + 2} }
exit
type L = List[_ <: Any]
type L = List[T] forSome { type T <: Any }
type S = Set[T] forSome { type T <: Any }
def foo(s: collection.mutable.Set[T] forSome { type T <: Any }) = ???
def foo(s: collection.mutable.Set[T forSome { type T <: Any }]) = ???
foo(Set(1, 2, 3))
foo(collection.mutable.Set(1, 2, 3))
2 + 2
exit
class Foo { override def toString = "foo" }
case class Bar() extends Foo
Bar()
def T1 { println("hello 1") }
def T2 { println("hello 2") }
class C extends T1 with T2
trait T2 { println("hello 2") }
trait T1 { println("hello 1") }
class C extends T1 with T2
new C
class C extends T2 with T1
new C
:power
definitions.ListClass
appliedType(definitions.ListClass.asType, List(definitions.IntClass.asType))
appliedType(definitions.SeqClass.asType, List(definitions.IntClass.asType))
res1 <:< res2
definitions.IntClass.asType <:< definitions.LongClass.asType
definitions.LongClass.asType <:< definitions.IntClass.asType
case class LitInt(i: Int)
val map = collection.mutable.Map[Int, Int]()
map += 1 -> 2
"%d".format(null)
"foo%dbar".format(null)
"%d".format(2.0)
val c: Int with Character = 'a'
def foo[T](x: Int) = x
def foo[T, U](x: Int) = x
foo(1)
def foo[T, U](x: Int) = x + 1
foo(1)
class C(x = 2)
:type -v def foo(x: => Int) = ???
:type -v => Int
def foo(implicit x: Int) = x; def foo(y: Int)(implicit x: Int) = x + y
implicit val x = 2
foo
def foo(y: Int)(implicit x: Int) = x + y
foo
def foo(y: Int = 0)(implicit x: Int) = x + y
foo
foo()
import scala.reflect.mirror
def typeOf[T: ConcreteTypeTag] = implicitly[ConcreteTypeTag[T]]
typeOf[Int]
def typeOf[T: ConcreteTypeTag](x: T = null.asInstanceOf[T]) = implicitly[ConcreteTypeTag[T]]
typeOf[Int]
collection.mutable.ArrayBuffer[Int](1, 2)
collection.mutable.ArrayBuffer[Int](List(1, 2))
collection.mutable.ArrayBuffer[Int](List(1, 2): _*)
case class C(var x: Int = 2)
C()
C().copy
C().copy()
import scala.reflect.mirror._
staticClass("scala.Nothing")
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
exit
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
exit
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
exit
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
exit
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
exit
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
exit
scala.reflect.runtime.currentMirror.staticClass("scala.Nothing")
scala.reflect.runtime.currentMirror
res1.staticClass("scala.Nothing")
scala.reflect.runtime.universe.rootMirror.staticClass("scala.Nothing")
scala.reflect.runtime.universe.rootMirror.staticModule("scala.Nothing")
scala.reflect.runtime.universe.rootMirror.staticModule("scala")
scala.reflect.runtime.universe.rootMirror.staticModule("scala").moduleClass.asTypeSymbol.asType.typeSignature
scala.reflect.runtime.universe.rootMirror.staticModule("scala").moduleClass.asTypeSymbol.asType.members.toList
scala.reflect.runtime.universe.currentMirror.staticModule("scala")
scala.reflect.runtime.currentMirror.staticModule("scala")
res9.staticModule("scala").moduleClass.asTypeSymbol.asType.members.toList
res9.moduleClass.asTypeSymbol.asType.members.toList
exit
cm
exit
root
rootMirror.staticClass("scala.Nothing")
cm.staticClass("scala.Nothing")
rootMirror.EmptyPackageClass.asTypeSymbol.asTypeConstructor
rootMirror.EmptyPackageClass.asTypeSymbol.asTypeConstructor.typeSignature
rootMirror.EmptyPackageClass.typeSignature
rootMirror.EmptyPackage.typeSignature
rootMirror.EmptyPackageClass.initialize.typeSignature
rootMirror.EmptyPackageClass.asInstanceOf[scala.reflect.internal.Symbol].initialize
rootMirror.EmptyPackageClass.asInstanceOf[scala.reflect.internal.Symbols#Symbol].initialize
rootMirror.EmptyPackageClass.typeSignature
rootMirror.RootClass.typeSignature
rootMirror.RootClass.typeSignature.member(newTermName("scala"))
rootMirror.RootClass.typeSignature.member(newTermName("scala")).typeSignature
rootMirror.RootClass.typeSignature.member(newTermName("scala")).moduleClass.typeSignature
rootMirror.RootClass.typeSignature.member(newTermName("scala")).asModuleSymbol.moduleClass.typeSignature
rootMirror.RootClass.typeSignature.member(newTermName("scala")).asModuleSymbol.moduleClass.typeSignature.member(newTermName("Nothing"))
rootMirror.RootClass.typeSignature.member(newTermName("scala")).asModuleSymbol.moduleClass.typeSignature.member(newTermName("scala.Nothing"))
2
exit
2
exit
2
exit
exit\
2
22
exit
2
exit
2
cm.staticClass("scala.Nothing")
definitions.ScalaPackageClass
cm.staticModule("scala").moduleClass
cm.staticModule("scala").companionSymbol
cm.staticModule("scala").moduleClass
exit
definScalaPackage
definitions.ScalaPackage
cm.staticModule("scala")
rm.staticModule("scala")
val m = ru.runtimeMirror(null)
rb
ru
val ru = scala.reflect.runtime.universe
val m = ru.runtimeMirror(null)
rm
exit
rm
cm
ru.runtimeMirror(null)
exit
cm
rm
runtimeMirror(null)
runtimeMirror(null).staticClass("scala")
cm.classLoader
cm.classLoader.parent
cm.classLoader.getParent
scala.reflect.runtime.show(cm.classLoader.getParent)
scala.reflect.runtime.ReflectionUtil.show(cm.classLoader.getParent)
scala.reflect.runtime.ReflectionUtils.show(cm.classLoader.getParent)
rm
rm.classLoader.loadClass("scala.package")
res6.loadClass("scala.package")
exit
rm
cm
exit
show(cm.classLo
d
)
show(cm.classLoader)
exit
show(cm.classLoader)
println show(cm.classLoader)
println(show(cm.classLoader))
exit
ScalaPackageClass
rm.staticClass("scala")
rm.staticPackage("scala").moduleClass
rm.staticModule("scala").moduleClass
ScalaPackage
rm.staticModule("scala")
cm.staticModule("scala")
RootPackage
exit
rm
exit
rm // aka scala.reflect.runtime.universe.rootMirror
cm // aka scala.reflect.runtime.currentMirror
ScalaPackage
rm.staticModule("scala")
cm.staticModule("scala")
exit
cm
exit
cm
2
exit
cm
exit
rm.staticClass("scala.Any")
AnyClass
rm.staticClass("scala.AnyRef")
rm.staticClass("scala.AnyVal")
AnyValClass
cm.staticClass("scala.Any")
cm.staticClass("scala.AnyVal")
cm.staticClass("scala.Int")
rm.staticClass("scala.Int")
IntClass
exit
reify { def foo[T <: String with Singleton] = ??? }
exit
import scala.reflect.mirror._
reify{ def foo[T <: String with Singleton] = ??? }
reify{ def foo[T <: String] = ??? }
reify { abstract class C extends Seq[Int] with TraversableOnce[Int] }
exit
typeOf[{ def x: Int }]
exit
def foo[T] = classOf[T]
def foo[T] = classOf[List[T]]
foo[Int]
def foo[T] = classOf[Array[T]]
foo[Int]
def foo[T] = classOf[Array[Array[T]]]
foo
def foo[T] = classOf[Array[Int]]
foo
def foo[T] = classOf[Array[T]]
foo
foo == classOf[Object]
exit
cm
exit
import scala.reflect.mirror._
implicitly[TypeTag[List[Int]]
]
implicitly[TypeTag[List[Int]]]
implicitly[TypeTag[List[Int]]].tpe
typeOf[List[Int]]
{
  import scala.reflect.runtime.universe._
  val x = "2"
  val tt = implicitly[TypeTag[x.type]]
  println(tt)
}
val x = "2"
typeOf[x.type]
{
val y = "2"
typeOf[y.type]
}
exit
{
  import scala.reflect.runtime.universe._
  val x = "2"
  val tt = implicitly[TypeTag[x.type]]
  println(tt)
}
parse this
parse
exit
{
  import scala.reflect.runtime.universe._
  val x = "2"
  val tt = implicitly[TypeTag[x.type]]
  println(tt)
}
exit
classOf[Array[_ <: Object]]
classTag[Array[_ <: Object]]
def foo[T <: Object] = classTag[Array[T]]
def foo[T <: Object] = classOf[Array[T]]
foo
:type scala.reflect.mirror.Type
:type -v scala.reflect.mirror
:type -v scala.reflect.Code
:type -v scala.reflect.ScalaSignature
val List(1, 2, _*) = List(1, 2, 3, 4)
val List(1, 2, _) = List(1, 2, 3, 4)
val List(1, 2) = List(1, 2, 3, 4)
val List(x, y) = List(1, 2, 3, 4)
val List(1, 2) = List(1, 2, 3, 4)
val List(1) = List(1)
cm
cm.staticClass("Nothing")
cm.staticClass("scala.Nothing")
exit
class C {
type T
implicit val tag: ClassT
}
class C {
type T[U]
implicit val tag: ClassTag[T]
}
cm
cm.staticClass("scala.Nothing")
cm.staticClass("java.lang.String")
exit
class C { s"$this" }
class C { s"$yield" }
case clas
class foo extends StaticAnnotation
class foo extends annotation.StaticAnnotation
case class C(@foo x: Int)
case class C(x: Int)
cm.reflectClass(classOf[C])
res0.asTypeSymbol.asTypeConstructor
res0.symbol.asTypeSymbol.asTypeConstructor
res2.member(nme.CONSTRUCTOR)
val MethodType(params, _) = res3.typeSignature
params.map(_.typeSignature)
List(1, 2, 3) map (x => new { i = x })
List(1, 2, 3) map (x => new { val i = x })
res1(0).i
List(1, 2, 3) map (x => new { val i = x })
res1(0).i
res0(0).i
reify(new { val a = 1; val b = 2 })
val c: scala.reflect.makro.Context = null
:type c.universe
:type c.mirror
:type c.mirror.type
:type -v c.mirror
def q: c.mirror.type = ???
:type -v q
def q(x: Int): c.mirror.type = ???
:type -v q
:type -v def q: c.mirror.type = ???
"2".asInstanceOf[type { def toString: String }]
"2".asInstanceOf[{ def toString: String }]
"2".asInstanceOf[{ def toString: String }].toString
def foo = foo
classTag[Int]
scala.reflect.classTag[Int]
exit
scala.reflect.classTag[Int]
ru.typeOf[Int]
ru.typeOf[List[Int]]
exit
typeTag[List[Int]]
typeOf[List[Int]]
exit
typeTag[Int]
exit
typeTag[Int]
typeTag[List[Int]]
reify
typeTag
exit
classTag[Int]
typeTag[List[Int]]
exit
scala.reflect.runtime.currentMirror
scala.reflect.runtime.universe
scala.reflect.mirror
exit
class A {
 var x: Int = 42
}

val a = new A
val im: InstanceMirror = cm.reflect(a)
val cs = im.reflectClass.symbol
val f = cs.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f)
fm.field.isVariable
class A {
 var x: Int = 42
}

val a = new A

val im: InstanceMirror = cm.reflect(a)
val cs = im.reflectClass.symbol
val f = cs.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f)
fm.field.isVariable
reify { class A { var x = 42 } }
class A {
 var x: Int = 42
}

val a = new A

val im: InstanceMirror = cm.reflect(a)
val cs = im.reflectClass.symbol
val f = cs.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f)
fm.field.isVariable
"%x".format(22222)
"%x8".format(22222)
"%x:8".format(22222)
"%08x".format(22222)
"%%d".format(42)
def f: Function0[Int] = ???
def foo[T: TypeTag] = Array[T]()
def foo[T: ClassTag] = Array[T]()
reify(2)
exit
typeOf[List[Int]]
typeof[List[Int]]
typeOf[List[Int]]
m { val x = 1; x }
import scala.reflect.makro._
object Fun { def fun[A: c.TypeTag](c: Context)(x: c.Expr[A]) = c.reify( () => x.eval ) }
object Fun { def fun[A: c.TypeTag](c: Context)(x: c.Expr[A]) = c.reify( () => x.splice
)}
def m[A](x: A) = macro Fun.fun[A]
m(1)
m { val x = 1; 2 }
m { val x = 1; x }
scala.Nil
List(1, 2, 3).foldRight(0)(_ + _)
List(1, 2, 3).foldRight(0)((x, y) => { println(x); x + y })
{ val x = 2; reify(x) }
object Foo { val x = 2 }
import Foo._
reify(x)
exit
:type -v def foo = ???
:type def foo = ???
:type -v def foo = ???
:type def foo = ???
:type -v def foo = ???
List(1, 2, 3).productIterator
List(1, 2, 3).productIterator.toList
class Foo { def bar(x: Int) = x }
import scala.reflect.runtime.universe._ // requires scala-reflect.jar
val foo = new Foo
runtimeMirror(getClass.getClassLoader).reflect(foo)
res0.declaration(newTermName("foo"))
res0.symbol.typeSignature.declaration(newTermName("foo"))
res0.symbol.typeSignature.declarations()
res0.symbol.typeSignature.declarations
class Foo { def bar(x: Int) = x }
val foo = new Foo
runtimeMirror(getClass.getClassLoader).reflect(foo)
res0.symbol.typeSignature.declaration(newTermName("bar"))
res0.reflectMethod(res1.asMethodSymbol)(42)
class C { class D }
:type -v def foo(x: C#D) = ???
:type -v x: C#D = ???
:type -v def x: C#D = ???
showRaw(typeOf[scala.Product])
showRaw(typeOf[scala.Function1[_, _]))
showRaw(typeOf[scala.Function1[_, _])
showRaw(typeOf[scala.Function1[_, _]])
val tb = m.mkToolBox() 
val tb = cm.mkToolBox() 
tb.parseExpr("def x = {}")
tb.parseExpr("def x = {") 
tb.parseExpr("def x = {}")
trait ThirdParty { def invoke = println("right") }
trait WeatherIcon { def invoke = println("wrong") }
class MyClass {
    object objA extends ThirdParty
    object objB extends WeatherIcon
}
val stuff = typeOf[MyClass].members.filter(_.isValue).filter(_.typeSignature <:< typeOf[ThirdParty])
val objASymbol = stuff.head.asModuleSymbol
cm.reflect(new MyClass).reflectModule(objASymbol)
res0.companion
res0.instance
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
exit
reify(new { trait Inner; def m(): Inner = null })
def foo[T: TypeTag](x: T) = ()
foo(new { trait Inner; def m(): Inner = null })
0 to 64
2048 & (1L << 11) == (1L << 11)
(2048 & 1L << 11) == (1L << 11)
(2048 & (1L << 11)) == (1L << 11)
for (i <- 0 to 63 if i % 2 == 0) { print(i) }
"as".toUpper
"as".toUpperCase
class B { def foo(a: A) = 1 }
val im = cm.reflect(new B)
 im.symbol.asType.nonPrivateMember(u.newTermName("foo")).asMethodSymbol
 im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(res1)
res0(new A)
im(new A)
res2(new A)
typeOf[A]
res0.dealias
res0.normalize
type B = A
typeOf[B}
typeOf[B]
staticClass(classOf[B].getName)
cm.staticClass(classOf[B].getName)
classOf[B].getName
classOf[A].getName
cm.staticClass("B")
object C { type B = A }
typeOf[C.type]
typeOf[C.type].typeSignature.member(newTypeName("B")
)
typeOf[C.type].member(newTypeName("B")
)
res11.isAlias
res11.isAliasType
typeOf[C.B]
type B = A
object D { type C = B }
exit
cm.asInstanceOf[{def getModuleOrClass(path: Name, len: Int): Symbol}]
exit
typeOf[Int]
showRaw(res0)
res1.typeSymbol.typeSignature
res0.typeSymbol.typeSignature
mirrorThatLoaded
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
showRaw(t1)
showRaw(t2)
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}

import scala.reflect.runtime.universe._
import scala.reflect.runtime.{ currentMirror => cm }
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
val TypeRef(pre1, _, _) = t1
val TypeRef(pre2, _, _) = t2
pre1.typeSymbol
pre2.typeSymbol
ru
ru.asInstanceOf[{def mirrorThatLoaded(sym: Symbol): Mirror}
]
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}

import scala.reflect.runtime.universe._
import scala.reflect.runtime.{ currentMirror => cm }
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}

import scala.reflect.runtime.universe._
import scala.reflect.runtime.{ currentMirror => cm }
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
mirrorThatLoaded(t1)
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}

import scala.reflect.runtime.universe._
import scala.reflect.runtime.{ currentMirror => cm }
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
mirrorThatLoaded(t1)
val TypeRef(pre1, _, _) = t1
val TypeRef(pre2, _, _) = t2
mirrorThatLoaded(pre1)
mirrorThatLoaded(pre1.typeSymbol)
mirrorThatLoaded(pre2.typeSymbol)
classManifest[Int]
showRaw(typeOf[Int])
showRaw(reify(2 + 2).tree)
showRaw(reify(2 + 2).tree, printTypes = true)
" " * 2
exit
class ManifestTester {
  private final def toJavaMap[T, V](map: Map[T, V])(implicit m1: Manifest[T], m2: Manifest[V]): java.util.Map[_, _] = {
    map match {
      case m0: Map[Int, Int] => new java.util.HashMap[Integer, Integer]
      case m1: Map[Int, V] => new java.util.HashMap[Integer, V]
      case m2: Map[T, Int] => new java.util.HashMap[T, Integer]
      case _ => new java.util.HashMap[T, V]
    }
  }
}
val x: Manifest[Int] = null
def foo[T: Manifest] = ???
def foo[T: ClassManifest] = ???
def foo[T: Manifest] = ???
exit
def foo[T: Manifest] = ???
def foo[T: ClassManifest] = ???
def foo[T](implicit x: ClassManifest[T]) = ???
exit
def foo[T: ClassManifest] = ???
def foo[T](implicit x: ClassManifest[T]) = ???
def foo[T](implicit x: scala.reflect.ClassManifest[T]) = ???
def bar[T] = foo[T]
val x: ClassManifest[Int] = null
val y: ClassTag[Int] = null
x = y
var y: ClassTag[Int] = null
var x: ClassManifest[Int] = null
x = y
y = x
exit
@deprecated("foo", "2.10.0") def foo = ???
@deprecated("foo", "2.10.0") type T = Int
val x: T = 2
exit
typeOf[Int].member("$plus").asTermSymbol.resolveOverloaded(actuals = List(typeOf[Int]))
typeOf[Int].member(newTermName("$plus")).asTermSymbol.resolveOverloaded(actuals = List(typeOf[Int]))
exit
typeTag[(Int*) => Unit]
trait T
implicit val tag = typeTag[T]
implicit val tag = typeTag[String].asInstanceOf[TypeTag[T]]
println(tag.tpe)
val tree = reify { Nil : List[T] }.tree
trait T
implicit val tag = typeTag[String].asInstanceOf[TypeTag[T]]
val tree = reify { Nil : List[T] }.tree
class Foo { def bar(x: Int) = 2 }
new Foo().bar("
new Foo().bar("x")
implicit class Bar(x: Foo) { def bar(x: String) = 3 }
new Foo().bar("x")
ca
case class Foo()
trait X { def foo: Unit }
object Bar { def m(c: Context) = ??? }
import scala.reflect.makro.Context
object Bar { def m(c: Context) = ??? }
class C extends X { def foo = macro m }
class C extends X { def foo = macro Bar.m }
mirrorThatLoaded(typeOf[Int].typeSymbol)
showRaw(atype)
showRaw(atype2)
showRaw(atype, printIds = true)
showRaw(atype)
showRaw(atype, printIds = true)
showRaw(atype, printIds = true, printMirrors = true)
showRaw(atype2, printIds = true, printMirrors = true)
showRaw(atype, printIds = true, printMirrors = true)
typeOf[F].parents contains atype
typeOf[F].parents contains atype2
showRaw(atype)
showRaw(atype, printIds = true, printMirrors = true)
showRaw(atype2, printIds = true, printMirrors = true)
typeOf[F].parents
showRaw(typeOf[F].parents(1), printIds = true, printMirrors = true)
atype == atype2
atype2
typeOf[F].parents(1)
atype2 != res1
trait A[X]
trait B[Y] extends A[Y]
trait D
trait E extends A[D]
trait F extends A[String]
val atype = typeOf[A[String]]
val atype2 = typeOf[F].parents(1)
atype == atype2
class C { def foo(x: Int)(y: Int) = x + y }
object C { def foo(x: Int)(y: Int) = x + y }
cm.reflectModule("C")
class C { def foo(x: Int)(y: Int) = x + y }
cm.reflect(new C)
res1.reflectMethod(res1.symbol.member(newTermName("foo)))
res1.reflectMethod(res1.symbol.member(newTermName("foo:)))
res1.reflectMethod(res1.symbol.member(newTermName("foo")))
res1.reflectMethod(res1.symbol.typeSignature.member(newTermName("foo")))
res1.reflectMethod(res1.symbol.asTypeSymbol.typeSignature.member(newTermName("foo")))
res1.reflectMethod(res1.symbol.typeSignature.member(newTermName("foo")).asMethodSymbol)
res5(1, 2)
classOf[String]
ClassTag.String
classTag[String]
scala.reflect.classTag[String]
ClassTag.String
scala.reflect.ClassTag.String
exit
"""#\d+""".r.replaceAllIn("a#12121, b#3232", "<id>")
showRaw(reify(2), printTypes = true, printMirrors = true)
showRaw(reify(2).tree, printTypes = true, printMirrors = true)
showRaw(reify(2).tree, printTypes = true)
  val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
  val tree1 = reify(new collection.immutable.HashMap[String, String])
  val tree2 = reify(new collection.mutable.HashMap[String, String])
tb.typeCheck(tree1.tree)
showRaw(res3, printTypes = true, printMirrors = true)
  val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
  val tree1 = reify(new collection.immutable.HashMap[String, String])
  val tree2 = reify(new collection.mutable.HashMap[String, String])
tb.typeCheck(tree1.tree)
showRaw(res0, printTypes = true, printMirrors = true)
def foo[T <: Int] = reify(List[T]())
def foo[T] = reify(List[T]())
class Foo {
type T
reify(List[T]())
}
class Foo {
type T = Int
reify(List[T]())
}
class Foo {
type T = Int
def mkT: T = 0
reify(List[T](mkT, mkT))
}
type FootnoteIndex = collection.mutable.Map[Class, collection.mutable.WeakHashMap[Any, Int]]
type FootnoteIndex = collection.mutable.Map[Class[_], collection.mutable.WeakHashMap[Any, Int]]
new FootnoteIndex()
FootnoteIndex()
val s = TreeSet[Int]()
val s = collection.mutable.TreeSet[Int]()
s += 1
s += 5
s += 2
s
collection.mutable.WeakHashMap[Any, Int]()
collection.mutable.TreeSet(1, 5, 2)
collection.mutable.TreeSet(1, 5, 2).map(i => (i, i))
collection.mutable.SortedSet(1, 5, 2).map(i => (i, i))
collection.mutable.SortedSet(1, 5, 2).map(i => (i, i.toString))
collection.mutable.SortedSet(1, 5, 2).map(i => (i, new Object))
showRaw(typeOf[Int])
showRaw(typeOf[List[Int]], printIds = true, printMirrors = true)
Map[Class[_], SortedSet[Int]]() withDefault (key => SortedSet[Int]())
import scala.collection.mutable.{Map, WeakHashMap, SortedSet}
Map[Class[_], SortedSet[Int]]() withDefault (key => SortedSet[Int]())
res2(typeOf[Int]) += 1
res2(typeOf[Int])
res0(typeOf[Int])
res0(scala.reflect.runtime.universe.typeOf[Int])
res0(classOf[Int]) += 1
res0(classOf[Int])
showRaw(typeOf[Int])
showRaw(typeOf[List[Int]], printIds = true, printMirrors = true)
classOf[Object].getSuperClass
classOf[Object].getSuperclass
showRaw(typeOf[List[Int]], printIds = true, printMirrors = true)
showRaw(typeOf[List[Int]], printIds = true)
showRaw(typeOf[List[Int]])
show(typeOf[List[Int]])
typeOf[{def foo(x: Int): Int}]
typeOf[String]
exit
staticModule("java.lang")
cm.staticModule("java.lang")
res1.typeSignature
res2.members
res2.moduleClass.typeSignature
res1.moduleClass.typeSignature
res1.moduleClass.typeSignature.members
res1.moduleClass
IntTpe
JavaLangPackage
JavaLangPackage.parent
JavaLangPackage.owner
typeOf[{def foo(x: Int): Int}]
typeOf[Nothing]
typeOf[Null]
typeOf[scala.Null]
typeOf[Any]
typeOf[List[Any]]
typeOf[{def foo(x: Int): Int}]
cm.selectType(ScalaPackage, "AnyRef")
build.selectType(ScalaPackage, "AnyRef")
typeOf[{def foo(x: Int): Int}]
typeOf[(Int*) => Unit]
typeOf[(=> Int) => Unit]
typeOf[String].members(0)
typeOf[String].members.toList(0)
res0.typeSignature
val MethodType(params, ret) = res0.typeSignature
class Foo; object Foo
typeOf[Foo]
res1.typeSymbol
res0.typeSymbol
res0.typeSymbol.companionSymbol
showRaw(res0, printKinds = true)
class Foo

object Foo
typeOf[Foo.type]
showRaw(res0, printKinds = true)
res0.typeSymbol.companionSymbol
res0.typeSymbol
res0.typeSymbol.kinds
res0.typeSymbol.kind
res0.typeSymbol.companionSymbol.kind
res0.typeSymbol.companionSymbol.getClass
res0.typeSymbol.getClass
res0.typeSymbol.isModule
typeOf[Foo]
class Foo; object Foo
typeOf[Foo.type].typeSymbol
typeOf[Foo.type].typeSymbol.getClass
typeOf[Foo.type].typeSymbol.typeSignature
typeOf[Foo.type].typeSymbol.typeSignature.selfType
typeOf[Foo.type].typeSymbol.selfType
typeOf[Foo.type].typeSymbol.asClassSymbol
typeOf[Foo.type].typeSymbol.asClassSymbol.selfType
typeOf[Foo.type].typeSymbol.asClassSymbol.selfType.termSymbol
typeOf[Foo.type].typeSymbol.asClassSymbol.selfType.asInstanceOf[scala.tools.nsc.Global#Type].termSymbol
typeOf[{def foo(x: Int): Int}]
cm.selectType(ScalaModule.moduleClass, "AnyRef")
build.selectType(ScalaModule.moduleClass, "AnyRef")
build.selectType(staticModule("scala").moduleClass, "AnyRef")
build.selectType(cm.staticModule("scala").moduleClass, "AnyRef")
typeOf[{def foo(x: Int): Int}]
 def f1 = classManifest[Predef.ArrowAssoc[_]]
class A; class B { def foo(x: A) = 1 }
cval im = cm.reflect(new B)
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)
res0(new A)
exit
exity
exit
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
im.reflectMethod(method)
class A; class B { def foo(x: A) = 1 }; val im = cm.reflect(new B); val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol; im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val cm = reflect.runtime.currentMirror
val cm = scala.reflect.runtime.currentMirror
val u = cm.universe
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(u.newTermName("foo")).asMethodSymbol
im.reflectMethod(method)
 res0(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(u.newTermName("foo")).asMethodSymbol
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)
 res0(new A)
class A; class B { def foo(x: A) = 1 }; val im = cm.reflect(new B); val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol; im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
println(classOf[A].getName)
println(classOf[B].getName)
class A
class B { def foo(x: A) = 1 }
val cm = reflect.runtime.currentMirror
val u = cm.universe
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(u.newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
exit
class A;classB
class A;class B
class A; class B
class A
class A; class B
t1
t2
showRaw(t1)
showRaw(t2)
t1 == t2
showRaw(typeOf[scala.Int])
showRaw(typeOf[scala.Int], printMirrors = true)
showRaw(scala.Int)
showRaw(typeOf[scala.Int])
showRaw(typeOf[scala.Int], printMirrors = true)
showRaw(cm.typeOf[scala.Int], printMirrors = true)
exit
showRaw(typeOf[scala.Int], printMirrors = true)
typeOf[GenTraversable[_]]
typeOf[scala.collection.GenTraversable[_]]
scala.tools.reflect.mkConsoleFrontEnd()
reify { trait Foo { val a: Int } }
c{
}
class X { def foo(x: Int) = ??? }; val MethodType(_, t1) = typeOf[X].declaration(newTermName("foo")); val t2 = typeOf[scala.Int]
class X { def foo(x: Int) = ??? }; val MethodType(_, t1) = typeOf[X].declaration(newTermName("foo")).typeSignature; val t2 = typeOf[scala.Int]
class X { def foo(x: Int): Int = ??? }; val MethodType(_, t1) = typeOf[X].declaration(newTermName("foo")).typeSignature; val t2 = typeOf[scala.Int]
t1 == t2
t1 =:= t2
t1 == t2
2
t1 == t2
case class TypeRef(pre: Type, sym: Symbol, args: List[Type])
t1 == t2
class A
val a = new A
val b = new A
case class A
:type -v def foo: Int
:type -v def foo: Int = ???
class A { def foo(x: Int*) = 1 }
typeOf[A] member newTermName("foo") typeSignature
res0.asInstanceOf[u.MethodType].params.head
res0.asInstanceOf[MethodType].params.head
res1.typeSignature
res2.typeSignature
class A { def foo(x: Int*) = 1 }
typeOf[A] member newTermName("foo") typeSignature
res0.asInstanceOf[MethodType].params.head
res1.typeSignature
x.typeSignature
 typeOf[(Any, Any)]
typeOf[(Int, Int)].erasure =:= typeOf[(Any, Any)]
 typeOf[Map[_, _]]
def impl(c: Context) = { println(c.typeOf[Map[_, _]]); c.literalUnit }
def foo = macro impl
foo
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
typeOf[(Int, Int)]
showRaw(res0)
reify(2)
sealed trait LaunchExp extends LazyExp[LaunchExp] with BaseExp { 
   type OpSemExp = LaunchExp 
   type Val = Lam
}
class BaseExp
class LazyExp[T]
sealed trait LaunchExpr extends LazyExp[LaunchExp] with BaseExp {
type OpSemExp = LaunchExp
type Val = Lam
}
sealed trait LaunchExp extends LazyExp[LaunchExp] with BaseExp {
type OpSemExp = LaunchExp
type Val = Lam
}
class BaseExp
class LazyExp[T] { type Lam }
sealed trait LaunchExp extends LazyExp[LaunchExp] with BaseExp {
type OpSemExp = LaunchExp
type Val = Lam
}
trait BaseExp
class LazyExp[T] { type Lam }
sealed trait LaunchExp extends LazyExp[LaunchExp] with BaseExp {
type OpSemExp = LaunchExp
type Val = Lam
}
class BaseLam[T](a: Any, b: Any)
class Idn
case class Lam(override val x: Idn, override val e: LaunchExp) 
   extends BaseLam[LaunchExp](x, e) with LaunchExp
typeOf[List[Int]] <:< typeOf[List[Any]]
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
do 2 with 3
foo 2 bar 3
reify(reify(2))
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class A; def foo = 2
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A { def x = 2 }
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
exit
class A; class B
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
trait ThirdParty { def invoke = println("right") }
trait WeatherIcon { def invoke = println("wrong") }
class MyClass {
    object objA extends ThirdParty
    object objB extends WeatherIcon
}
val stuff = typeOf[MyClass].members.filter(_.isValue).filter(_.typeSignature <:< typeOf[ThirdParty])
val objASymbol = stuff.head.asModuleSymbol
cm.reflect(new MyClass).reflectModule(objASymbol)
res0.companion
res0.instance
class A {
  var x: Int = 42
}

val a = new A

val im: InstanceMirror = cm.reflect(a)
val cs = im.reflectClass.symbol
val f = cs.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f) 
fm.field.isVariable
class A {
  var x: Int = 42
}
val a = new A
val im: InstanceMirror = cm.reflect(a)
val f = im.symbol.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f) 
fm.field.isVariable
fm.symbol.isVariable
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
exit
def impl(c: Context) = {
def cc: c.type with scala.reflect.makro.Context = ???
}
def impl(c: Context) = {
val cc: c.type with scala.reflect.makro.Context = c
}
3 + 4
class World { def update(x: Int, v: Int): World = new World }
var w = new World
w(1) = 2
var w = new World
class World { def update(x: Int, v: Int): World = new World }
var w = new World
w(1) = 2
w
var x = List(1, 2)
x(0) = 3
List(1, 2).iterator
res0.mkString
exit
List(1, 2, 3).max
List(1, 2, 3).max(i => i * 2)
"lost".capitalize
exit
1.compare(2)
exit
val xs = SortedSet(3, 2, 5, 6, 1)
val xs = TreeSet(3, 2, 5, 6, 1)
val xs = collection.immutable.SortedSet(3, 2, 5, 6, 1)
xs take 3
import scala.reflect.runtime.universe._
List(List(), (1,2))
def x[T : TypeTag](t: T) = typeOf[T]
x(List(List(), (1,2)))
showRaw(res1)
 x(List(List(), (1,2)).head)
showRaw(res3)
typeOf[Product]
showRaw(res5)
exit
val rng = new scala.util.Random(42)
rng.nextInt(100)
import collection.immutable.SortedSet
SortedSet(10, 2) ++ SortedSet(5, 3)
SortedSet(10, 2) ++ SortedSet(5, 3) take 1
SortedSet(10, 2) ++ (SortedSet(5, 3) take 1)
collection.immutable.SortedSet(1, 2, 3, 2)
1.0.toInt
typeOf[X]
isDifferent(instance, instance)
Experiment.isDifferent(instance, instance)
exit
typeOf[X]
case class X(s: String)
typeOf[X].members
typeTag[scala.Predef.ArrowAssoc[_]]
classTag[scala.Predef.ArrowAssoc[String]]
classManifest[scala.Predef.ArrowAssoc[String]]
classManifest[List[_]]
classManifest[List[Int]]
classManifest[List[_]]
staticClass("scala.List"
)
cm.staticClass("scala.List")
res0.fullName
cm.staticModule("scala")
res2.moduleClass.typeSignature member newTypeName("List")
res3.fullName
case class Test(first: String, second: String)
typeOf[Test].declarations
Foo.foo
exit
reify { trait Foo { val a: Int } }
getModule("scala")
getModule(newTrrmName("scala"))
getModule(newTermName("scala"))
exit
getModule(newTermName("B.C"))
:power
getModule(newTermName("B.C"))
new B>.C
new B.C
getModule(newTypeName("B.C"))
getCLass(newTypeName("B.C"))
getClass(newTypeName("B.C"))
getClassByName(newTypeName("B.C"))
package B { class C { override def toString = "package" } }
object B { class C { override def toString = "package" } }
getClass(newTypeName("B.C"))
definitions.getModule(newTypeName("B.C"))
definitions.getClass(newTypeName("B.C"))
exit
object foo { class A; class B }
cm.staticModule("foo").typeSignature
cm.staticModule("foo").typeSignature.members
cm.staticModule("foo").moduleClass.typeSignature
cm.staticModule("foo").moduleClass
cm.staticModule("foo").moduleClass.asTypeSymbol
cm.staticModule("foo").moduleClass.asTypeSymbol.typeSignature
cm.staticModule("foo").moduleClass.asTypeSymbol.typeSignature.members
"aaa" contains "."
"a.aa" contains "."
:power
exit
trait Y
trait X extends { val x: Int } with Y
exit
:type -v def foo: BaseUniverse#TypeTag[Int]
:type -v def foo: scala.reflect.base.Universe#TypeTag[Int]
:type -v def foo: scala.reflect.base.Universe#TypeTag[Int] = ???
ru.reify{object Test {
println("Hello World!")
} }
ru.showRaw(res0.tree)
ru.showRaw(ru.definitions.IntTpe)
ru.showRaw(ru.definitions.IntClass)
ru.showRaw(ru.definitions.IntClass.asType)
object O { def impl[T: c.TypeTag](c: Context) = ??? }
cm.staticModule("O")
reify(O)
reify(O).tpe
reify(O).staticTpe
reify(O).staticTpe.typeSymbol
reify(O).staticTpe.typeSymbol.moduleClass
reify(O).staticTpe.typeSymbol.asModuleSymbol.moduleClass
reify(O).staticTpe.typeSymbol.typeSignature
reify(O).staticTpe.typeSymbol.typeSignature(1)
reify(O).staticTpe.typeSymbol.typeSignature.tail.head
reify(O).staticTpe.typeSymbol.typeSignature.member(newTermName("impl"))
object O { def impl[T: c.TypeTag](c: Context) = ??? }
ru.reify(O).staticTpe.typeSymbol.typeSignature.member(newTermName("impl"))
object O { def impl[T: c.TypeTag](c: Context) = ??? }
val meth = ru.reify(O).staticTpe.typeSymbol.typeSignature.member(newTermName("impl"))
showRaw(meth.typeSignature)
import scala.reflect.runtime.{universe => ru}
trait X { def foo: String }
ru.typeOf[X]
res0.members
def foo[T: ru.TypeTag](x: T) = ru.typeOf[T]
foo(List(1, 2, 3))
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox
val tree = Apply(Select(Literal(Constant(40)),
newTermName("$plus")), List(Literal(Constant(2))))
println(ru.mkToolBox().runExpr(tree))
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox
val tree = Apply(Select(Literal(Constant(40)), newTermName("$plus")), List(Literal(Constant(2))))
ru.mkToolBox()
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox
val tree = Apply(Select(Literal(Constant(40)),
newTermName("$plus")), List(Literal(Constant(2))))
val cm = ru.runtimeMirror(getClass.getClassLoader)
println(cm.mkToolBox().runExpr(tree))
typeTag[List[Int]]
scala.reflect.runtime.currentMirror
cm
typeOf[List[Int]]
class Foo extends StaticAnnotation
class Foo extends annotation.StaticAnnotation
def foo(x: Int @Foo)
 = ???
def (x: @Foo) = ???
class Proof(expr: Any) extends annotation.StaticAnnotation
def trans[T](x: T, y: T, z: T)(a: Int @Proof(eq(x, y))) = ???
def trans[T](x: T, y: T, z: T)(a: Int @Proof eq(x, y)) = ???
def impl(c: Context) = c.literal(42)
def foo = macro(impl)
def impl(c: Context) = c.literal(42)
def foo = macro(impl)
def impl(c: Context) = c.literal(42)
def foo = macro(impl)
exit
def impl(c: Context) = c.literal(42)
def foo = macro(impl)
foo
def foo[T: Manifest] = println("hello")
foo[Int]
exit
def foo = macro(bar)
exit
def foo = macro(impl)
def impl(c: Context) = ???
def foo = macro(impl)
exit
def impl(c: Context) = ???
def foo = macro(impl)
foo
exit
typeOf[Int] stat_<:< typeOf[Int]
def impl(c: scala.reflect.macros.Context) = c.literal(42)
def foo = macro impl
foo
typeOf[List[Int]]
class C(val x: Int, val y: Int)
typeOf[C].members
import scala.concurrent._
Promise.successful(12)
res5.future.mapTo[Int].value
(res0.future.mapTo: Future[Int]).value
(res0.future.mapTo[Int]).value
exit
import scala.concurrent._
Promise.successful(12)
res0.future.mapTo[Int].value
(res0.future.mapTo: Future[Int].value
(res0.future.mapTo: Future[Int]).value
exit
import scala.concurrent._
Promise.successful(12)
res0.future.mapTo[Int].value
(res0.future.mapTo: Future[Int]).value
exit
class C { val x: Int = 2; def x(y: Int) = y }
typeOf[(=> Int)] =:= typeOf[Int]
def impl(c: Context)(s: c.Expr[String]): c.Expr[Any] = ???
def test(s: String) = macro impl
def test(s: String): Int = macro impl
exit
type =>!IO![X, Y] = (X, Y)
type !IO![X, Y] = (X, Y)
type IO[X, Y] = (X, Y)
X IO Y
type Foo = X IO Y
type IO[X, Y] = (X, Y)
Int IO Int
type IO[X, Y] = (X, Y)
type Foo = Int IO Int
:type Int IO Int
:type Foo
def f(x: Int: Ordering) = ???
case class C(x: Int, y: Int)
typeOf[C].declarations
ListMap(1 -> "1", 2 -> "2")
scala.collection.immutable.ListMap(1 -> "1", 2 -> "2")
scala.collection.immutable.ListMap(1 -> "1", 2 -> "2").toListMap
class C { def foo[T <: Int] = ??? }
typeOf[C].member("foo")
typeOf[C].member(newTermName("foo"))
val meth = typeOf[C].member(newTermName("foo")).asMethod
meth.typeParams
meth.typeParams(0)
meth.typeParams(0).info
meth.typeParams(0).typeSignature
meth.typeParams(0).typeSignature.kind
class C
implicit def c2int(c: C): Int = ???
implicitly[C => Int]
implicitly[C => Int](new C)
implicitly[C => Int]()(new C)
res0(new C)
reify(2)
class C
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}
val ctor = typeOf[C].member(nme.CONSTRUCTOR)
class C
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}
val ctor = typeOf[C].member(nme.CONSTRUCTOR)
val ctor = typeOf[C].member(nme.CONSTRUCTOR).asMethodSymbol
cm.reflectClass(typeOf[C].typeSymbol).reflectConstructor(ctor)
val c = typeOf[C].typeSymbol.asClassSymbol
cm.reflectClass(c).reflectConstructor(ctor)
val mm = cm.reflectClass(c).reflectConstructor(ctor)
mm()
List(1, 2).length
exit
def foo[T](x :
ds
)
def foo[T](x: Int) = ???
val 
d
}
val "".r(foo) = ""
foo(x = 2)
def foo(xs: Any*) = xs.length
definitions.ArrayClass
definitions.ArrayClass.decls
definitions.ArrayClass.declarations
definitions.ArrayClass.typeSignature.declarations
definitions.ArrayClass.typeSignature.declarations.last
val clone = res4
val m = res4
Array(1, 2).clone()
Array(1, 2).clone
val m = definitions.ArrayClass.typeSignature.declarations.last.asMethodSymbol
val m = definitions.ArrayClass.typeSignature.declarations.last.asMethod
cm.reflect(Array(1, 2)).reflectMethod(m)()
val m = definitions.ArrayClass.typeSignature.declarations.last.asMethod
definitions.ArrayClass.typeSignature.declarations
definitions.ArrayClass.typeSignature.declarations.head.asTerm
val f = res1
cm.reflect(Array(1, 2)).reflectField(f)
definitions.AnyClass.typeSignature.declarations
definitions.AnyValClass.typeSignature.declarations
definitions.AnyRefClass.typeSignature.declarations
definitions.ObjectClass.typeSignature.declarations
cm.reflect(1).reflectMethod(res0.head.asMethodSymbol)(1)
cm.reflect(1).reflectMethod(res0.head.asMethod)(1)
definitions.NullClass
definitions.NullClass.typeSignature.declarations
definitions.NothingClass.typeSignature.declarations
definitions.SingletonClass.typeSignature.declarations
:power
SingletonClass
SingletonClass.info.decls
AnnotationDefaultAttr.info.decls
magicSymbols
magicSymbols.filter(_.isType)
magicSymbols.filter(_.isType).foreach(s => { println("
magicSymbols.filter(_.isType).foreach(s => { println("=========="); println(s.name); println(s.info.decls) })
val m = definitions.AnyRefClass.typeSignature.member(newTermName("getClass")).asMethod
cm.reflect(1).reflectMethod(m)
cm.reflect(1).reflectMethod(m)()
val ctor = definitions.AnyValClass.typeSignature.head.asMethod
val ctor = definitions.AnyValClass.typeSignature.declarations.head.asMethod
cm.reflectClass(definitions.AnyValClass)
cm.reflectClass(definitions.AnyValClass).reflectConstructor(ctor)
res3()
val ctor = definitions.AnyValClass.typeSignature.declarations.head.asMethod
cm.reflectClass(definitions.AnyValClass).reflectConstructor(ctor)()
definitions.AnyRefClass.typeSignature.declarations.head.owner
definitions.AnyRefClass.typeSignature.declarations.foreach(println(_.owner))
definitions.AnyRefClass.typeSignature.declarations.foreach(x => println(x_.owner))
definitions.AnyRefClass.typeSignature.declarations.foreach(x => println(x.owner))
val x = typeOf[Int].declarations.head
x match { case definitions.ArraySymbol => "" }
x match { case definitions.ArrayClass => "" }
class C { override def getClass = ??? }
class C { override def getClass() = ??? }
class C { override def getClass(x: Int) = ??? }
def foo(x: Int*)(y: Int) = ???
def foo(x: Int*)(y: Int*) = ???
2.getClass
val x: Any = 2
x.getClass
synchronized(2)
"".synchronized(2)
typeOf[Int].declarations
typeOf[Int].declaration(newTermName(
"+"))
typeOf[Int].declaration(newTermName("$plus"))
cm.reflect(2).reflectMethod(res2)
cm.reflect(2).reflectMethod(res2.asMethod)
typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(0).asMethod
cm.reflect(2).reflectMethod(res5)
class C { def +(c: C) = ??? }
typeOf[C].member(newTermName("+"))
typeOf[AnyRef].declaration(newTermName("asInstanceOf"))
typeOf[AnyRef].declarations
typeOf[Any].declarations
cm.reflect("2").reflectMethod(typeOf[AnyRef].member(newTermName("clone")))()
cm.reflect("2").reflectMethod(typeOf[AnyRef].member(newTermName("clone")).asMethod)()
class C { def test(x: => Int) = x }
typeOf[C].member(newTermName("x")).asMethod
typeOf[C].member(newTermName("test")).asMethod
cm.reflect(new C).reflectMethod(res1)
res2(2)
res2(() => 2)
res2((() => 2).asInstanceOf[Function0[Int]])
res2((() => 2).asInstanceOf[Function1[Int]])
exit
typeOf[AnyRef].member(newTermName("wait")).asMethod
def foo(x: => Int*) = ???
def foo(x: (=> Int)*) = ???
def foo(x: => Int) = ???
def foo(x: => (Int*)) = ???
class C { var x = 2 }
class D extends C { override x = 3 }
class D extends C { override var x = 3 }
case class C(x: Int, y: Int = 2)
typeOf[C].decls.filter(_.isDefaultParam)
typeOf[C].declarations.filter(_.isDefaultParam)
typeOf[C].declarations.collect(_.isTerm).filter(_.isDefaultParam)
typeOf[C].declarations.collect(sym => sym.isTerm).filter(_.isDefaultParam)
typeOf[C].declarations.collect{ case sym => sym.isTerm }.filter(_.isDefaultParam)
typeOf[C].declarations.collect{ case sym if sym.isTerm => sym }.filter(_.isDefaultParam)
typeOf[C].declarations.collect{ case sym if sym.isTerm => sym }
typeOf[C].declarations.collect({ case sym if sym.isTerm => sym }).filter(sym => sym.isDefaultParam)
val decls = typeOf[C].declarations.collect{ case sym if sym.isTerm => sym }
decls filter (_.isDefaultParam)
val decls = typeOf[C].declarations.collect{ case sym if sym.isTerm => sym.asTerm }
decls filter (_.isDefaultParam)
classManifest[Int]
exit
classManifest[Int]
def foo[T: ClassManifest] = ()
foo[Int[]
foo[Int]
case class C(x: Int, y: Int = 2)
typeOf[C].decl(nme.CONSTRUCTOR)
typeOf[C].declaration(nme.CONSTRUCTOR)
res1.params
typeOf[C].declaration(nme.CONSTRUCTOR).asMethod
res3.params
res3.params filter (_.isDefault)
res3.params filter (_.asTerm.isDefault)
res3.params.flatten filter (_.asTerm.isDefault)
res3.params.flatten filter (_.asTerm.isDefaultParam)
typeOf[C].declaration(nme.CONSTRUCTOR).asMethod
case class C(x: Int, y: Int = 2)
typeOf[C].declaration(nme.CONSTRUCTOR).asMethod
res3.params.flatten filter (_.asTerm.isDefaultParam)
res1.params.flatten filter (_.asTerm.isDefaultParam)
case class C(x: Int, y: Int = 2)
val ctor = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod
ctor.params.flatten filter (_.asTerm.isDefaultParam)
IntClass
def foo[@specialized T] = null.asInstanceOf[T]
class C { def foo[@specialized T] = null.asInstanceOf[T] }
typeOf[C].decls
typeOf[C].declarations
val m = typeOf[C].declarations.tail.asMethod
val m = typeOf[C].declarations.toList.tail.asMethod
val m = typeOf[C].declarations.toList.last.asMethod
m.params
m.typeParams
m.typeParams.head.isSpecialized
class C(val x: Int) extends AnyVal { def foo = x }
typeOf[C].declarations
val d = typeOf[C].declarations.toList
d(0)
d(0).fullName
d(0).flags
showRaw(d(0).flags)
show(d(0).flags)
ru.show(d(0).flags)
ru.show(d(1).flags)
d
cm.reflect(new C(10)).reflectMethod(d(0).asMethod)
res9()
new C(10)
AnyValClass.declarations
AnyValClass.typeSignature.declarations
AnyValTpe
AnyValTpe.declarations
AnyValTpe.declarations.toList(1)
cm.reflect(new C(10)).reflectMethod(res16)
cm.reflect(new C(10)).reflectMethod(res16.asMethod)
res18()
exit
class C(val x: Int) extends AnyVal { def foo = x }
classTag[C]
typeTag[C]
cm.reflect(2).reflectMethod(AnyValTpe.declarations.toList(1).asMethod)
val plus = IntTpe.member(newTermName("$plus")).asTerm.alternatives.head.asMethod
plus.typeSignature
cm.reflect(2).reflectMethod(plus)
val plus = IntTpe.member(newTermName("$plus")).asTerm.alternatives.head.asMethod
cm.reflect(2).reflectMethod(plus)
2.getClass
typeOf[Int].member(newTermName("$plus")).asTerm.alternatives
typeOf[Int].member(newTermName("$plus")).asTerm.alternatives.map(sym => sym.typeSignature)
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("+")).asTerm.alternatives(3).asMethod)(2)
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod)(2)
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod)(2, 2)
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod)()
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod)(2)
2.toByte == 2.toShort
2.asInstanceOf[{def ==(x: Byte): Boolean}] == 2.toByte
val plus = typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod
cm.reflect(2.asInstanceOf[AnyRef]).reflectMethod(plus)
plus.owner.toType.erasure
plus.owner.asClassSymbol.,toType.erasure
plus.owner.asClassSymbol.toType.erasure
plus.owner.asClass.toType.erasure
Set(1, 2) ++ List(3)
class C { def foo = () }
cm.reflect(new C).reflectMethod(typeOf[C].member(newTermName("foo")).asMethod)()
class C { def foo = () }
cm.reflect(new C).reflectMethod(typeOf[C].member(newTermName("foo")).asMethod)()
exit
val MethodType(params, ret) = sortMethod.typeSignature
showRaw(sortMethod.typeSignature)
val sortMethod = typeOf[::[_]].member(newTermName("sorted"))
val sortMethod = typeOf[::[_]].member(newTermName("sorted")).asMethod
sortMethod.params
sortMethod.params(0)(0).isImplicit
sortMethod.params(0)(0).asTerm.isImplicit
sortMethod.params(0)(0) hasFlag Flag.IMPLICIT
typeOf[Int]
Integer(2)
new Integer(2)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Id {

}
def foo[T: TypeTag] = typeOf[T]
import scala.{Int => Foobzie}
foo[Foobzie]
import scala.reflect.runtime.{universe => ru}
foo[ru.Type]
reify(ru)
build.newNestedSymbol(IntClass, newTypeName("Bash"), NoPosition, MODULE, true)
res0.info
res0.typeSignature
build.setTypeSignature(build.newNestedSymbol(IntClass, newTypeName("Bash"), NoPosition, MODULE, true), NoType)
res0.typeSignature
typeOf[{ def x(x: Int): Int }]
)
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("2 + 2"))
scala.collection.mutable.ListBuffer(1, 2, 3)
scala.collection.mutable.ListBuffer(List(1))
res1.flatten
trait Foo { type T }
type Bar = T forSome Foo
def foo(implicit x: Int*)
= ???
foo(1, 2)
def foo(implicit x: Int*) = ()
foo(1, 2)
foo(1)
foo()
foo
implicit val x: Int = 1
foo
def foo(implicit x: Int*) = ()
foo
implicit val x: Int = 1
foo
exit
List(1) zip List(0)
List(1) zip List()
exit
object Impls { private def impl(c: Context) = ??? }
def foo = macro Impls.impl
object Impls { private def impl(c: Context) = ??? }
def foo = macro Impls.impl
reify { class C { type T } }
reify { abstract C }
reify { abstract class C }
reify { trait C }
reify { class C[+T] }
class C { def foo(x: Int = 2) = ??? }
sealed abstract type T
show(9024791446044960)
show(9024791446044960L)
ru.show(9024791446044960L)
ru.show(9024791446044960L.asInstanceOf[FlagSet])
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
val t = typeTag[Outer[Int]].tpe
val m = t.member(newTermName("m"))
m.typeSignature
m.typeSignatureIn(t)
m.typeSignatureIn(t).narrow
m.typeSignatureIn(t.narrow)
t.narrow
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
val t = typeOf[Outer[Int]]
val m = t.member(newTermName("m"))
m.typeSignatureIn(SuperType(ThisType(t.typeSymbol), t))
m.typeSignatureIn(t.narrow)
res0 =:= res1
showRaw(res0)
showRaw(res1)
m.typeSignatureIn(ThisType(t.typeSymbol))
m.typeSignatureIn(t)
m.typeSignatureIn(t).narrow
trait Foo { 
   def apply(i: Int): String 

}
 reify(new Foo { def apply(i: Int) = "hello"+i })
showRaw(res0.tree)
showRaw(res0.tree, printKinds = true)
def foo[T: TypeTag <: String] = ???
def foo[T <: String: TypeTag] = ???
ClassManifest.Int <:< ClassTag.Int
ClassManifest.Int >:> ClassTag.Int
ClassManifest.Int == ClassTag.Int
ClassManifest.classType(classOf[Int])
ClassTag.Int == ClassManifest.classType(classOf[Int])
exist
exit
ClassManifest.Int.runtimeClass
ClassManifest.Int.erasure == ClassTag.Int.erasure
exit
Manifest.Int <:< TypeTag.Int
TypeTag.Int <:< Manifest.Int
trait X { self: D.type => }
trait X { self: D.type => }; object D extends X
lazy val x = 2
lazy val (x, y) = (2, 3)
Map(1 -> 2)(1)
Map(1 -> 2)(2)
Map(1 -> 2).get(2)
:power
NoSymbol.defString
def foo[T, U] = ???
foo[Int]
ru.showRaw(17592186077248L.asInstanceOf[FlagSet])
ru.show(17592186077248L.asInstanceOf[FlagSet])
new Exception().getMessage
new Exception().toString
"%noffender".format()
def foo[T[_]: TypeTag] = ???
def foo[T[_]] = ???
def foo[M[_]](implicit ev: TypeTag[M[_]]) = ev
foo
foo[List]
scala.util.Properties.ScalaCompilerVersion
scala.util.Properties.versionString
System.getProperties()
ClassTag.Nothing
ClassTag.Nothing.mkArray
ClassTag.Nothing.make
ClassTag.Nothing.getClass.getMethods
ClassTag.Nothing.newArray(10)
exit
def foo[T: TypeTag] = implicitly[TypeTag[T]]
def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo[Int]
def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo[Int]
def bar[T] = foo[T]
def bar[T: TypeTag] = foo[T]
def bar[T: TypeTag] = foo[List[T]]
def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo[Int]
foo[List[Int]]
def bar[T] = foo[T]
def bar[T] = foo[List[T]]
def bar[T: TypeTag] = foo[T]
bar[Int]
def bar[T: TypeTag] = foo[List[T]]
bar[Int]
bar[List[Int]]
val ru = scala.reflect.runtime.universe
1
object c { def x(x: Int) = ???; def x(x: String) = ??? }
val x = c.x
ClassTag.Int <:< ClassTag.AnyVal
tb.runExpr(tb.parseExpr(
exit
))
tb.runExpr(tb.parseExpr("class C; new C"))
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("class C; new C"))
res2.getClass
val cm = scala.reflect.runtime.universe.runtimeMirror(getClass.getClassLoader)
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("class C; scala.reflect.classTag[C].runtimeClass"))
import scala.tools.reflect.ToolBox
exit
:paste
scala> import scala.reflect.runtime._ // requires scala-reflect.jar
                                      // in REPL it's implicitly added 
                                      // to the classpath
                                      // but in your programs
                                      // you need to do this on your own
import scala.reflect.runtime
scala> val cm = universe.runtimeMirror(getClass.getClassLoader)
cm @ 41d0fe80: reflect.runtime.universe.Mirror = JavaMirror with scala.tools.nsc.interpreter.IMain$TranslatingClassLoader...
scala> import scala.tools.reflect.ToolBox // requires scala-compiler.jar
                                          // in REPL it's implicitly added 
                                          // to the classpath
                                          // but in your programs
                                          // you need to do this on your own
import scala.tools.reflect.ToolBox
scala> val tb = cm.mkToolBox()
tb: scala.tools.reflect.ToolBox[reflect.runtime.universe.type] = scala.tools.reflect.ToolBoxFactory$ToolBoxImpl@3a962da5
scala> tb.runExpr(tb.parseExpr("class C; scala.reflect.classTag[C].runtimeClass"))
res2: Any = class __wrapper$1$f9d572ca0d884bca9333e251c64e980d$C$1
val cm = universe.runtimeMirror(getClass.getClassLoader)
import scala.tools.reflect.ToolBox // requires scala-compiler.jar
                                          // in REPL it's implicitly added 
                                          // to the classpath
                                          // but in your programs
                                          // you need to do this on your own
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("class C; scala.reflect.classTag[C].runtimeClass"))
val tb = cm.mkToolBox()
import scala.reflect.runtime.universe._
val x = build.newFreeTerm("x", typeOf[Int], 2)
val tb = cm.mkToolBox()
val x = build.newFreeTerm("x", typeOf[Int], 2)
tb.runExpr(Apply(Select(Ident(x), newTermName("$plus")), List(Literal(Constant(2))))
)
List(1, 2, 3)
1 :: 2 :: 3
1 :: 2 :: 3 :: Nil
abstract class Funky(val i: Int) extends AnyVal
def C[T] { def foo[T] = ??? }
typeOf[C[_]].member(newTermName("foo")).asMethodSymbol
class C[T] { def foo[T] = ??? }
typeOf[C[_]].member(newTermName("foo")).asMethodSymbol
typeOf[C[_]].member(newTermName("foo")).asMethod
foo.typeParams
val meth = typeOf[C[_]].member(newTermName("foo")).asMethod
meth.typeParams
class C[T] { def foo(x: T) = ??? }
val meth = typeOf[C[_]].member(newTermName("foo")).asMethod
meth.paramss
meth.params
meth.typeParams
case class C(x: Int, y: Int)
typeOf[C].members.filter(_.isCaseAccessor)
typeOf[C].members.collect{case x: TermSymbol => x}.filter(_.isCaseAccessor)
typeOf[C].members.collect{case x: TermSymbol => x}.filter(sym => sym.isCaseAccessor && sym.isM)
typeOf[C].members.collect{case x: MethodSymbol => x}.filter(_.isCaseAccessor)
typeOf[C].members
case class C(x: Int, y: Int)
typeOf[C].members.collect{case x: MethodSymbol => x}.filter(_.isCaseAccessor)
 typeOf[C].members.collect{case m: MethodSymbol if m.isCaseAccessor => (m.name -> m.returnType)}
class C(val x: Int, val y: Int)
typeOf[C].members.sorted
case class C(val x: Int, val y: Int)
typeOf[C].members.sorted
  val Listing, Album = Value
}
typeOf[ResponseType.Value].asInstanceOf[TypeRef].pre.typeSymbol
typeOf[ResponseType.Value].owner
typeOf[ResponseType.Value].typeSymbol
typeOf[ResponseType.Value].typeSymbol.owner
cm.reflectModule(res0)
cm.reflectModule(res0.asModule)
val moduleClass = typeOf[ResponseType.Value].asInstanceOf[TypeRef].pre.typeSymbol
val module = moduleClass.owner.member(moduleClass.name.toTermName)
val module = moduleClass.owner.typeSignature.member(moduleClass.name.toTermName)
cm.reflectModule(res0.asModule)
val module = moduleClass.owner.typeSignature
val module = moduleClass.owner.typeSignature.member(moduleClass.name.toTermName)
cm.reflectModule(module.asModule)
cm.reflectModule(module.asModule).instance
val moduleClass = typeOf[ResponseType.Value].asInstanceOf[TypeRef].pre.typeSymbol
val module = moduleClass.owner.typeSignature.member(moduleClass.name.toTermName)
cm.reflectModule(module.asModule).instance
case class C
typeOf[C].declarations
typeOf[C.type].declarations
typeOf[C.type].typeSymbol
typeOf[C.type].typeSymbol.name
typeOf[C].typeSymbol
res2 == res4
typeOf[C].owner.typeSymbol
typeOf[C].typeSymbol.owner.typeSignature
typeOf[C.type].typeSymbol.owner.typeSignature
case class C; def C(x: Int) = ???
typeOf[C].typeSymbol.owner.typeSignature
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C"))
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C")).asModule
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C")).suchThat(_.isModule)
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C")).suchThat(_.isModule).asModule
showRaw(typeOf[Int])
showRaw(typeOf[Int].typeSymbol)
showRaw(typeOf[Int].typeSymbol, printKinds = true)
import scala.reflect.runtime.{universe => ru}
ru.showRaw(typeOf[Int])
ru.showRaw(typeOf[Int].typeSymbol, printKinds = true)
tb = cm.mkToolBox()
val tb = cm.mkToolBox()
tb.mirror.classLoader
val tb = cm.mkToolBox()
tb.mirror.classLoader
tb.mirror.classLoader.getClass.getMethods
tb.mirror.classLoader.getClass.getDeclaredMethods
val t1 = tb.parseExpr("1 to 3 map (_+1)")
tb.runExpr(t1)
val t1 = tb.parseExpr("1 to 3 map (_+1)")
val tb = cm.mkToolBox()
val t1 = tb.parseExpr("def foo = 1 to 3 map (_+1); foo")
tb.runExpr(t1)
{
  def main(args: Array[String]) 
  {
    println("test")
  }
}
exit
scala.util.Try(1.toString)
 'scala.util.Try(1.toString)
scala.util.Try(1.toString)
def impl[A](c: reflect.macros.Context) = c.universe.reify(())
def impl[A](c: scala.reflect.macros.Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl[Any]
decl
def impl(c: Context) = c.reify(new { val x = 2 })
def impl(c: Context) = c.universe.reify(new { val x = 2 })
def foo = macro impl
foo
scala.reflect.runtime.universe.reify(new {val x = 2 })
class C
type X = C with { val amount: Int }
type X = { val amount: Int }
type X = { val amount: Int } with C
type X = ({ val amount: Int }) with C
type X = C with ({ val amount: Int })
case class C(x: Int, y: Int)
typeOf[C].members.collect{ case x: TermSymbol => x }
typeOf[C].members.collect{ case x: TermSymbol if x.isCaseAccessor => x }
typeOf[C].members.collect{ case x: TermSymbol if x.isCaseAccessor && x.isMethod => x }
typeOf[C].members.sorted.collect{ case x: TermSymbol if x.isCaseAccessor && x.isMethod => x }
exit
case class Test(a:String,b:List[Int])
typeOf[Test]
res0.members
res1.filter(_.isMethod).map(_.asMethod).toArray
val ms = res2.toList
val methods = res2.toList
val mirroredMethods = methods.flatMap(e => try
 {Some(lookAtMe.reflectMethod(e))} catch {case e:Throwable =>
 e.printStackTrace();None})
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass
sym.isSealed
res0.isSealed
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.isSealed
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.initialize
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.typeSignature
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.isSealed
val n = 1
ClassTag.Int.runtimeClass
n.getClass
classManifest[Object]
classManifest[List]
classManifest[List[_]]
classTag[List[_]]
classManifest[Int]
classManifest[String]
exit
classTag[List[_]]
classManifest[List[_]]
classManifest[String]
classManifest[String].toString
classManifest[Array[Int]]
classTag[Int]
classTag[Array[Int]]
classManifest[Array[Int]].erasure
res7.isArray
import scala.runtime.ScalaRunTime._
arrayElementClass(res7)
class C[T]
reify { object O; O }
reify { object O; O.asInstanceOf[Object] }
