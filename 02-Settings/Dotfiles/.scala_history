rootMirror.RootClass.typeSignature.member(newTermName("scala")).asModuleSymbol.moduleClass.typeSignature
rootMirror.RootClass.typeSignature.member(newTermName("scala")).asModuleSymbol.moduleClass.typeSignature.member(newTermName("Nothing"))
rootMirror.RootClass.typeSignature.member(newTermName("scala")).asModuleSymbol.moduleClass.typeSignature.member(newTermName("scala.Nothing"))
2
exit
2
exit
2
exit
exit\
2
22
exit
2
exit
2
cm.staticClass("scala.Nothing")
definitions.ScalaPackageClass
cm.staticModule("scala").moduleClass
cm.staticModule("scala").companionSymbol
cm.staticModule("scala").moduleClass
exit
definScalaPackage
definitions.ScalaPackage
cm.staticModule("scala")
rm.staticModule("scala")
val m = ru.runtimeMirror(null)
rb
ru
val ru = scala.reflect.runtime.universe
val m = ru.runtimeMirror(null)
rm
exit
rm
cm
ru.runtimeMirror(null)
exit
cm
rm
runtimeMirror(null)
runtimeMirror(null).staticClass("scala")
cm.classLoader
cm.classLoader.parent
cm.classLoader.getParent
scala.reflect.runtime.show(cm.classLoader.getParent)
scala.reflect.runtime.ReflectionUtil.show(cm.classLoader.getParent)
scala.reflect.runtime.ReflectionUtils.show(cm.classLoader.getParent)
rm
rm.classLoader.loadClass("scala.package")
res6.loadClass("scala.package")
exit
rm
cm
exit
show(cm.classLo
d
)
show(cm.classLoader)
exit
show(cm.classLoader)
println show(cm.classLoader)
println(show(cm.classLoader))
exit
ScalaPackageClass
rm.staticClass("scala")
rm.staticPackage("scala").moduleClass
rm.staticModule("scala").moduleClass
ScalaPackage
rm.staticModule("scala")
cm.staticModule("scala")
RootPackage
exit
rm
exit
rm // aka scala.reflect.runtime.universe.rootMirror
cm // aka scala.reflect.runtime.currentMirror
ScalaPackage
rm.staticModule("scala")
cm.staticModule("scala")
exit
cm
exit
cm
2
exit
cm
exit
rm.staticClass("scala.Any")
AnyClass
rm.staticClass("scala.AnyRef")
rm.staticClass("scala.AnyVal")
AnyValClass
cm.staticClass("scala.Any")
cm.staticClass("scala.AnyVal")
cm.staticClass("scala.Int")
rm.staticClass("scala.Int")
IntClass
exit
reify { def foo[T <: String with Singleton] = ??? }
exit
import scala.reflect.mirror._
reify{ def foo[T <: String with Singleton] = ??? }
reify{ def foo[T <: String] = ??? }
reify { abstract class C extends Seq[Int] with TraversableOnce[Int] }
exit
typeOf[{ def x: Int }]
exit
def foo[T] = classOf[T]
def foo[T] = classOf[List[T]]
foo[Int]
def foo[T] = classOf[Array[T]]
foo[Int]
def foo[T] = classOf[Array[Array[T]]]
foo
def foo[T] = classOf[Array[Int]]
foo
def foo[T] = classOf[Array[T]]
foo
foo == classOf[Object]
exit
cm
exit
import scala.reflect.mirror._
implicitly[TypeTag[List[Int]]
]
implicitly[TypeTag[List[Int]]]
implicitly[TypeTag[List[Int]]].tpe
typeOf[List[Int]]
{
  import scala.reflect.runtime.universe._
  val x = "2"
  val tt = implicitly[TypeTag[x.type]]
  println(tt)
}
val x = "2"
typeOf[x.type]
{
val y = "2"
typeOf[y.type]
}
exit
{
  import scala.reflect.runtime.universe._
  val x = "2"
  val tt = implicitly[TypeTag[x.type]]
  println(tt)
}
parse this
parse
exit
{
  import scala.reflect.runtime.universe._
  val x = "2"
  val tt = implicitly[TypeTag[x.type]]
  println(tt)
}
exit
classOf[Array[_ <: Object]]
classTag[Array[_ <: Object]]
def foo[T <: Object] = classTag[Array[T]]
def foo[T <: Object] = classOf[Array[T]]
foo
:type scala.reflect.mirror.Type
:type -v scala.reflect.mirror
:type -v scala.reflect.Code
:type -v scala.reflect.ScalaSignature
val List(1, 2, _*) = List(1, 2, 3, 4)
val List(1, 2, _) = List(1, 2, 3, 4)
val List(1, 2) = List(1, 2, 3, 4)
val List(x, y) = List(1, 2, 3, 4)
val List(1, 2) = List(1, 2, 3, 4)
val List(1) = List(1)
cm
cm.staticClass("Nothing")
cm.staticClass("scala.Nothing")
exit
class C {
type T
implicit val tag: ClassT
}
class C {
type T[U]
implicit val tag: ClassTag[T]
}
cm
cm.staticClass("scala.Nothing")
cm.staticClass("java.lang.String")
exit
class C { s"$this" }
class C { s"$yield" }
case clas
class foo extends StaticAnnotation
class foo extends annotation.StaticAnnotation
case class C(@foo x: Int)
case class C(x: Int)
cm.reflectClass(classOf[C])
res0.asTypeSymbol.asTypeConstructor
res0.symbol.asTypeSymbol.asTypeConstructor
res2.member(nme.CONSTRUCTOR)
val MethodType(params, _) = res3.typeSignature
params.map(_.typeSignature)
List(1, 2, 3) map (x => new { i = x })
List(1, 2, 3) map (x => new { val i = x })
res1(0).i
List(1, 2, 3) map (x => new { val i = x })
res1(0).i
res0(0).i
reify(new { val a = 1; val b = 2 })
val c: scala.reflect.makro.Context = null
:type c.universe
:type c.mirror
:type c.mirror.type
:type -v c.mirror
def q: c.mirror.type = ???
:type -v q
def q(x: Int): c.mirror.type = ???
:type -v q
:type -v def q: c.mirror.type = ???
"2".asInstanceOf[type { def toString: String }]
"2".asInstanceOf[{ def toString: String }]
"2".asInstanceOf[{ def toString: String }].toString
def foo = foo
classTag[Int]
scala.reflect.classTag[Int]
exit
scala.reflect.classTag[Int]
ru.typeOf[Int]
ru.typeOf[List[Int]]
exit
typeTag[List[Int]]
typeOf[List[Int]]
exit
typeTag[Int]
exit
typeTag[Int]
typeTag[List[Int]]
reify
typeTag
exit
classTag[Int]
typeTag[List[Int]]
exit
scala.reflect.runtime.currentMirror
scala.reflect.runtime.universe
scala.reflect.mirror
exit
class A {
 var x: Int = 42
}

val a = new A
val im: InstanceMirror = cm.reflect(a)
val cs = im.reflectClass.symbol
val f = cs.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f)
fm.field.isVariable
class A {
 var x: Int = 42
}

val a = new A

val im: InstanceMirror = cm.reflect(a)
val cs = im.reflectClass.symbol
val f = cs.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f)
fm.field.isVariable
reify { class A { var x = 42 } }
class A {
 var x: Int = 42
}

val a = new A

val im: InstanceMirror = cm.reflect(a)
val cs = im.reflectClass.symbol
val f = cs.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f)
fm.field.isVariable
"%x".format(22222)
"%x8".format(22222)
"%x:8".format(22222)
"%08x".format(22222)
"%%d".format(42)
def f: Function0[Int] = ???
def foo[T: TypeTag] = Array[T]()
def foo[T: ClassTag] = Array[T]()
reify(2)
exit
typeOf[List[Int]]
typeof[List[Int]]
typeOf[List[Int]]
m { val x = 1; x }
import scala.reflect.makro._
object Fun { def fun[A: c.TypeTag](c: Context)(x: c.Expr[A]) = c.reify( () => x.eval ) }
object Fun { def fun[A: c.TypeTag](c: Context)(x: c.Expr[A]) = c.reify( () => x.splice
)}
def m[A](x: A) = macro Fun.fun[A]
m(1)
m { val x = 1; 2 }
m { val x = 1; x }
scala.Nil
List(1, 2, 3).foldRight(0)(_ + _)
List(1, 2, 3).foldRight(0)((x, y) => { println(x); x + y })
{ val x = 2; reify(x) }
object Foo { val x = 2 }
import Foo._
reify(x)
exit
:type -v def foo = ???
:type def foo = ???
:type -v def foo = ???
:type def foo = ???
:type -v def foo = ???
List(1, 2, 3).productIterator
List(1, 2, 3).productIterator.toList
class Foo { def bar(x: Int) = x }
import scala.reflect.runtime.universe._ // requires scala-reflect.jar
val foo = new Foo
runtimeMirror(getClass.getClassLoader).reflect(foo)
res0.declaration(newTermName("foo"))
res0.symbol.typeSignature.declaration(newTermName("foo"))
res0.symbol.typeSignature.declarations()
res0.symbol.typeSignature.declarations
class Foo { def bar(x: Int) = x }
val foo = new Foo
runtimeMirror(getClass.getClassLoader).reflect(foo)
res0.symbol.typeSignature.declaration(newTermName("bar"))
res0.reflectMethod(res1.asMethodSymbol)(42)
class C { class D }
:type -v def foo(x: C#D) = ???
:type -v x: C#D = ???
:type -v def x: C#D = ???
showRaw(typeOf[scala.Product])
showRaw(typeOf[scala.Function1[_, _]))
showRaw(typeOf[scala.Function1[_, _])
showRaw(typeOf[scala.Function1[_, _]])
val tb = m.mkToolBox() 
val tb = cm.mkToolBox() 
tb.parseExpr("def x = {}")
tb.parseExpr("def x = {") 
tb.parseExpr("def x = {}")
trait ThirdParty { def invoke = println("right") }
trait WeatherIcon { def invoke = println("wrong") }
class MyClass {
    object objA extends ThirdParty
    object objB extends WeatherIcon
}
val stuff = typeOf[MyClass].members.filter(_.isValue).filter(_.typeSignature <:< typeOf[ThirdParty])
val objASymbol = stuff.head.asModuleSymbol
cm.reflect(new MyClass).reflectModule(objASymbol)
res0.companion
res0.instance
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
exit
reify(new { trait Inner; def m(): Inner = null })
def foo[T: TypeTag](x: T) = ()
foo(new { trait Inner; def m(): Inner = null })
0 to 64
2048 & (1L << 11) == (1L << 11)
(2048 & 1L << 11) == (1L << 11)
(2048 & (1L << 11)) == (1L << 11)
for (i <- 0 to 63 if i % 2 == 0) { print(i) }
"as".toUpper
"as".toUpperCase
class B { def foo(a: A) = 1 }
val im = cm.reflect(new B)
 im.symbol.asType.nonPrivateMember(u.newTermName("foo")).asMethodSymbol
 im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(res1)
res0(new A)
im(new A)
res2(new A)
typeOf[A]
res0.dealias
res0.normalize
type B = A
typeOf[B}
typeOf[B]
staticClass(classOf[B].getName)
cm.staticClass(classOf[B].getName)
classOf[B].getName
classOf[A].getName
cm.staticClass("B")
object C { type B = A }
typeOf[C.type]
typeOf[C.type].typeSignature.member(newTypeName("B")
)
typeOf[C.type].member(newTypeName("B")
)
res11.isAlias
res11.isAliasType
typeOf[C.B]
type B = A
object D { type C = B }
exit
cm.asInstanceOf[{def getModuleOrClass(path: Name, len: Int): Symbol}]
exit
typeOf[Int]
showRaw(res0)
res1.typeSymbol.typeSignature
res0.typeSymbol.typeSignature
mirrorThatLoaded
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
showRaw(t1)
showRaw(t2)
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}

import scala.reflect.runtime.universe._
import scala.reflect.runtime.{ currentMirror => cm }
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
val TypeRef(pre1, _, _) = t1
val TypeRef(pre2, _, _) = t2
pre1.typeSymbol
pre2.typeSymbol
ru
ru.asInstanceOf[{def mirrorThatLoaded(sym: Symbol): Mirror}
]
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}

import scala.reflect.runtime.universe._
import scala.reflect.runtime.{ currentMirror => cm }
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}

import scala.reflect.runtime.universe._
import scala.reflect.runtime.{ currentMirror => cm }
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
mirrorThatLoaded(t1)
class X {
   def methodIntIntInt(x: Int, y: Int) = x+y
}

import scala.reflect.runtime.universe._
import scala.reflect.runtime.{ currentMirror => cm }
val im: InstanceMirror = cm.reflect(new X)
val cs: ClassSymbol = im.symbol
val ts: Type = cs.typeSignature
val ms: MethodSymbol = ts.declaration(newTermName("methodIntIntInt")).asMethodSymbol
val MethodType( _, t1 ) = ms.typeSignature
val t2 = typeOf[scala.Int]
mirrorThatLoaded(t1)
val TypeRef(pre1, _, _) = t1
val TypeRef(pre2, _, _) = t2
mirrorThatLoaded(pre1)
mirrorThatLoaded(pre1.typeSymbol)
mirrorThatLoaded(pre2.typeSymbol)
classManifest[Int]
showRaw(typeOf[Int])
showRaw(reify(2 + 2).tree)
showRaw(reify(2 + 2).tree, printTypes = true)
" " * 2
exit
class ManifestTester {
  private final def toJavaMap[T, V](map: Map[T, V])(implicit m1: Manifest[T], m2: Manifest[V]): java.util.Map[_, _] = {
    map match {
      case m0: Map[Int, Int] => new java.util.HashMap[Integer, Integer]
      case m1: Map[Int, V] => new java.util.HashMap[Integer, V]
      case m2: Map[T, Int] => new java.util.HashMap[T, Integer]
      case _ => new java.util.HashMap[T, V]
    }
  }
}
val x: Manifest[Int] = null
def foo[T: Manifest] = ???
def foo[T: ClassManifest] = ???
def foo[T: Manifest] = ???
exit
def foo[T: Manifest] = ???
def foo[T: ClassManifest] = ???
def foo[T](implicit x: ClassManifest[T]) = ???
exit
def foo[T: ClassManifest] = ???
def foo[T](implicit x: ClassManifest[T]) = ???
def foo[T](implicit x: scala.reflect.ClassManifest[T]) = ???
def bar[T] = foo[T]
val x: ClassManifest[Int] = null
val y: ClassTag[Int] = null
x = y
var y: ClassTag[Int] = null
var x: ClassManifest[Int] = null
x = y
y = x
exit
@deprecated("foo", "2.10.0") def foo = ???
@deprecated("foo", "2.10.0") type T = Int
val x: T = 2
exit
typeOf[Int].member("$plus").asTermSymbol.resolveOverloaded(actuals = List(typeOf[Int]))
typeOf[Int].member(newTermName("$plus")).asTermSymbol.resolveOverloaded(actuals = List(typeOf[Int]))
exit
typeTag[(Int*) => Unit]
trait T
implicit val tag = typeTag[T]
implicit val tag = typeTag[String].asInstanceOf[TypeTag[T]]
println(tag.tpe)
val tree = reify { Nil : List[T] }.tree
trait T
implicit val tag = typeTag[String].asInstanceOf[TypeTag[T]]
val tree = reify { Nil : List[T] }.tree
class Foo { def bar(x: Int) = 2 }
new Foo().bar("
new Foo().bar("x")
implicit class Bar(x: Foo) { def bar(x: String) = 3 }
new Foo().bar("x")
ca
case class Foo()
trait X { def foo: Unit }
object Bar { def m(c: Context) = ??? }
import scala.reflect.makro.Context
object Bar { def m(c: Context) = ??? }
class C extends X { def foo = macro m }
class C extends X { def foo = macro Bar.m }
mirrorThatLoaded(typeOf[Int].typeSymbol)
showRaw(atype)
showRaw(atype2)
showRaw(atype, printIds = true)
showRaw(atype)
showRaw(atype, printIds = true)
showRaw(atype, printIds = true, printMirrors = true)
showRaw(atype2, printIds = true, printMirrors = true)
showRaw(atype, printIds = true, printMirrors = true)
typeOf[F].parents contains atype
typeOf[F].parents contains atype2
showRaw(atype)
showRaw(atype, printIds = true, printMirrors = true)
showRaw(atype2, printIds = true, printMirrors = true)
typeOf[F].parents
showRaw(typeOf[F].parents(1), printIds = true, printMirrors = true)
atype == atype2
atype2
typeOf[F].parents(1)
atype2 != res1
trait A[X]
trait B[Y] extends A[Y]
trait D
trait E extends A[D]
trait F extends A[String]
val atype = typeOf[A[String]]
val atype2 = typeOf[F].parents(1)
atype == atype2
class C { def foo(x: Int)(y: Int) = x + y }
object C { def foo(x: Int)(y: Int) = x + y }
cm.reflectModule("C")
class C { def foo(x: Int)(y: Int) = x + y }
cm.reflect(new C)
res1.reflectMethod(res1.symbol.member(newTermName("foo)))
res1.reflectMethod(res1.symbol.member(newTermName("foo:)))
res1.reflectMethod(res1.symbol.member(newTermName("foo")))
res1.reflectMethod(res1.symbol.typeSignature.member(newTermName("foo")))
res1.reflectMethod(res1.symbol.asTypeSymbol.typeSignature.member(newTermName("foo")))
res1.reflectMethod(res1.symbol.typeSignature.member(newTermName("foo")).asMethodSymbol)
res5(1, 2)
classOf[String]
ClassTag.String
classTag[String]
scala.reflect.classTag[String]
ClassTag.String
scala.reflect.ClassTag.String
exit
"""#\d+""".r.replaceAllIn("a#12121, b#3232", "<id>")
showRaw(reify(2), printTypes = true, printMirrors = true)
showRaw(reify(2).tree, printTypes = true, printMirrors = true)
showRaw(reify(2).tree, printTypes = true)
  val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
  val tree1 = reify(new collection.immutable.HashMap[String, String])
  val tree2 = reify(new collection.mutable.HashMap[String, String])
tb.typeCheck(tree1.tree)
showRaw(res3, printTypes = true, printMirrors = true)
  val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
  val tree1 = reify(new collection.immutable.HashMap[String, String])
  val tree2 = reify(new collection.mutable.HashMap[String, String])
tb.typeCheck(tree1.tree)
showRaw(res0, printTypes = true, printMirrors = true)
def foo[T <: Int] = reify(List[T]())
def foo[T] = reify(List[T]())
class Foo {
type T
reify(List[T]())
}
class Foo {
type T = Int
reify(List[T]())
}
class Foo {
type T = Int
def mkT: T = 0
reify(List[T](mkT, mkT))
}
type FootnoteIndex = collection.mutable.Map[Class, collection.mutable.WeakHashMap[Any, Int]]
type FootnoteIndex = collection.mutable.Map[Class[_], collection.mutable.WeakHashMap[Any, Int]]
new FootnoteIndex()
FootnoteIndex()
val s = TreeSet[Int]()
val s = collection.mutable.TreeSet[Int]()
s += 1
s += 5
s += 2
s
collection.mutable.WeakHashMap[Any, Int]()
collection.mutable.TreeSet(1, 5, 2)
collection.mutable.TreeSet(1, 5, 2).map(i => (i, i))
collection.mutable.SortedSet(1, 5, 2).map(i => (i, i))
collection.mutable.SortedSet(1, 5, 2).map(i => (i, i.toString))
collection.mutable.SortedSet(1, 5, 2).map(i => (i, new Object))
showRaw(typeOf[Int])
showRaw(typeOf[List[Int]], printIds = true, printMirrors = true)
Map[Class[_], SortedSet[Int]]() withDefault (key => SortedSet[Int]())
import scala.collection.mutable.{Map, WeakHashMap, SortedSet}
Map[Class[_], SortedSet[Int]]() withDefault (key => SortedSet[Int]())
res2(typeOf[Int]) += 1
res2(typeOf[Int])
res0(typeOf[Int])
res0(scala.reflect.runtime.universe.typeOf[Int])
res0(classOf[Int]) += 1
res0(classOf[Int])
showRaw(typeOf[Int])
showRaw(typeOf[List[Int]], printIds = true, printMirrors = true)
classOf[Object].getSuperClass
classOf[Object].getSuperclass
showRaw(typeOf[List[Int]], printIds = true, printMirrors = true)
showRaw(typeOf[List[Int]], printIds = true)
showRaw(typeOf[List[Int]])
show(typeOf[List[Int]])
typeOf[{def foo(x: Int): Int}]
typeOf[String]
exit
staticModule("java.lang")
cm.staticModule("java.lang")
res1.typeSignature
res2.members
res2.moduleClass.typeSignature
res1.moduleClass.typeSignature
res1.moduleClass.typeSignature.members
res1.moduleClass
IntTpe
JavaLangPackage
JavaLangPackage.parent
JavaLangPackage.owner
typeOf[{def foo(x: Int): Int}]
typeOf[Nothing]
typeOf[Null]
typeOf[scala.Null]
typeOf[Any]
typeOf[List[Any]]
typeOf[{def foo(x: Int): Int}]
cm.selectType(ScalaPackage, "AnyRef")
build.selectType(ScalaPackage, "AnyRef")
typeOf[{def foo(x: Int): Int}]
typeOf[(Int*) => Unit]
typeOf[(=> Int) => Unit]
typeOf[String].members(0)
typeOf[String].members.toList(0)
res0.typeSignature
val MethodType(params, ret) = res0.typeSignature
class Foo; object Foo
typeOf[Foo]
res1.typeSymbol
res0.typeSymbol
res0.typeSymbol.companionSymbol
showRaw(res0, printKinds = true)
class Foo

object Foo
typeOf[Foo.type]
showRaw(res0, printKinds = true)
res0.typeSymbol.companionSymbol
res0.typeSymbol
res0.typeSymbol.kinds
res0.typeSymbol.kind
res0.typeSymbol.companionSymbol.kind
res0.typeSymbol.companionSymbol.getClass
res0.typeSymbol.getClass
res0.typeSymbol.isModule
typeOf[Foo]
class Foo; object Foo
typeOf[Foo.type].typeSymbol
typeOf[Foo.type].typeSymbol.getClass
typeOf[Foo.type].typeSymbol.typeSignature
typeOf[Foo.type].typeSymbol.typeSignature.selfType
typeOf[Foo.type].typeSymbol.selfType
typeOf[Foo.type].typeSymbol.asClassSymbol
typeOf[Foo.type].typeSymbol.asClassSymbol.selfType
typeOf[Foo.type].typeSymbol.asClassSymbol.selfType.termSymbol
typeOf[Foo.type].typeSymbol.asClassSymbol.selfType.asInstanceOf[scala.tools.nsc.Global#Type].termSymbol
typeOf[{def foo(x: Int): Int}]
cm.selectType(ScalaModule.moduleClass, "AnyRef")
build.selectType(ScalaModule.moduleClass, "AnyRef")
build.selectType(staticModule("scala").moduleClass, "AnyRef")
build.selectType(cm.staticModule("scala").moduleClass, "AnyRef")
typeOf[{def foo(x: Int): Int}]
 def f1 = classManifest[Predef.ArrowAssoc[_]]
class A; class B { def foo(x: A) = 1 }
cval im = cm.reflect(new B)
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)
res0(new A)
exit
exity
exit
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
im.reflectMethod(method)
class A; class B { def foo(x: A) = 1 }; val im = cm.reflect(new B); val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol; im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val cm = reflect.runtime.currentMirror
val cm = scala.reflect.runtime.currentMirror
val u = cm.universe
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(u.newTermName("foo")).asMethodSymbol
im.reflectMethod(method)
 res0(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(u.newTermName("foo")).asMethodSymbol
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)
 res0(new A)
class A; class B { def foo(x: A) = 1 }; val im = cm.reflect(new B); val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol; im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
println(classOf[A].getName)
println(classOf[B].getName)
class A
class B { def foo(x: A) = 1 }
val cm = reflect.runtime.currentMirror
val u = cm.universe
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(u.newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
exit
class A;classB
class A;class B
class A; class B
class A
class A; class B
t1
t2
showRaw(t1)
showRaw(t2)
t1 == t2
showRaw(typeOf[scala.Int])
showRaw(typeOf[scala.Int], printMirrors = true)
showRaw(scala.Int)
showRaw(typeOf[scala.Int])
showRaw(typeOf[scala.Int], printMirrors = true)
showRaw(cm.typeOf[scala.Int], printMirrors = true)
exit
showRaw(typeOf[scala.Int], printMirrors = true)
typeOf[GenTraversable[_]]
typeOf[scala.collection.GenTraversable[_]]
scala.tools.reflect.mkConsoleFrontEnd()
reify { trait Foo { val a: Int } }
c{
}
class X { def foo(x: Int) = ??? }; val MethodType(_, t1) = typeOf[X].declaration(newTermName("foo")); val t2 = typeOf[scala.Int]
class X { def foo(x: Int) = ??? }; val MethodType(_, t1) = typeOf[X].declaration(newTermName("foo")).typeSignature; val t2 = typeOf[scala.Int]
class X { def foo(x: Int): Int = ??? }; val MethodType(_, t1) = typeOf[X].declaration(newTermName("foo")).typeSignature; val t2 = typeOf[scala.Int]
t1 == t2
t1 =:= t2
t1 == t2
2
t1 == t2
case class TypeRef(pre: Type, sym: Symbol, args: List[Type])
t1 == t2
class A
val a = new A
val b = new A
case class A
:type -v def foo: Int
:type -v def foo: Int = ???
class A { def foo(x: Int*) = 1 }
typeOf[A] member newTermName("foo") typeSignature
res0.asInstanceOf[u.MethodType].params.head
res0.asInstanceOf[MethodType].params.head
res1.typeSignature
res2.typeSignature
class A { def foo(x: Int*) = 1 }
typeOf[A] member newTermName("foo") typeSignature
res0.asInstanceOf[MethodType].params.head
res1.typeSignature
x.typeSignature
 typeOf[(Any, Any)]
typeOf[(Int, Int)].erasure =:= typeOf[(Any, Any)]
 typeOf[Map[_, _]]
def impl(c: Context) = { println(c.typeOf[Map[_, _]]); c.literalUnit }
def foo = macro impl
foo
class A
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 }
val im = cm.reflect(new B)
val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol
im.reflectMethod(method)(new A)
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
typeOf[(Int, Int)]
showRaw(res0)
reify(2)
sealed trait LaunchExp extends LazyExp[LaunchExp] with BaseExp { 
   type OpSemExp = LaunchExp 
   type Val = Lam
}
class BaseExp
class LazyExp[T]
sealed trait LaunchExpr extends LazyExp[LaunchExp] with BaseExp {
type OpSemExp = LaunchExp
type Val = Lam
}
sealed trait LaunchExp extends LazyExp[LaunchExp] with BaseExp {
type OpSemExp = LaunchExp
type Val = Lam
}
class BaseExp
class LazyExp[T] { type Lam }
sealed trait LaunchExp extends LazyExp[LaunchExp] with BaseExp {
type OpSemExp = LaunchExp
type Val = Lam
}
trait BaseExp
class LazyExp[T] { type Lam }
sealed trait LaunchExp extends LazyExp[LaunchExp] with BaseExp {
type OpSemExp = LaunchExp
type Val = Lam
}
class BaseLam[T](a: Any, b: Any)
class Idn
case class Lam(override val x: Idn, override val e: LaunchExp) 
   extends BaseLam[LaunchExp](x, e) with LaunchExp
typeOf[List[Int]] <:< typeOf[List[Any]]
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
do 2 with 3
foo 2 bar 3
reify(reify(2))
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class A; def foo = 2
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A { def x = 2 }
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
exit
class A; class B
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
trait ThirdParty { def invoke = println("right") }
trait WeatherIcon { def invoke = println("wrong") }
class MyClass {
    object objA extends ThirdParty
    object objB extends WeatherIcon
}
val stuff = typeOf[MyClass].members.filter(_.isValue).filter(_.typeSignature <:< typeOf[ThirdParty])
val objASymbol = stuff.head.asModuleSymbol
cm.reflect(new MyClass).reflectModule(objASymbol)
res0.companion
res0.instance
class A {
  var x: Int = 42
}

val a = new A

val im: InstanceMirror = cm.reflect(a)
val cs = im.reflectClass.symbol
val f = cs.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f) 
fm.field.isVariable
class A {
  var x: Int = 42
}
val a = new A
val im: InstanceMirror = cm.reflect(a)
val f = im.symbol.typeSignature.declaration(newTermName("x")).asTermSymbol
val fm: FieldMirror = im.reflectField(f) 
fm.field.isVariable
fm.symbol.isVariable
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
class A
class B { def foo(x: A) = 1 };val im = cm.reflect(new B);val method = im.symbol.asType.nonPrivateMember(newTermName("foo")).asMethodSymbol;val mm = im.reflectMethod(method)
mm(new A)
exit
def impl(c: Context) = {
def cc: c.type with scala.reflect.makro.Context = ???
}
def impl(c: Context) = {
val cc: c.type with scala.reflect.makro.Context = c
}
3 + 4
class World { def update(x: Int, v: Int): World = new World }
var w = new World
w(1) = 2
var w = new World
class World { def update(x: Int, v: Int): World = new World }
var w = new World
w(1) = 2
w
var x = List(1, 2)
x(0) = 3
List(1, 2).iterator
res0.mkString
exit
List(1, 2, 3).max
List(1, 2, 3).max(i => i * 2)
"lost".capitalize
exit
1.compare(2)
exit
val xs = SortedSet(3, 2, 5, 6, 1)
val xs = TreeSet(3, 2, 5, 6, 1)
val xs = collection.immutable.SortedSet(3, 2, 5, 6, 1)
xs take 3
import scala.reflect.runtime.universe._
List(List(), (1,2))
def x[T : TypeTag](t: T) = typeOf[T]
x(List(List(), (1,2)))
showRaw(res1)
 x(List(List(), (1,2)).head)
showRaw(res3)
typeOf[Product]
showRaw(res5)
exit
val rng = new scala.util.Random(42)
rng.nextInt(100)
import collection.immutable.SortedSet
SortedSet(10, 2) ++ SortedSet(5, 3)
SortedSet(10, 2) ++ SortedSet(5, 3) take 1
SortedSet(10, 2) ++ (SortedSet(5, 3) take 1)
collection.immutable.SortedSet(1, 2, 3, 2)
1.0.toInt
typeOf[X]
isDifferent(instance, instance)
Experiment.isDifferent(instance, instance)
exit
typeOf[X]
case class X(s: String)
typeOf[X].members
typeTag[scala.Predef.ArrowAssoc[_]]
classTag[scala.Predef.ArrowAssoc[String]]
classManifest[scala.Predef.ArrowAssoc[String]]
classManifest[List[_]]
classManifest[List[Int]]
classManifest[List[_]]
staticClass("scala.List"
)
cm.staticClass("scala.List")
res0.fullName
cm.staticModule("scala")
res2.moduleClass.typeSignature member newTypeName("List")
res3.fullName
case class Test(first: String, second: String)
typeOf[Test].declarations
Foo.foo
exit
reify { trait Foo { val a: Int } }
getModule("scala")
getModule(newTrrmName("scala"))
getModule(newTermName("scala"))
exit
getModule(newTermName("B.C"))
:power
getModule(newTermName("B.C"))
new B>.C
new B.C
getModule(newTypeName("B.C"))
getCLass(newTypeName("B.C"))
getClass(newTypeName("B.C"))
getClassByName(newTypeName("B.C"))
package B { class C { override def toString = "package" } }
object B { class C { override def toString = "package" } }
getClass(newTypeName("B.C"))
definitions.getModule(newTypeName("B.C"))
definitions.getClass(newTypeName("B.C"))
exit
object foo { class A; class B }
cm.staticModule("foo").typeSignature
cm.staticModule("foo").typeSignature.members
cm.staticModule("foo").moduleClass.typeSignature
cm.staticModule("foo").moduleClass
cm.staticModule("foo").moduleClass.asTypeSymbol
cm.staticModule("foo").moduleClass.asTypeSymbol.typeSignature
cm.staticModule("foo").moduleClass.asTypeSymbol.typeSignature.members
"aaa" contains "."
"a.aa" contains "."
:power
exit
trait Y
trait X extends { val x: Int } with Y
exit
:type -v def foo: BaseUniverse#TypeTag[Int]
:type -v def foo: scala.reflect.base.Universe#TypeTag[Int]
:type -v def foo: scala.reflect.base.Universe#TypeTag[Int] = ???
ru.reify{object Test {
println("Hello World!")
} }
ru.showRaw(res0.tree)
ru.showRaw(ru.definitions.IntTpe)
ru.showRaw(ru.definitions.IntClass)
ru.showRaw(ru.definitions.IntClass.asType)
object O { def impl[T: c.TypeTag](c: Context) = ??? }
cm.staticModule("O")
reify(O)
reify(O).tpe
reify(O).staticTpe
reify(O).staticTpe.typeSymbol
reify(O).staticTpe.typeSymbol.moduleClass
reify(O).staticTpe.typeSymbol.asModuleSymbol.moduleClass
reify(O).staticTpe.typeSymbol.typeSignature
reify(O).staticTpe.typeSymbol.typeSignature(1)
reify(O).staticTpe.typeSymbol.typeSignature.tail.head
reify(O).staticTpe.typeSymbol.typeSignature.member(newTermName("impl"))
object O { def impl[T: c.TypeTag](c: Context) = ??? }
ru.reify(O).staticTpe.typeSymbol.typeSignature.member(newTermName("impl"))
object O { def impl[T: c.TypeTag](c: Context) = ??? }
val meth = ru.reify(O).staticTpe.typeSymbol.typeSignature.member(newTermName("impl"))
showRaw(meth.typeSignature)
import scala.reflect.runtime.{universe => ru}
trait X { def foo: String }
ru.typeOf[X]
res0.members
def foo[T: ru.TypeTag](x: T) = ru.typeOf[T]
foo(List(1, 2, 3))
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox
val tree = Apply(Select(Literal(Constant(40)),
newTermName("$plus")), List(Literal(Constant(2))))
println(ru.mkToolBox().runExpr(tree))
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox
val tree = Apply(Select(Literal(Constant(40)), newTermName("$plus")), List(Literal(Constant(2))))
ru.mkToolBox()
import scala.reflect.runtime.universe._
import scala.tools.reflect.ToolBox
val tree = Apply(Select(Literal(Constant(40)),
newTermName("$plus")), List(Literal(Constant(2))))
val cm = ru.runtimeMirror(getClass.getClassLoader)
println(cm.mkToolBox().runExpr(tree))
typeTag[List[Int]]
scala.reflect.runtime.currentMirror
cm
typeOf[List[Int]]
class Foo extends StaticAnnotation
class Foo extends annotation.StaticAnnotation
def foo(x: Int @Foo)
 = ???
def (x: @Foo) = ???
class Proof(expr: Any) extends annotation.StaticAnnotation
def trans[T](x: T, y: T, z: T)(a: Int @Proof(eq(x, y))) = ???
def trans[T](x: T, y: T, z: T)(a: Int @Proof eq(x, y)) = ???
def impl(c: Context) = c.literal(42)
def foo = macro(impl)
def impl(c: Context) = c.literal(42)
def foo = macro(impl)
def impl(c: Context) = c.literal(42)
def foo = macro(impl)
exit
def impl(c: Context) = c.literal(42)
def foo = macro(impl)
foo
def foo[T: Manifest] = println("hello")
foo[Int]
exit
def foo = macro(bar)
exit
def foo = macro(impl)
def impl(c: Context) = ???
def foo = macro(impl)
exit
def impl(c: Context) = ???
def foo = macro(impl)
foo
exit
typeOf[Int] stat_<:< typeOf[Int]
def impl(c: scala.reflect.macros.Context) = c.literal(42)
def foo = macro impl
foo
typeOf[List[Int]]
class C(val x: Int, val y: Int)
typeOf[C].members
import scala.concurrent._
Promise.successful(12)
res5.future.mapTo[Int].value
(res0.future.mapTo: Future[Int]).value
(res0.future.mapTo[Int]).value
exit
import scala.concurrent._
Promise.successful(12)
res0.future.mapTo[Int].value
(res0.future.mapTo: Future[Int].value
(res0.future.mapTo: Future[Int]).value
exit
import scala.concurrent._
Promise.successful(12)
res0.future.mapTo[Int].value
(res0.future.mapTo: Future[Int]).value
exit
class C { val x: Int = 2; def x(y: Int) = y }
typeOf[(=> Int)] =:= typeOf[Int]
def impl(c: Context)(s: c.Expr[String]): c.Expr[Any] = ???
def test(s: String) = macro impl
def test(s: String): Int = macro impl
exit
type =>!IO![X, Y] = (X, Y)
type !IO![X, Y] = (X, Y)
type IO[X, Y] = (X, Y)
X IO Y
type Foo = X IO Y
type IO[X, Y] = (X, Y)
Int IO Int
type IO[X, Y] = (X, Y)
type Foo = Int IO Int
:type Int IO Int
:type Foo
def f(x: Int: Ordering) = ???
case class C(x: Int, y: Int)
typeOf[C].declarations
ListMap(1 -> "1", 2 -> "2")
scala.collection.immutable.ListMap(1 -> "1", 2 -> "2")
scala.collection.immutable.ListMap(1 -> "1", 2 -> "2").toListMap
class C { def foo[T <: Int] = ??? }
typeOf[C].member("foo")
typeOf[C].member(newTermName("foo"))
val meth = typeOf[C].member(newTermName("foo")).asMethod
meth.typeParams
meth.typeParams(0)
meth.typeParams(0).info
meth.typeParams(0).typeSignature
meth.typeParams(0).typeSignature.kind
class C
implicit def c2int(c: C): Int = ???
implicitly[C => Int]
implicitly[C => Int](new C)
implicitly[C => Int]()(new C)
res0(new C)
reify(2)
class C
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}
val ctor = typeOf[C].member(nme.CONSTRUCTOR)
class C
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}
val ctor = typeOf[C].member(nme.CONSTRUCTOR)
val ctor = typeOf[C].member(nme.CONSTRUCTOR).asMethodSymbol
cm.reflectClass(typeOf[C].typeSymbol).reflectConstructor(ctor)
val c = typeOf[C].typeSymbol.asClassSymbol
cm.reflectClass(c).reflectConstructor(ctor)
val mm = cm.reflectClass(c).reflectConstructor(ctor)
mm()
List(1, 2).length
exit
def foo[T](x :
ds
)
def foo[T](x: Int) = ???
val 
d
}
val "".r(foo) = ""
foo(x = 2)
def foo(xs: Any*) = xs.length
definitions.ArrayClass
definitions.ArrayClass.decls
definitions.ArrayClass.declarations
definitions.ArrayClass.typeSignature.declarations
definitions.ArrayClass.typeSignature.declarations.last
val clone = res4
val m = res4
Array(1, 2).clone()
Array(1, 2).clone
val m = definitions.ArrayClass.typeSignature.declarations.last.asMethodSymbol
val m = definitions.ArrayClass.typeSignature.declarations.last.asMethod
cm.reflect(Array(1, 2)).reflectMethod(m)()
val m = definitions.ArrayClass.typeSignature.declarations.last.asMethod
definitions.ArrayClass.typeSignature.declarations
definitions.ArrayClass.typeSignature.declarations.head.asTerm
val f = res1
cm.reflect(Array(1, 2)).reflectField(f)
definitions.AnyClass.typeSignature.declarations
definitions.AnyValClass.typeSignature.declarations
definitions.AnyRefClass.typeSignature.declarations
definitions.ObjectClass.typeSignature.declarations
cm.reflect(1).reflectMethod(res0.head.asMethodSymbol)(1)
cm.reflect(1).reflectMethod(res0.head.asMethod)(1)
definitions.NullClass
definitions.NullClass.typeSignature.declarations
definitions.NothingClass.typeSignature.declarations
definitions.SingletonClass.typeSignature.declarations
:power
SingletonClass
SingletonClass.info.decls
AnnotationDefaultAttr.info.decls
magicSymbols
magicSymbols.filter(_.isType)
magicSymbols.filter(_.isType).foreach(s => { println("
magicSymbols.filter(_.isType).foreach(s => { println("=========="); println(s.name); println(s.info.decls) })
val m = definitions.AnyRefClass.typeSignature.member(newTermName("getClass")).asMethod
cm.reflect(1).reflectMethod(m)
cm.reflect(1).reflectMethod(m)()
val ctor = definitions.AnyValClass.typeSignature.head.asMethod
val ctor = definitions.AnyValClass.typeSignature.declarations.head.asMethod
cm.reflectClass(definitions.AnyValClass)
cm.reflectClass(definitions.AnyValClass).reflectConstructor(ctor)
res3()
val ctor = definitions.AnyValClass.typeSignature.declarations.head.asMethod
cm.reflectClass(definitions.AnyValClass).reflectConstructor(ctor)()
definitions.AnyRefClass.typeSignature.declarations.head.owner
definitions.AnyRefClass.typeSignature.declarations.foreach(println(_.owner))
definitions.AnyRefClass.typeSignature.declarations.foreach(x => println(x_.owner))
definitions.AnyRefClass.typeSignature.declarations.foreach(x => println(x.owner))
val x = typeOf[Int].declarations.head
x match { case definitions.ArraySymbol => "" }
x match { case definitions.ArrayClass => "" }
class C { override def getClass = ??? }
class C { override def getClass() = ??? }
class C { override def getClass(x: Int) = ??? }
def foo(x: Int*)(y: Int) = ???
def foo(x: Int*)(y: Int*) = ???
2.getClass
val x: Any = 2
x.getClass
synchronized(2)
"".synchronized(2)
typeOf[Int].declarations
typeOf[Int].declaration(newTermName(
"+"))
typeOf[Int].declaration(newTermName("$plus"))
cm.reflect(2).reflectMethod(res2)
cm.reflect(2).reflectMethod(res2.asMethod)
typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(0).asMethod
cm.reflect(2).reflectMethod(res5)
class C { def +(c: C) = ??? }
typeOf[C].member(newTermName("+"))
typeOf[AnyRef].declaration(newTermName("asInstanceOf"))
typeOf[AnyRef].declarations
typeOf[Any].declarations
cm.reflect("2").reflectMethod(typeOf[AnyRef].member(newTermName("clone")))()
cm.reflect("2").reflectMethod(typeOf[AnyRef].member(newTermName("clone")).asMethod)()
class C { def test(x: => Int) = x }
typeOf[C].member(newTermName("x")).asMethod
typeOf[C].member(newTermName("test")).asMethod
cm.reflect(new C).reflectMethod(res1)
res2(2)
res2(() => 2)
res2((() => 2).asInstanceOf[Function0[Int]])
res2((() => 2).asInstanceOf[Function1[Int]])
exit
typeOf[AnyRef].member(newTermName("wait")).asMethod
def foo(x: => Int*) = ???
def foo(x: (=> Int)*) = ???
def foo(x: => Int) = ???
def foo(x: => (Int*)) = ???
class C { var x = 2 }
class D extends C { override x = 3 }
class D extends C { override var x = 3 }
case class C(x: Int, y: Int = 2)
typeOf[C].decls.filter(_.isDefaultParam)
typeOf[C].declarations.filter(_.isDefaultParam)
typeOf[C].declarations.collect(_.isTerm).filter(_.isDefaultParam)
typeOf[C].declarations.collect(sym => sym.isTerm).filter(_.isDefaultParam)
typeOf[C].declarations.collect{ case sym => sym.isTerm }.filter(_.isDefaultParam)
typeOf[C].declarations.collect{ case sym if sym.isTerm => sym }.filter(_.isDefaultParam)
typeOf[C].declarations.collect{ case sym if sym.isTerm => sym }
typeOf[C].declarations.collect({ case sym if sym.isTerm => sym }).filter(sym => sym.isDefaultParam)
val decls = typeOf[C].declarations.collect{ case sym if sym.isTerm => sym }
decls filter (_.isDefaultParam)
val decls = typeOf[C].declarations.collect{ case sym if sym.isTerm => sym.asTerm }
decls filter (_.isDefaultParam)
classManifest[Int]
exit
classManifest[Int]
def foo[T: ClassManifest] = ()
foo[Int[]
foo[Int]
case class C(x: Int, y: Int = 2)
typeOf[C].decl(nme.CONSTRUCTOR)
typeOf[C].declaration(nme.CONSTRUCTOR)
res1.params
typeOf[C].declaration(nme.CONSTRUCTOR).asMethod
res3.params
res3.params filter (_.isDefault)
res3.params filter (_.asTerm.isDefault)
res3.params.flatten filter (_.asTerm.isDefault)
res3.params.flatten filter (_.asTerm.isDefaultParam)
typeOf[C].declaration(nme.CONSTRUCTOR).asMethod
case class C(x: Int, y: Int = 2)
typeOf[C].declaration(nme.CONSTRUCTOR).asMethod
res3.params.flatten filter (_.asTerm.isDefaultParam)
res1.params.flatten filter (_.asTerm.isDefaultParam)
case class C(x: Int, y: Int = 2)
val ctor = typeOf[C].declaration(nme.CONSTRUCTOR).asMethod
ctor.params.flatten filter (_.asTerm.isDefaultParam)
IntClass
def foo[@specialized T] = null.asInstanceOf[T]
class C { def foo[@specialized T] = null.asInstanceOf[T] }
typeOf[C].decls
typeOf[C].declarations
val m = typeOf[C].declarations.tail.asMethod
val m = typeOf[C].declarations.toList.tail.asMethod
val m = typeOf[C].declarations.toList.last.asMethod
m.params
m.typeParams
m.typeParams.head.isSpecialized
class C(val x: Int) extends AnyVal { def foo = x }
typeOf[C].declarations
val d = typeOf[C].declarations.toList
d(0)
d(0).fullName
d(0).flags
showRaw(d(0).flags)
show(d(0).flags)
ru.show(d(0).flags)
ru.show(d(1).flags)
d
cm.reflect(new C(10)).reflectMethod(d(0).asMethod)
res9()
new C(10)
AnyValClass.declarations
AnyValClass.typeSignature.declarations
AnyValTpe
AnyValTpe.declarations
AnyValTpe.declarations.toList(1)
cm.reflect(new C(10)).reflectMethod(res16)
cm.reflect(new C(10)).reflectMethod(res16.asMethod)
res18()
exit
class C(val x: Int) extends AnyVal { def foo = x }
classTag[C]
typeTag[C]
cm.reflect(2).reflectMethod(AnyValTpe.declarations.toList(1).asMethod)
val plus = IntTpe.member(newTermName("$plus")).asTerm.alternatives.head.asMethod
plus.typeSignature
cm.reflect(2).reflectMethod(plus)
val plus = IntTpe.member(newTermName("$plus")).asTerm.alternatives.head.asMethod
cm.reflect(2).reflectMethod(plus)
2.getClass
typeOf[Int].member(newTermName("$plus")).asTerm.alternatives
typeOf[Int].member(newTermName("$plus")).asTerm.alternatives.map(sym => sym.typeSignature)
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("+")).asTerm.alternatives(3).asMethod)(2)
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod)(2)
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod)(2, 2)
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod)()
cm.reflect(2).reflectMethod(typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod)(2)
2.toByte == 2.toShort
2.asInstanceOf[{def ==(x: Byte): Boolean}] == 2.toByte
val plus = typeOf[Int].declaration(newTermName("$plus")).asTerm.alternatives(3).asMethod
cm.reflect(2.asInstanceOf[AnyRef]).reflectMethod(plus)
plus.owner.toType.erasure
plus.owner.asClassSymbol.,toType.erasure
plus.owner.asClassSymbol.toType.erasure
plus.owner.asClass.toType.erasure
Set(1, 2) ++ List(3)
class C { def foo = () }
cm.reflect(new C).reflectMethod(typeOf[C].member(newTermName("foo")).asMethod)()
class C { def foo = () }
cm.reflect(new C).reflectMethod(typeOf[C].member(newTermName("foo")).asMethod)()
exit
val MethodType(params, ret) = sortMethod.typeSignature
showRaw(sortMethod.typeSignature)
val sortMethod = typeOf[::[_]].member(newTermName("sorted"))
val sortMethod = typeOf[::[_]].member(newTermName("sorted")).asMethod
sortMethod.params
sortMethod.params(0)(0).isImplicit
sortMethod.params(0)(0).asTerm.isImplicit
sortMethod.params(0)(0) hasFlag Flag.IMPLICIT
typeOf[Int]
Integer(2)
new Integer(2)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Id {

}
def foo[T: TypeTag] = typeOf[T]
import scala.{Int => Foobzie}
foo[Foobzie]
import scala.reflect.runtime.{universe => ru}
foo[ru.Type]
reify(ru)
build.newNestedSymbol(IntClass, newTypeName("Bash"), NoPosition, MODULE, true)
res0.info
res0.typeSignature
build.setTypeSignature(build.newNestedSymbol(IntClass, newTypeName("Bash"), NoPosition, MODULE, true), NoType)
res0.typeSignature
typeOf[{ def x(x: Int): Int }]
)
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("2 + 2"))
scala.collection.mutable.ListBuffer(1, 2, 3)
scala.collection.mutable.ListBuffer(List(1))
res1.flatten
trait Foo { type T }
type Bar = T forSome Foo
def foo(implicit x: Int*)
= ???
foo(1, 2)
def foo(implicit x: Int*) = ()
foo(1, 2)
foo(1)
foo()
foo
implicit val x: Int = 1
foo
def foo(implicit x: Int*) = ()
foo
implicit val x: Int = 1
foo
exit
List(1) zip List(0)
List(1) zip List()
exit
object Impls { private def impl(c: Context) = ??? }
def foo = macro Impls.impl
object Impls { private def impl(c: Context) = ??? }
def foo = macro Impls.impl
reify { class C { type T } }
reify { abstract C }
reify { abstract class C }
reify { trait C }
reify { class C[+T] }
class C { def foo(x: Int = 2) = ??? }
sealed abstract type T
show(9024791446044960)
show(9024791446044960L)
ru.show(9024791446044960L)
ru.show(9024791446044960L.asInstanceOf[FlagSet])
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
val t = typeTag[Outer[Int]].tpe
val m = t.member(newTermName("m"))
m.typeSignature
m.typeSignatureIn(t)
m.typeSignatureIn(t).narrow
m.typeSignatureIn(t.narrow)
t.narrow
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
val t = typeOf[Outer[Int]]
val m = t.member(newTermName("m"))
m.typeSignatureIn(SuperType(ThisType(t.typeSymbol), t))
m.typeSignatureIn(t.narrow)
res0 =:= res1
showRaw(res0)
showRaw(res1)
m.typeSignatureIn(ThisType(t.typeSymbol))
m.typeSignatureIn(t)
m.typeSignatureIn(t).narrow
trait Foo { 
   def apply(i: Int): String 

}
 reify(new Foo { def apply(i: Int) = "hello"+i })
showRaw(res0.tree)
showRaw(res0.tree, printKinds = true)
def foo[T: TypeTag <: String] = ???
def foo[T <: String: TypeTag] = ???
ClassManifest.Int <:< ClassTag.Int
ClassManifest.Int >:> ClassTag.Int
ClassManifest.Int == ClassTag.Int
ClassManifest.classType(classOf[Int])
ClassTag.Int == ClassManifest.classType(classOf[Int])
exist
exit
ClassManifest.Int.runtimeClass
ClassManifest.Int.erasure == ClassTag.Int.erasure
exit
Manifest.Int <:< TypeTag.Int
TypeTag.Int <:< Manifest.Int
trait X { self: D.type => }
trait X { self: D.type => }; object D extends X
lazy val x = 2
lazy val (x, y) = (2, 3)
Map(1 -> 2)(1)
Map(1 -> 2)(2)
Map(1 -> 2).get(2)
:power
NoSymbol.defString
def foo[T, U] = ???
foo[Int]
ru.showRaw(17592186077248L.asInstanceOf[FlagSet])
ru.show(17592186077248L.asInstanceOf[FlagSet])
new Exception().getMessage
new Exception().toString
"%noffender".format()
def foo[T[_]: TypeTag] = ???
def foo[T[_]] = ???
def foo[M[_]](implicit ev: TypeTag[M[_]]) = ev
foo
foo[List]
scala.util.Properties.ScalaCompilerVersion
scala.util.Properties.versionString
System.getProperties()
ClassTag.Nothing
ClassTag.Nothing.mkArray
ClassTag.Nothing.make
ClassTag.Nothing.getClass.getMethods
ClassTag.Nothing.newArray(10)
exit
def foo[T: TypeTag] = implicitly[TypeTag[T]]
def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo[Int]
def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo[Int]
def bar[T] = foo[T]
def bar[T: TypeTag] = foo[T]
def bar[T: TypeTag] = foo[List[T]]
def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo[Int]
foo[List[Int]]
def bar[T] = foo[T]
def bar[T] = foo[List[T]]
def bar[T: TypeTag] = foo[T]
bar[Int]
def bar[T: TypeTag] = foo[List[T]]
bar[Int]
bar[List[Int]]
val ru = scala.reflect.runtime.universe
1
object c { def x(x: Int) = ???; def x(x: String) = ??? }
val x = c.x
ClassTag.Int <:< ClassTag.AnyVal
tb.runExpr(tb.parseExpr(
exit
))
tb.runExpr(tb.parseExpr("class C; new C"))
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("class C; new C"))
res2.getClass
val cm = scala.reflect.runtime.universe.runtimeMirror(getClass.getClassLoader)
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("class C; scala.reflect.classTag[C].runtimeClass"))
import scala.tools.reflect.ToolBox
exit
:paste
scala> import scala.reflect.runtime._ // requires scala-reflect.jar
                                      // in REPL it's implicitly added 
                                      // to the classpath
                                      // but in your programs
                                      // you need to do this on your own
import scala.reflect.runtime
scala> val cm = universe.runtimeMirror(getClass.getClassLoader)
cm @ 41d0fe80: reflect.runtime.universe.Mirror = JavaMirror with scala.tools.nsc.interpreter.IMain$TranslatingClassLoader...
scala> import scala.tools.reflect.ToolBox // requires scala-compiler.jar
                                          // in REPL it's implicitly added 
                                          // to the classpath
                                          // but in your programs
                                          // you need to do this on your own
import scala.tools.reflect.ToolBox
scala> val tb = cm.mkToolBox()
tb: scala.tools.reflect.ToolBox[reflect.runtime.universe.type] = scala.tools.reflect.ToolBoxFactory$ToolBoxImpl@3a962da5
scala> tb.runExpr(tb.parseExpr("class C; scala.reflect.classTag[C].runtimeClass"))
res2: Any = class __wrapper$1$f9d572ca0d884bca9333e251c64e980d$C$1
val cm = universe.runtimeMirror(getClass.getClassLoader)
import scala.tools.reflect.ToolBox // requires scala-compiler.jar
                                          // in REPL it's implicitly added 
                                          // to the classpath
                                          // but in your programs
                                          // you need to do this on your own
val tb = cm.mkToolBox()
tb.runExpr(tb.parseExpr("class C; scala.reflect.classTag[C].runtimeClass"))
val tb = cm.mkToolBox()
import scala.reflect.runtime.universe._
val x = build.newFreeTerm("x", typeOf[Int], 2)
val tb = cm.mkToolBox()
val x = build.newFreeTerm("x", typeOf[Int], 2)
tb.runExpr(Apply(Select(Ident(x), newTermName("$plus")), List(Literal(Constant(2))))
)
List(1, 2, 3)
1 :: 2 :: 3
1 :: 2 :: 3 :: Nil
abstract class Funky(val i: Int) extends AnyVal
def C[T] { def foo[T] = ??? }
typeOf[C[_]].member(newTermName("foo")).asMethodSymbol
class C[T] { def foo[T] = ??? }
typeOf[C[_]].member(newTermName("foo")).asMethodSymbol
typeOf[C[_]].member(newTermName("foo")).asMethod
foo.typeParams
val meth = typeOf[C[_]].member(newTermName("foo")).asMethod
meth.typeParams
class C[T] { def foo(x: T) = ??? }
val meth = typeOf[C[_]].member(newTermName("foo")).asMethod
meth.paramss
meth.params
meth.typeParams
case class C(x: Int, y: Int)
typeOf[C].members.filter(_.isCaseAccessor)
typeOf[C].members.collect{case x: TermSymbol => x}.filter(_.isCaseAccessor)
typeOf[C].members.collect{case x: TermSymbol => x}.filter(sym => sym.isCaseAccessor && sym.isM)
typeOf[C].members.collect{case x: MethodSymbol => x}.filter(_.isCaseAccessor)
typeOf[C].members
case class C(x: Int, y: Int)
typeOf[C].members.collect{case x: MethodSymbol => x}.filter(_.isCaseAccessor)
 typeOf[C].members.collect{case m: MethodSymbol if m.isCaseAccessor => (m.name -> m.returnType)}
class C(val x: Int, val y: Int)
typeOf[C].members.sorted
case class C(val x: Int, val y: Int)
typeOf[C].members.sorted
  val Listing, Album = Value
}
typeOf[ResponseType.Value].asInstanceOf[TypeRef].pre.typeSymbol
typeOf[ResponseType.Value].owner
typeOf[ResponseType.Value].typeSymbol
typeOf[ResponseType.Value].typeSymbol.owner
cm.reflectModule(res0)
cm.reflectModule(res0.asModule)
val moduleClass = typeOf[ResponseType.Value].asInstanceOf[TypeRef].pre.typeSymbol
val module = moduleClass.owner.member(moduleClass.name.toTermName)
val module = moduleClass.owner.typeSignature.member(moduleClass.name.toTermName)
cm.reflectModule(res0.asModule)
val module = moduleClass.owner.typeSignature
val module = moduleClass.owner.typeSignature.member(moduleClass.name.toTermName)
cm.reflectModule(module.asModule)
cm.reflectModule(module.asModule).instance
val moduleClass = typeOf[ResponseType.Value].asInstanceOf[TypeRef].pre.typeSymbol
val module = moduleClass.owner.typeSignature.member(moduleClass.name.toTermName)
cm.reflectModule(module.asModule).instance
case class C
typeOf[C].declarations
typeOf[C.type].declarations
typeOf[C.type].typeSymbol
typeOf[C.type].typeSymbol.name
typeOf[C].typeSymbol
res2 == res4
typeOf[C].owner.typeSymbol
typeOf[C].typeSymbol.owner.typeSignature
typeOf[C.type].typeSymbol.owner.typeSignature
case class C; def C(x: Int) = ???
typeOf[C].typeSymbol.owner.typeSignature
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C"))
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C")).asModule
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C")).suchThat(_.isModule)
typeOf[C].typeSymbol.owner.typeSignature.member(newTermName("C")).suchThat(_.isModule).asModule
showRaw(typeOf[Int])
showRaw(typeOf[Int].typeSymbol)
showRaw(typeOf[Int].typeSymbol, printKinds = true)
import scala.reflect.runtime.{universe => ru}
ru.showRaw(typeOf[Int])
ru.showRaw(typeOf[Int].typeSymbol, printKinds = true)
tb = cm.mkToolBox()
val tb = cm.mkToolBox()
tb.mirror.classLoader
val tb = cm.mkToolBox()
tb.mirror.classLoader
tb.mirror.classLoader.getClass.getMethods
tb.mirror.classLoader.getClass.getDeclaredMethods
val t1 = tb.parseExpr("1 to 3 map (_+1)")
tb.runExpr(t1)
val t1 = tb.parseExpr("1 to 3 map (_+1)")
val tb = cm.mkToolBox()
val t1 = tb.parseExpr("def foo = 1 to 3 map (_+1); foo")
tb.runExpr(t1)
{
  def main(args: Array[String]) 
  {
    println("test")
  }
}
exit
scala.util.Try(1.toString)
 'scala.util.Try(1.toString)
scala.util.Try(1.toString)
def impl[A](c: reflect.macros.Context) = c.universe.reify(())
def impl[A](c: scala.reflect.macros.Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl[Any]
decl
def impl(c: Context) = c.reify(new { val x = 2 })
def impl(c: Context) = c.universe.reify(new { val x = 2 })
def foo = macro impl
foo
scala.reflect.runtime.universe.reify(new {val x = 2 })
class C
type X = C with { val amount: Int }
type X = { val amount: Int }
type X = { val amount: Int } with C
type X = ({ val amount: Int }) with C
type X = C with ({ val amount: Int })
case class C(x: Int, y: Int)
typeOf[C].members.collect{ case x: TermSymbol => x }
typeOf[C].members.collect{ case x: TermSymbol if x.isCaseAccessor => x }
typeOf[C].members.collect{ case x: TermSymbol if x.isCaseAccessor && x.isMethod => x }
typeOf[C].members.sorted.collect{ case x: TermSymbol if x.isCaseAccessor && x.isMethod => x }
exit
case class Test(a:String,b:List[Int])
typeOf[Test]
res0.members
res1.filter(_.isMethod).map(_.asMethod).toArray
val ms = res2.toList
val methods = res2.toList
val mirroredMethods = methods.flatMap(e => try
 {Some(lookAtMe.reflectMethod(e))} catch {case e:Throwable =>
 e.printStackTrace();None})
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass
sym.isSealed
res0.isSealed
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.isSealed
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.initialize
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.typeSignature
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.isSealed
val n = 1
ClassTag.Int.runtimeClass
n.getClass
classManifest[Object]
classManifest[List]
classManifest[List[_]]
classTag[List[_]]
classManifest[Int]
classManifest[String]
exit
classTag[List[_]]
classManifest[List[_]]
classManifest[String]
classManifest[String].toString
classManifest[Array[Int]]
classTag[Int]
classTag[Array[Int]]
classManifest[Array[Int]].erasure
res7.isArray
import scala.runtime.ScalaRunTime._
arrayElementClass(res7)
class C[T]
reify { object O; O }
reify { object O; O.asInstanceOf[Object] }
classTag[String].newArray(10)
ClassTag.Object
ClassTag.Object.runtimeClass
class W extends scala.annotation.Annotation
trait A {
     | @W val a: Int
     | }
trait A { @W val a: Int }
typeOf[A].members.last
res0.annotations
res0.getAnnotations
res0.initialize
res0.typeSignature
res0.getAnnotations
typeOf[A].members
cla
class ValueClass(val x: Int) extends AnyVal
def foo(x: Any) = x
foo(new ValueClass(1))
val x = new ValueClass(1)
foo(x)
classTag[ValueClass].runtimeClass.isAssignableFrom(x.getClass)
x.getClass
class ValueClass(val x: Int) extends AnyVal
new ValueClass(1).getClass
exit
classManifest[List[_]]
manifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exit
classManifest[List[_]]
exity
exit
class W extends scala.annotation.StaticAnnotation
class A { @W def x: Int = ??? }
typeOf[A].members.last
res0.typeSignature
res0.getAnnotations
typeOf[A].members
typeOf[A].members.first
typeOf[A].members(0)
typeOf[A].members.toList(0)
res6.getAnnotations
exit
class W extends scala.annotation.Annotation
class A { @W def x: Int = ??? }
typeOf[A].members.toList(0)
res0.getAnnotations
res0.typeSignature
res0.getAnnotations
exit
class W extends scala.annotation.StaticAnnotation
trait A { @W val a : Int }
typeOf[A].members.last
res0.getAnnotations
res0.typeSignature
res0.getAnnotations
exit
class W extends scala.annotation.Annotation
class W extends scala.annotation.StaticAnnotation
trait A { @W val a: Int }
typeOf[A].members.last
res0.getAnnotations
trait A { @W def a: Int }
typeOf[A].members.last
res2.getAnnotations
class W extends scala.annotation.ClassfileAnnotation
typeOf[scala.collection.immutable.List[_]].typeSymbol.asClass.isSealed
type Foo = Annotation
type Foo = java.reflect.Annotation
type Foo = java.lang.reflect.Annotation
type Foo = java.lang.Annotation
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
val t = typeOf[Outer[Int]]
 val m = t.member(newTermName("m"))
m.typeSignature
m.typeSignatureIn(SuperType(ThisType(t.typeSymbol), t))
m.typeSignatureIn(t)
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
val t = typeOf[Outer[Int]]
 val m = t.member(newTermName("m"))
m.typeSignatureIn(t)
m.typeSignatureIn(SuperType(ThisType(t.typeSymbol), t))
m.typeSignatureIn(SingleType(t))
m.typeSignatureIn(t.narrow)
t.narrow
m.typeSignatureIn(SingleType(NoPrefix, t))
reify('foo)
typeOf[String]
weakTypeOf[String]
val tb = cm.mkToolBox(options = "-Yreify-copypaste")
tb.parseExpr("scala.reflect.runtime.universe.reify(2)")
tb.runExpr(res0)
val tb = cm.mkToolBox(options = "-Yreify-copypaste")
tb.parseExpr("scala.reflect.runtime.universe.reify(2)")
tb.runExpr(res0)
val a = 0.9
cm.reflect(a).symbol.asType <:< typeOf[Double]
cm.reflect(a).symbol.typeSignature <:< typeOf[Double]
cm.reflect(a).symbol.typeSignature
cm.reflect(a).symbol.toType
val a = 0.9
val t = cm.reflect(a).symbol.toType
t <:< typeOf[Double]
tpnme.ANON_CLASS_NAME
Apply(Select(
  Block(List(ClassDef(
    Modifiers(FINAL), tpnme.ANON_CLASS_NAME, Nil, 
    Template(List(Ident(AnyRefClass)), emptyValDef, Nil))),
  Apply(Select(New(Ident(tpnme.ANON_CLASS_NAME)), nme.CONSTRUCTOR), Nil))
, sn.GetClass), Nil)
Apply(Select(
  Block(List(ClassDef(
    Modifiers(scala.tools.nsc.symtab.Flags.FINAL), tpnme.ANON_CLASS_NAME, Nil, 
    Template(List(Ident(AnyRefClass)), emptyValDef, Nil))),
  Apply(Select(New(Ident(tpnme.ANON_CLASS_NAME)), nme.CONSTRUCTOR), Nil))
, sn.GetClass), Nil)
val t = typeOf[Outer[Int]]
class Outer[T] { trait Inner[T]; def m(): Inner[T] = null }
 val m = t.member(newTermName("m"))
val t = typeOf[Outer[Int]]
 val m = t.member(newTermName("m"))
m.typeSignatureIn(t)
m.typeSignatureIn(ThisType(t.typeSymbol))
m.typeSignatureIn(ThisType(t))
showRaw(t)
m.typeSignatureIn(ThisType(t.typeSymbol))
m.typeSignatureIn(t)
m.typeSignatureIn(t).narrow
m.typeSignatureIn(SingleType(t.pre))
m.typeSignatureIn(SingleType(t.pre, t.typeSymbol))
type T = { def x: Int }
type U = { def y: Int}
type Z = T with U
import scala.reflect.runtime.universe._
// example 1
implicit val intTag = typeTag[Int]
import scala.reflect.runtime.universe._
// example 1
def foo[T](implicit tag: TypeTag[T]) = typeTag[Array[T]]
foo[List[Int]]
// example 2
val tpe = typeOf[Int]
appliedType(definitions.ArrayClass.asType, tpe)
appliedType(definitions.ArrayClass.toType, tpe)
appliedType(definitions.ArrayClass.toType, List(tpe))
val tpe = typeOf[List[Int]]
appliedType(definitions.ArrayClass.toType, List(tpe))
trait C { def x: Int }
trait T { def x: Int }
type E = { def y: Int }
type U = T with E
class C extends C { def x = 2; def y = 2 }
class C extends T { def x = 2; def y = 2 }
val u: U = new C
u.x
u.y
(int)null
null.asInstanceOf[Int]
object Foo { def unapply(x: Int): Option[Boolean] = Some(true) }
2 match { case Foo(x) => x }
import scala.collection.immutable.ListMap
ListMap(List((1, 2)))
List((1, 2)).toListMap
List((1, 2)).toMap
ListMap(List((1, 2)).toMap)
ListMap(List(1 -> 2))
ListMap(List(1 -> 2): _*)
import scala.collection.immutable.ListMap
ListMap(1 -> 2)
ListMap(1 -> 2).toList
typeOf[Foo].typeSymbol
exit
typeOf[Foo].typeSymbol
exit
val b: Any = true
b match { case b: Boolean => println(b) }
b.getClass
b match { case b: scala.Boolean => println(b) }
Array(1).getClass.isArray
Array(1, 2).asInstanceOf[Array[_]]
"11".substring(0, 1)
import scala.collection.immutable.ListMap
ListMap(1 -> 2, 3 -> 4)
class W extends scala.annotation.StaticAnnotation
trait A { @W def x: Int }
typeOf[A].declarations.toList
typeOf[A].declarations.head.getAnnotations
trait A { @W val x: Int }
typeOf[A].declarations.head.getAnnotations
typeOf[A].declarations
typeOf[A].declarations.head
typeOf[A].declarations.head.asMethodSymbol
typeOf[A].declarations.head.asMethod
typeOf[A].declarations.head.asMethod.field
typeOf[A].declarations.head.asMethod.accessed
class W extends scala.annotation.StaticAnnotation
trait A { @W val x: Int }
class C extends A
class C extends A { val x = 2 }
typeOf[C].declarations
typeOf[C].declarations.toList(1)
typeOf[C].declarations.toList(1).getAnnotations
typeOf[C].declarations.toList(2).getAnnotations
class W extends scala.annotation.StaticAnnotation
trait T { @W val x: Int }
typeOf[T].declarations
typeOf[T].declarations.head.getAnnotations
trait T { @(W @scala.annotation.meta.getter) val x: Int }
typeOf[T].declarations.head.getAnnotations
class C { val x: Int }
class C extends T { val x: Int = 2 }
typeOf[C].declarations
typeOf[C].declarations.toList(1).getAnnotations
typeOf[C].declarations.toList(2).getAnnotations
class W extends scala.annotation.ClassfileAnnotation
implicit object Foo
lazy object Foo
classOf[Array[_]
]
res0.isArray
classOf[Array[_]]
import java.lang.annotation.Annotation
def foo(c: Context) = { import c.universe._; ??? }
typeOf[List[_]].typeSymbol.asClass
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass
res1.isSealed
exit
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass
res0.isSealed
exit
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass
res0.isSealed
exit
val tb1 = cm.mkToolBox()
var i = 0
val action = reify { i += 1; println(i) }.tree
tb1.runExpr(action)
tb1.eval(action)
tb1.frontEnd.reset()
tb1.eval(action)
cm.mkToolBox()
tb.parse("def x = {}")
res0.parse("def x = {}")
res0.parse("def x = {")
res0.parse("def x = {}")
def impl[A](c: Context) = c.reify(())
def impl[A](c: Context) = c.universe.reify(())
def decl[A] = macro impl[A]
decl
val tb = cm.mkToolBox()
val expr = tb.parse("1 to 3 map (_+1)")
tb.typeCheck(expr)
scala.reflect.runtime.universe.reify(2)
reflect.runtime.universe.reify("foo")
scala.reflect.runtime.universe.reify("foo")
exit
val x = 0, y = 1
val x = 0; val y = 1
val tb = cm.mkToolBox()
tb.eval(tb.parse("math.sqrt(4.0)"))
tb.eval(tb.parse("1 to 5"))
tb.frontEnd.reset
tb.eval(tb.parse("1 to 5"))
tb.eval(tb.parse("scala.math.sqrt(4.0)"))
tb.eval(tb.parse("import scala._; import Predef._; math.sqrt(4.0)"))
tb
tb.eval(tb.parse("object C"))
tb.eval(ModuleDef(NoMods, newTermName("C"), Template(Nil, emptyValDef, Nil)))
scala.reflect.runtime.universe.typeOf[List].isSealed
scala.reflect.runtime.universe.typeOf[List[_]].isSealed
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass.isSealed
exit
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass.isSealed
exit
scala.reflect.runtime.universe.typeOf[List[_]].typeSymbol.asClass.isSealed
exit
tb.eval(tb.parse("object C; C"))
tb.eval(tb.parse("object C"))
tb.eval(tb.parse("scala.math.sqrt(4.0)"))
def echoThisImpl(c:Context): c.Expr[Any] = {
  import c.universe._
  val selfTree = This(c.enclosingClass.symbol)
  c.Expr[AnyRef](selfTree)
}
def echoThisImpl(c:Context): c.Expr[Any] = {
import c.universe._
val selfTree = This(c.enclosingClass.symbol)
c.Expr[AnyRef](selfTree)
}
def echoThis: Any = macro CallMacro.echoThisImpl
def echoThis: Any = macro echoThisImpl
val thisValue = CallMacro.echoThis
val thisValue = echoThis
class C { this }
Map(1 -> 1, 1 ->2 )
typeOf[Int]
classTag[Int]
classOf[Int]
typeOf[Int]
classOf[Int]
typeOf[Int]
typeOf[List[Int]]
reify(2)
classOf[Array[Int]]
classOf[Int]
clssTag[Int]
classTag[Int]
classTag[List[Int]]
classOf[Int]
classTag[Int]
classTag[List[Int]]
typeTag[List[Int]]
typeTag[Int]
def foo[T: ru.TypeTag] = manifest[T]
def foo[T: ClassTag: ru.TypeTag] = manifest[T]
"1\n2".split("\n")
typeOf[Int]
scala.reflect.runtime.universe.typeOf[Int]
exit
typeOf[scala.reflect.runtime.SymbolTable]
res0.baseClasses
res0.typeSymbol.name
res0.typeSymbol.fullName
def allBaseClasses = { def loop(tpe: Type): List[Type] = tpe.baseClasses.filter(_.typeSymbol.fullName.toString startsWith "scala.reflect").map(loop); loop(res0) }
def allBaseClasses = { def loop(tpe: Symbol): List[Symbol] = tpe.baseClasses.filter(_.typeSymbol.fullName.toString startsWith "scala.reflect").map(loop); loop(res0.typeSymbol) }
def allBaseClasses = { def loop(tpe: Symbol): List[Symbol] = tpe.asClass.baseClasses.filter(_.typeSymbol.fullName.toString startsWith "scala.reflect").map(loop); loop(res0.typeSymbol) }
def allBaseClasses = { def loop(tpe: Symbol): List[Symbol] = tpe.asClass.baseClasses.filter(_.fullName.toString startsWith "scala.reflect").map(loop); loop(res0.typeSymbol) }
def allBaseClasses = { def loop(tpe: Symbol): List[Symbol] = tpe.asClass.baseClasses.filter(_.fullName.toString startsWith "scala.reflect").map(loop).flatten; loop(res0.typeSymbol) }
allBaseClasses
def loop(tpe: Symbol): List[Symbol] = { val bases = tpe.asClass.baseClasses.filter(_.fullName.toString startsWith "scala.reflect"); bases.head +: bases.tail.map(loop).flatten }
loop(res0.typeSymbol)
def loop(tpe: Symbol): List[Symbol] = { val bases = tpe.asClass.baseClasses.filter(_.fullName.toString startsWith "scala.reflect.internal"); bases.head +: bases.tail.map(loop).flatten }
loop(res0.typeSymbol)
loop(res0.typeSymbol) map (_.asClass) map (_.typeSignature)
1
val sigs = res7
sigs.flatMap(_.declarations.toList)
val decls = sigs.flatMap(_.declarations.toList)
decls.filter(sym => sym.isVal || sym.isVar).foreach(println)
decls.collect{case ts: TermSymbol => ts}.filter(sym => sym.isVal || sym.isVar).foreach(println)
decls.collect{case ts: TermSymbol => ts}.filter(sym => !sym.name.toString.endsWith("Tag") && (sym.isVal || sym.isVar)).foreach(println)
decls.collect{case ts: TermSymbol => ts}.filter(sym => !sym.name.toString.trim.endsWith("Tag") && (sym.isVal || sym.isVar)).foreach(println)
Some(1).collect{case 1 => 2}
Some(1).collect{case 2 => 2}
import ru.QuasiQuote
import scala.reflect.runtime.universe
import universe.QuasiQuote
exit
:power
val tpe = UniqueConstantType(Constant(StringTpe))
val tpe = ConstantType(Constant(StringTpe))
val tpe = ConstantType(Constant(definitions.StringTpe))
val tpe = ConstantType(Constant(IntTpe))
tpe.underlying
Constant(IntTpe).tpe
afterPhase(1)
afterPhase(erasurePpahse)
afterPhase(erasurePhase)
afterPhase(erasure)
afterPhase(phaseNamed(erasure))
afterPhase(erasure)
afterPhase(run.erasure)
afterPhase(currentRun.erasure)
afterPhase(currentRun.erasurePhase)
ConstantType(Constant(IntTpe)).erasure
typed(1)
typed(Literal(Constant(1))
)
typed(Literal(Constant(1)))
typed(Literal(Constant(1))).tpe
typed(Literal(Constant(1))).tpe.underlying
typed(Literal(Constant(IntTpe))
)
typed(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe))))
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
typed(Apply(Ident(ListModule), List(Literal(Constant(1))))).tpe
afterPhase(currentRun.erasurePhase)(typed(Apply(Ident(ListModule), List(Literal(Constant(1))))).tpe)
New(ConsClass, Literal(Constant(1)), Ident(NilModule))
typed(New(ConsClass, Literal(Constant(1)), Ident(NilModule)))
New(appliedType(ConsClass, List(Ident(IntTpe))), Literal(Constant(1)), Ident(NilModule))
New(appliedType(ConsClass, List(Ident(IntClass))), Literal(Constant(1)), Ident(NilModule))
New(appliedType(ConsClass, Ident(IntClass)), Literal(Constant(1)), Ident(NilModule))
New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule))
typed(New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule)))
typed(New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(Apply(Ident(ListModule), List(Literal(Constant(1))))).tpe)
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, IntTpe), Literal(Constant(1)), Ident(NilModule))).tpe)
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(1)), Ident(NilModule))).tpe
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe)
:power
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe)
typed(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
:power
typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe
afterPhase(currentRun.erasurePhase)(typed(New(appliedType(ConsClass, ObjectTpe), Literal(Constant(null)), Ident(NilModule))).tpe)
typed(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
typed(Literal(Constant(IntClass.asTypeConstructor))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntClass.asTypeConstructor)))).tpe.underlying
macro def foo = ???
exit
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntClass.asTypeConstructor)))).tpe.underlying
exit
val head = typeOf[List[Int]].member(newTermName("head")).asMethod
head.returnType
println(showRaw(head.returnType))
val head = typeOf[List[Int]].member(newTermName("head")).asMethod
val head_a = head.returnType.typeSymbol
val TypeRef(_,_,List(a)) = typeOf[List[_]].typeSymbol.asType.toType
val list_a = a.typeSymbol
head_a eq list_a\
head_a eq list_a
val list = typeOf[List[_]].typeSymbol.asType.toType
val head = typeOf[List[Int]].member(newTermName("head")).asMethod
showRaw(list)
showRaw(head.typeSignature)
showRaw(list.returnType, printIds = true, printKinds = true)
showRaw(list, printIds = true, printKinds = true)
showRaw(head.returnType, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].member(newTermName("head")).typeSignature)
showRaw(typeOf[List[_]].member(newTermName("head")).typeSignature, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].member(newTermName("tail")).typeSignature, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].declaration(newTermName("tail")).typeSignature, printIds = true, printKinds = true)
showRaw(typeOf[List[_]].declaration(newTermName("head")).typeSignature, printIds = true, printKinds = true)
val TypeRef(_, _, List(a)) = typeOf[List[_]].dealias.typeSymbol.asType.toType
val TypeRef(_, _, List(a)) = typeOf[List[_]].normalize.typeSymbol.asType.toType
showRaw(a, printIds = true, printKinds = true)
val TypeRef(_, _, List(type_parameter_of_list)) = typeOf[List[_]].dealias.typeSymbol.asType.toType
val TypeRef(_, _, List(type_parameter_of_list)) = typeOf[List[_]].normalize.typeSymbol.asType.toType
val NullaryMethodType(type_parameter_of_head) = typeOf[List[_]].declaration(newTermName("head")).typeSignature
:power
typed(Literal(Constant(IntTpe))).tpe.underlying
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe.underlying
ConstantType(Constant(IntTpe))
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(IntTpe)))
typed(Literal(Constant(StringTpe))).tpe.underlying
typed(Literal(Constant(StringTpe))).tpe.getClass
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(StringTpe)))
afterPhase(currentRun.erasurePhase)(Literal(Constant(IntTpe)))
afterPhase(currentRun.erasurePhase)(Literal(Constant(IntTpe))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(IntTpe)))).tpe
Constant(IntTpe).tpe
Constant(IntTpe).typeValue
afterPhase(currentRun.erasurePhase)(Constant(IntTpe).typeValue)
afterPhase(currentRun.erasurePhase)(Constant(IntTpe))
afterPhase(currentRun.erasurePhase)(Constant(IntTpe).tpe)
:power
RootClass
RootClass.id
JavaPackage
JavaLangPackageClass.id
JavaLangPackage.id
JavaLangPackageClass.owner
JavaLangPackageClass.owner.id
showRaw(StringTpe, printIds = true)
:power
transformedType
transformedType(IntTpe)
showRaw(res1, printIds = true)
ConstantType(Constant(res1))
ConstantType(Constant(res1)).underlying
typed(Literal(Constant(res2)))
typed(Literal(Constant(res2))).tpe
typed(Literal(Constant(res1))).tpe
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(res1))))
afterPhase(currentRun.erasurePhase)(typed(Literal(Constant(res1)))).tpe
ConstantType(Constant(res1)).getClass
transformedType(StringClass.toType)
showRaw(res11, printIds = true)
ConstantType(Constant(res11))
ConstantType(Constant(res11)).underlying
res11
ConstantType(Constant(res11)).underlying
ConstantType(Constant(res11))
exit
val s = transformedType(StringClass.toType)
:power
val s = transformedType(StringClass.toType)
showRaw(s)
ConstantType(Constant(s))
exit
val s = transformedType(StringClass.toType)
ConstantType(Constant(s))
Constant(s).##
new UniqueConstantType(Constant(s)).##
unique
new UniqueConstantType(Constant(s)) == new UniqueConstantType(Constant(s))
ConstantType(Constant(s)) == ConstantType(Constant(s))
ConstantType(Constant(s)) eq ConstantType(Constant(s))
ConstantType(Constant(s))
ConstantType(Constant(s)).##
:power
val s = transformedType(StringClass.toType)
val s = transformedType(StringClass.asTypeConstructor)
showRaw(s)
ConstantType(Constant(s))
System.identityHashCode(ConstantType(Constant(s)))
uniques
unique
exit
:power
val s = transformedType(StringClass.asTypeConstructor)
val s = transformedType(StringClass.toType)
Constant(StringClass.toType)
Constant(s)
res0.##
res1.##
Constant(s)
Constant(s).##
Constant(StringClass.toType).##
ConstantType(res0).##
ConstantType(res1).##
exit
val s = transformedType(StringClass.toType)
ConstantType(Constant(s))
{ ConstantType(Constant(s)); ConstantType(Constant(s)) }
{ println(ConstantType(Constant(s))); afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); }
exit
:power
val s = transformedType(StringClass.toType)
{ val t1 = ConstantType(Constant(s))); println(t1.underlying); val t2 = afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); println(t2.underlying); }
{ val t1 = ConstantType(Constant(s)); println(t1.underlying); val t2 = afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); println(t2.underlying); }
{ val t1 = ConstantType(Constant(s)); println(t1.underlying); val t2 = afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); println(t2.underlying); println(t2) }
{ val t1 = ConstantType(Constant(s)); println(t1.underlying); println(afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))); }
{ val t1 = ConstantType(Constant(s)); println(afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))); }
{ println(afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))); }
Seq(1, 2).toString
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
{ afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s))); ConstantType(Constant(s)) }
:power
val s = transformedType(StringClass.toType)
afterPhase(currentRun.erasurePhase)(ConstantType(Constant(s)))
cm.staticModule("scala.math.package")
cm.reflectModule(res0)
res1.runtimeClass
res1.instance
NoSymbol.baseClasses
EnumType(NoSymbol)
EnumType(IntClass)
q""
typeOf[List[_]].typeSymbol.asClass.isSealed
trait A { type T <: A }
trait B { type T <: B }
glb(typeOf[A], typeOf[B])
glb(List(typeOf[A], typeOf[B]))
ru.asInstanceOf[scala.reflect.internal.Types].uniques
ru.asInstanceOf[scala.reflect.internal.Types].uniques.asInstanceOf[scala.reflect.internal.util.HashSet[_]]
trait A { type T <: A }
trait B { type T <: B }
uniques
glb(List(typeOf[A], typeOf[B]))
uniques
glb(List(typeOf[A], typeOf[B]))
uniques
trait A1 { type T <: A1 }
trait B1 { type T <: B1 }
uniques
glb(List(typeOf[A1], typeOf[B1]))
uniques
glb(List(typeOf[A1], typeOf[B1]))
uniques
Runtime.freeMemort
Runtime.freeMemory
Runtime.freeMemory()
java.lang.Runtime.freeMemory()
Runtime.getRuntime().freeMemory()
Array(1, 2).sum
val arr = Array(1, 2)
arr.toArray[Any]
trait A { type T <: A }
trait B { type T <: B }
typeOf[A with B]
typeOf[List[List[A with B]]]
scala.math.`package`
def impl(c: Context) = c.literal(c.compilerSettings)
def impl(c: Context) = c.literal(c.compilerSettings.toString)
def foo = macro impl
foo
def impl(c: Context) = c.literal(show(c.libraryClassLoader))
def foo = macro impl
foo
val cache = scala.collection.mutable.HashMap[scala.reflect.macros.Context#Run, Int]()
def impl(c: Context) = c.literal(cache(c.currentRun) = cache.getOrElseUpdate(c.currentRun, 0) + 1)
def impl(c: Context) = c.literal({cache(c.currentRun) = cache.getOrElseUpdate(c.currentRun, 0) + 1; cache(c.currentRun)})
def foo = macro impl
foo
{ foo; foo }
def foo[T] = println(showRaw(weakTypeOf[List[T]]))
foo
typeOf[scala.math.type]
typeOf[scala.math.`package`.type]
res1.typeSymbol
showRaw(res1.typeSymbol.flags)
res1.typeSymbol.isPackageClass
res1.typeSymbol.isModuleClass
List() forall (_ % 2 == 1)
List[Int]() forall (_ % 2 == 1)
shiowRaw(res0.staticCpe)
showRaw(res0.staticTpe)
showRaw(res0.)
showRaw(res0.ac
showRaw(res0.ac))
showRaw(res0.actualTpe)
res0.
))
showRaw(res0.staticType)
List().toHashSet
